#include "ns_time_path_solver.h"
#include "ns_image_server.h"
#include "hungarian.h"

using namespace std;


const int ns_hungarian_impossible_value(std::numeric_limits<int>::max()/2);

ns_time_path_solver_parameters ns_time_path_solver_parameters::default_parameters(const unsigned long experiment_length_in_seconds,
														const unsigned long short_capture_interval_in_seconds_,
														const unsigned long number_of_consecutive_sample_captures_,
														const unsigned long number_of_samples_per_device_){

					
	ns_time_path_solver_parameters param;
	param.short_capture_interval_in_seconds = short_capture_interval_in_seconds_;
	param.number_of_consecutive_sample_captures = number_of_consecutive_sample_captures_;
	param.number_of_samples_per_device = number_of_samples_per_device_;

	const bool short_experiment(experiment_length_in_seconds <  4.5*24*60*60);
	param.fraction_of_points_allowed_to_be_missing_in_path_fragment = .5;  //allow 25% of points to be missing
	param.stationary_object_path_fragment_window_length_in_seconds = 8.0*60.0*60.0/param.maximum_object_detection_density_in_events_per_hour();  // enough time to capture 8 events
	param.min_stationary_object_path_fragment_duration_in_seconds = short_experiment?(3*60*60):(6*60*60);  
	param.stationary_object_path_fragment_max_movement_distance = 20; //pixels
	param.maximum_time_between_joined_path_fragments = short_experiment?3*24*60*60:12*60*60; 
	param.maximum_distance_betweeen_joined_path_fragments = 30;
	param.min_final_stationary_path_duration_in_minutes = short_experiment?1.5*60.0:9*60;
	param.maximum_path_fragment_displacement_per_hour = .9;
	param.max_average_final_path_average_timepoint_displacement = 4;
	return param;
}


ns_time_path_solver_parameters ns_time_path_solver_parameters::default_parameters(const unsigned long sample_region_image_info_id, ns_sql & sql){
	sql << "SELECT s.id, s.device_name, s.experiment_id, s.device_capture_period_in_seconds,s.number_of_consecutive_captures_per_sample FROM capture_samples as s, sample_region_image_info as r WHERE r.id =" << sample_region_image_info_id << " AND r.sample_id = s.id";
	ns_sql_result res;
	sql.get_rows(res);
	if (res.empty())
		throw ns_ex("ns_time_path_solver_parameters::default_paramers()::Could not find region id") << sample_region_image_info_id << " in the database!";
	const unsigned long device_capture_period_in_seconds(atol(res[0][3].c_str()));
	const unsigned long number_of_consecutive_captures_per_sample(atol(res[0][4].c_str()));
	const unsigned long experiment_id(atol(res[0][2].c_str()));
	sql << "SELECT count(*) FROM capture_samples WHERE device_name = '" << res[0][1] << "' AND experiment_id = " << res[0][2];
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("ns_time_path_solver_parameters::default_paramers()::Could not count the number of capture samples on the region's device");
	const unsigned long number_of_samples(atol(res[0][0].c_str()));
	sql << "SELECT first_time_point,last_time_point FROM experiments WHERE id = " << experiment_id;
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("ns_time_path_solver_parameters::default_paramers()::Could not find experiment boundaries!");
	const unsigned long experiment_duration(atol(res[0][1].c_str())-atol(res[0][0].c_str()));
	return default_parameters(experiment_duration,device_capture_period_in_seconds,number_of_consecutive_captures_per_sample,number_of_samples);
}

ns_time_path_solution_stationary_drift_estimator ns_time_path_solver::get_drift_estimator(const unsigned long path_id){
	ns_time_path_solution_stationary_drift_estimator estimator;
	estimator.path_id = path_id;
	ns_time_path_solver_path &path(paths[path_id]);
	int head_size(path.elements.size());
	if (head_size > 5)
		head_size = 5;
	if (head_size == 1){
		estimator.estimation_position = element(*path.elements.begin()).e.center;
		estimator.estimation_time = time(*path.elements.begin());
		estimator.estimation_drift = ns_vector_2d(0,0);
		return estimator;
	}
	
	estimator.estimation_position = element(*path.elements.begin()).e.center;
	estimator.estimation_time= time(*path.elements.begin())- time(*path.elements.rbegin());
	estimator.estimation_drift = ns_vector_2d(0,0);
	//unsigned long delta_t;
	for (unsigned int i = 1; i < head_size; i++){

		const ns_vector_2i & p0(element(path.elements[i]).e.center),
						& p1(element(path.elements[i-1]).e.center);
		const double & t0(time(path.elements[i])),
						& t1(time(path.elements[i-1]));
		estimator.estimation_position+=p0;
		estimator.estimation_time+=(t0-time(*path.elements.rbegin()));
		estimator.estimation_drift+=(p0-p1)/(t0-t1);
	}
	estimator.estimation_position/=head_size;
	estimator.estimation_time/=head_size;
	estimator.estimation_time+=time(*path.elements.rbegin());
	estimator.estimation_drift/=(head_size-1);

	//when trying to match other paths to this one
	//you'll want to find paths that connect with the earliest point in this path.
	estimator.match_position = element(*path.elements.rbegin()).e.center;
	estimator.match_time = time(*path.elements.rbegin());
	estimator.path_bound_max = path.max_time;
	estimator.path_bound_min = path.min_time;
	return estimator;
}
ns_vector_2d ns_time_path_solution_stationary_drift_estimator::estimate(const unsigned long time) const{
	return estimation_position+estimation_drift*(time-estimation_time);
}

void ns_time_path_solver::solve(const ns_time_path_solver_parameters &param, ns_time_path_solution & solve){

	//first we find all paths that are long enough and consistant enough to be real
	//note we discard lots of stray points here
	find_stationary_path_fragments(param.maximum_object_detection_density_in_events_per_hour()*param.fraction_of_points_allowed_to_be_missing_in_path_fragment,
				   param.min_stationary_object_path_fragment_duration_in_seconds,
				   param.stationary_object_path_fragment_window_length_in_seconds,
				   param.stationary_object_path_fragment_max_movement_distance);
	
	//remove fragments that move to much
	for (std::vector<ns_time_path_solver_path>::iterator p = paths.begin(); p != paths.end();){
		const double displacement_per_hour((p->max_time_position-p->min_time_position).mag()/(double)((p->max_time-p->min_time)/60.0/60.0));
		if (displacement_per_hour > param.maximum_path_fragment_displacement_per_hour)
			p = paths.erase(p);
		else p++;
	}

	for (vector<ns_time_path_solver_path>::iterator p = paths.begin(); p != paths.end();p++){
		for (unsigned int i = 1; i < p->elements.size(); i++){
			if (p->elements[i-1].t_id <= p->elements[i].t_id)
				throw ns_ex("Out of order paths were produced!");
		}
	}
	//then we merge all appropriate path centers together
	//(which, for example, means that if we don't measure a plate for a day
	//but get good worm data before and after it, the paths will be correctly
	//linked together accross the gap.
	
	for (unsigned int i = 0; i < paths.size(); i++){
		if (element(paths[i].elements[0]).e.center.x == 5107)
			break;
	}
	merge_overlapping_path_fragments(param.maximum_distance_betweeen_joined_path_fragments,
									 param.maximum_time_between_joined_path_fragments);

	for (vector<ns_time_path_solver_path>::iterator p = paths.begin(); p != paths.end();p++){
		for (unsigned int i = 1; i < p->elements.size(); i++){
			if (p->elements[i-1].t_id <= p->elements[i].t_id)
				throw ns_ex("Out of order paths were produced!");
		}
	}
	//remove short paths
	for (std::vector<ns_time_path_solver_path>::iterator p = paths.begin(); p != paths.end();){
		if (((p->max_time-p->min_time)/60) < param.min_final_stationary_path_duration_in_minutes){
			p = paths.erase(p);
			continue;
		}
		else p++;
	}

	//remove paths that move too much.
	for (std::vector<ns_time_path_solver_path>::iterator p = paths.begin(); p != paths.end();){
		
		double avg_delta(0);
		for (unsigned int i = 1; i < p->elements.size(); i++){
			avg_delta+=(element(p->elements[i]).e.center-element(p->elements[i-1]).e.center).mag();
		}
		avg_delta/=p->elements.size();
		if (avg_delta > param.max_average_final_path_average_timepoint_displacement)
			p = paths.erase(p);
		else p++;
	}
	find_low_density_stationary_paths(param.min_final_stationary_path_duration_in_minutes,
				   param.stationary_object_path_fragment_max_movement_distance/2);

	handle_low_density_stationary_paths_and_stray_points(param.maximum_distance_betweeen_joined_path_fragments/2,param.min_final_stationary_path_duration_in_minutes);
	
	assign_path_ids_to_elements();

	transfer_data_to_solution(solve);
}

void ns_time_path_solution::save_to_db(const unsigned long region_id, ns_sql & sql) const{
	sql << "SELECT time_path_solution_id FROM sample_region_image_info WHERE id = " << region_id;
	ns_sql_result res;
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("ns_time_path_solution::save_to_db():Could not load info from db");
	ns_image_server_image im;
	im.id = atol(res[0][0].c_str());
	bool update_db(false);
	if (im.id == 0){
		im = image_server.image_storage.get_region_movement_metadata_info(region_id,"time_path_solution_data",sql);
		update_db = true;
	}
	ofstream * o(image_server.image_storage.request_metadata_output(im,"csv",false,&sql));
	im.save_to_db(im.id,&sql);

	if (ns_dir::extract_extension(im.filename) != "csv")
		update_db = true;
	try{
		save_to_disk(*o);
		delete o;
	}
	catch(...){
		delete o;
		throw;
	}
	if (update_db){
		sql << "UPDATE sample_region_image_info SET time_path_solution_id = " << im.id << " WHERE id = " << region_id;
		sql.send_query();
	}

}
void ns_time_path_solution::load_from_db(const unsigned long region_id, ns_sql & sql){
	sql << "SELECT time_path_solution_id FROM sample_region_image_info WHERE id = " << region_id;
	ns_sql_result res;
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("ns_time_path_solution::load_from_db():Could not load info from db");
	ns_image_server_image im;
	im.id = atol(res[0][0].c_str());
	if (im.id == 0)
		throw ns_ex("Solution data has not been stored in db");
	ifstream * i(image_server.image_storage.request_metadata_from_disk(im,false,&sql));

	try{
		load_from_disk(*i);
		delete i;
	}
	catch(...){
		delete i;
		throw;
	}
}
//it would be nice to use XML here but it is so verbose!
void ns_time_path_solution::save_to_disk(ostream & o) const{
	//output time points
	for (unsigned int i = 0; i < timepoints.size(); i++){
		o << "t," << timepoints[i].time << "," << timepoints[i].sample_region_image_id << ",,,,\n";
	}

	//output worm data
	for (unsigned int i = 0; i < timepoints.size(); i++){
		for (unsigned int j = 0; j < timepoints[i].elements.size(); j++){
			o << "e," << i << ","
					  << timepoints[i].elements[j].region_position.x << ","
					  << timepoints[i].elements[j].region_position.y << ","
					  << timepoints[i].elements[j].context_image_position_in_region_vis_image.x << ","
					  << timepoints[i].elements[j].context_image_position_in_region_vis_image.y << ","
					  << timepoints[i].elements[j].region_size.x << ","
					  << timepoints[i].elements[j].region_size.y << ","
					  << timepoints[i].elements[j].context_image_position.x << ","
					  << timepoints[i].elements[j].context_image_position.y << ","
					  << timepoints[i].elements[j].context_image_size.x << ","
					  << timepoints[i].elements[j].context_image_size.y << ","
					  << timepoints[i].elements[j].low_temporal_resolution << ","
					  << timepoints[i].elements[j].slowly_moving << ","
					  << (timepoints[i].elements[j].part_of_a_multiple_worm_disambiguation_cluster?"1":"0") << ",,,,\n";
		}
	}
	
	//output paths
	for (unsigned int i = 0; i < paths.size(); i++){
		o << "p," << paths[i].center.x << "," 
				  << paths[i].center.y << ","
				  <<  "0,"  //reserved for future use
				  << paths[i].is_low_density_path << ",,,,\n";
	}
	//output path membership
	for (unsigned int i = 0; i < paths.size();i++){
		for (unsigned int j = 0; j < paths[i].stationary_elements.size(); j++){
			o << "l," << i << ","
					  << paths[i].stationary_elements[j].index << ","
					  << paths[i].stationary_elements[j].t_id << ",0\n";
		}
		for (unsigned int j = 0; j < paths[i].moving_elements.size(); j++){
			o << "l," << i << ","
					  << paths[i].moving_elements[j].index << ","
					  << paths[i].moving_elements[j].t_id << ",1\n";
		}
	}
	//output unassigned points
	for (unsigned int i = 0; i < unassigned_points.stationary_elements.size(); i++){
		o << "l," << "-1," 
				  << unassigned_points.stationary_elements[i].index << ","
				  << unassigned_points.stationary_elements[i].t_id << "\n";
	}
	//output path groups
	for (unsigned int i = 0; i < path_groups.size(); i++){
		o << "g," << path_groups[i].path_ids.size();
		for (unsigned int j = 0; j < path_groups[i].path_ids.size(); j++)
			o << "," << path_groups[i].path_ids[j];
		o << "\n";
	}
}/*
class ns_get_int{
	public:
	template<class T>
	inline void operator()(istream & in, T & d){
		in >> tmp;
		d = atol(tmp.c_str());
	}
	private:
	string tmp;
};
*/
void ns_time_path_solution::check_for_duplicate_events(){
	for (unsigned int i = 0; i < timepoints.size(); i++){
		for (unsigned int j = 0; j < timepoints[i].elements.size(); j++){
			for (unsigned int k = j+1; k < timepoints[i].elements.size(); k++){
				if (timepoints[i].elements[j].center == timepoints[i].elements[k].center &&
					!timepoints[i].elements[j].part_of_a_multiple_worm_disambiguation_cluster &&
					!timepoints[i].elements[k].part_of_a_multiple_worm_disambiguation_cluster
					)
					throw ns_ex("ns_time_path_solution::check_for_duplicate_events()::A worm seems to have been duplicated.");
			}
		}
	}
};

void ns_time_path_solution::load_from_disk(istream & in){
	clear();
	timepoints.reserve(100);
	paths.reserve(20);
	path_groups.reserve(10);
	worms_loaded = false;

	ns_get_int get_int;
	string tmp;
	while(true){
		string op_str;
		get_int(in,op_str);
		if (in.fail())
			break;
		if(op_str.size() != 1)
			throw ns_ex("ns_time_path_solution::load_from_disk()::Invalid op specification:") << op_str;
		char op(op_str[0]);
	//	cerr << op << " ";
		switch(op){
			case 't':{
				unsigned long s = timepoints.size();
				timepoints.resize(s+1);
				get_int(in,timepoints[s].time);
				get_int(in,timepoints[s].sample_region_image_id);
				for (unsigned int i = 0; i < 4; i++) get_int(in,tmp); //room for expansion
				timepoints[s].elements.reserve(10);
				break;
			}
			case 'e':{
				unsigned long timepoint_id;
				get_int(in,timepoint_id);
				if (timepoint_id >= timepoints.size())
					throw ns_ex("ns_time_path_solution::load_from_disk()::Invalid timepoint id: ")<< timepoint_id;
				unsigned long s = timepoints[timepoint_id].elements.size();
				timepoints[timepoint_id].elements.resize(s+1);
				get_int(in,timepoints[timepoint_id].elements[s].region_position.x);
				get_int(in,timepoints[timepoint_id].elements[s].region_position.y);
				get_int(in,timepoints[timepoint_id].elements[s].context_image_position_in_region_vis_image.x);
				get_int(in,timepoints[timepoint_id].elements[s].context_image_position_in_region_vis_image.y);
				get_int(in,timepoints[timepoint_id].elements[s].region_size.x);
				get_int(in,timepoints[timepoint_id].elements[s].region_size.y);
				get_int(in,timepoints[timepoint_id].elements[s].context_image_position.x);
				get_int(in,timepoints[timepoint_id].elements[s].context_image_position.y);
				get_int(in,timepoints[timepoint_id].elements[s].context_image_size.x);
				get_int(in,timepoints[timepoint_id].elements[s].context_image_size.y);
				timepoints[timepoint_id].elements[s].center = timepoints[timepoint_id].elements[s].region_position + timepoints[timepoint_id].elements[s].region_size/2;
				get_int(in,timepoints[timepoint_id].elements[s].low_temporal_resolution);
				get_int(in,timepoints[timepoint_id].elements[s].slowly_moving);
				get_int(in,timepoints[timepoint_id].elements[s].part_of_a_multiple_worm_disambiguation_cluster);
				for (unsigned int i = 0; i < 4; i++) get_int(in,tmp); //room for expansion
				break;
			}
			case 'p':{
				unsigned long s = paths.size();
				paths.resize(s+1);
				get_int(in,paths[s].center.x);
				get_int(in,paths[s].center.y);
				int dummy;
				get_int(in,dummy); //reserved for future use
				get_int(in,paths[s].is_low_density_path);
				for (unsigned int i = 0; i < 4; i++) get_int(in,tmp); //room for expansion
				break;
			}
			case 'l':{
					long path_id,stationary_type;
					ns_time_element_link temp_link;
					get_int(in,path_id);
					get_int(in,temp_link.index);
					get_int(in,temp_link.t_id);
					in.unget();
					char a(in.get());
					if (a!=',')  //no stationary type specified; assume stationary.
						stationary_type = 0;
					else get_int(in,stationary_type);			
					ns_time_path * path;
					if (path_id == -1)
						path = &(this->unassigned_points);	
					else if (path_id >= paths.size())
						throw ns_ex("ns_time_path_solution::load_from_disk()::Invalid path id!");
					else path = &paths[path_id];
					vector<ns_time_element_link> & v(stationary_type==0?path->stationary_elements:path->moving_elements);
					unsigned long s = v.size();
					v.resize(s+1);
					v[s] = temp_link;
				break;
			}
			case 'g':{
				unsigned long s = path_groups.size();
				path_groups.resize(s+1);
				unsigned long number_of_paths;
				get_int(in,number_of_paths);
				path_groups[s].path_ids.resize(number_of_paths);
				for (unsigned int i = 0; i < number_of_paths; i++){
					get_int(in,path_groups[s].path_ids[i]);
				}
				break;
			}
			default:{
				string a;
				a+=op;
				throw ns_ex("ns_time_path_solution::load_from_disk()::Unknown object in path solution: ") << a;
				}
		}
	}
	check_for_duplicate_events();
}


inline void ns_is_interesting_point(const ns_vector_2i &p){
	if (	abs(p.x-3036) < 4	 && abs(p.y-2230) < 4)
			cerr << "Whee";
};
//does not include in the minimization problem any elements with "element_assigned" tag set to true.
void ns_time_path_solver::assign_timepoint_elements_to_paths(std::vector<ns_time_path_solver_element> & elements, const unsigned long max_dist_sq, std::vector<ns_time_path_solver_path_builder> & opaths){
	hungarian_problem_t matching_problem;
	int unassigned_count(0);
	for (unsigned int i = 0; i < elements.size(); i++)
		unassigned_count+=elements[i].element_assigned?0:1;
	if (unassigned_count == 0)
		return;
	int ** cost_matrix = new int *[opaths.size()];
	for (unsigned int i = 0; i < opaths.size(); i++)
		cost_matrix[i] = new int[unassigned_count];
	try{
		for (unsigned int i = 0; i < opaths.size(); i++){
			unsigned long k(0);
			for (unsigned int j = 0; j < elements.size(); j++){
				if (elements[j].element_assigned) 
					continue;
				const unsigned long d((elements[j].e.center-opaths[i].center).squared());
				if (d > max_dist_sq)
					cost_matrix[i][k] = ns_hungarian_impossible_value;
				else 
					cost_matrix[i][k] = d;
				k++;
			}
		}

		hungarian_init(&matching_problem,cost_matrix,
			opaths.size(),//rows
			unassigned_count,	//columns
			HUNGARIAN_MODE_MINIMIZE_COST);

		hungarian_solve(&matching_problem);
		
		int k = 0;
		for (unsigned int j = 0; j < elements.size(); j++){
			if (elements[j].element_assigned){
				elements[j].element_assigned_in_this_round = false;
				continue;
			}
			bool found(false);
			for (unsigned int i = 0; i < opaths.size(); i++){
				if (matching_problem.assignment[i][k] != HUNGARIAN_ASSIGNED ||
					cost_matrix[i][k] == ns_hungarian_impossible_value)
					continue;
				elements[j].path_id = i;
				elements[j].element_assigned_in_this_round = true;
				found = true;
				break;
			}
			if (!found){
			//	ns_is_interesting_point(timepoints[t_id].elements[j].e.center);
				elements[j].element_assigned_in_this_round = false;
			}
			k++;
		}
		hungarian_free(&matching_problem);
		for (unsigned int i = 0; i < opaths.size(); i++)
			delete[] cost_matrix[i];
		delete[] cost_matrix;
	}
	catch(...){
		for (unsigned int i = 0; i < opaths.size(); i++)
			delete[] cost_matrix[i];
		delete[] cost_matrix;
		throw;
	}
}
double ns_time_path_solver_path_builder::calculate_current_density(const unsigned long current_time,const unsigned long time_density_window) const{
	if (elements.size() == 0) return 0;
	unsigned long point_count(0);
	int i;
	for (i = elements.size()-1; i >=0; i--){
		if (elements[i].time > current_time+time_density_window)
			break;
		point_count++;
	}
	if (i < 0){
		if (current_time-elements[0].time == 0)
			return 1.0;
		double t(elements[0].time-current_time);
		return point_count/(double)(t);
	}
	double t(elements[i].time-current_time);
	return point_count/(double)(elements[i].time/t);
}

void ns_time_path_solver_path_builder::calculate_center(const unsigned long time_density_window) const{
	if (elements.empty()){
		center =  ns_vector_2d(0,0);
		return;
	}
	if (time_density_window == 0){
		center = ns_vector_2d(0,0);
		for (unsigned int i = 0; i < elements.size(); i++)
			center+=elements[i].pos;
		center/=elements.size();
		return;
	}
	const unsigned long stop_time(elements.rbegin()->time+time_density_window);
	ns_vector_2d pos(0,0);
	unsigned long count(0);
	for (int i = elements.size()-1; i >=0; i--){
		if (elements[i].time > stop_time)
			break;
		pos+=elements[i].pos;
		count++;
	}
	center = pos/count;
}

ns_time_path_solution_stationary_drift_estimator ns_estimator_for_point(const ns_vector_2i & center,const unsigned long time,const ns_time_element_link & link){
	ns_time_path_solution_stationary_drift_estimator estimator;
	estimator.estimation_position = estimator.match_position = center;
	estimator.estimation_drift = ns_vector_2i(0,0);
	estimator.stray_point_id = link;
	estimator.match_time = estimator.estimation_time = time;
	return estimator;
}

int ns_find_linked(const int id, const int size, int ** assignments){
	for (unsigned int i = 0; i < size; i++){
		if (assignments[id][i] == HUNGARIAN_ASSIGNED)
			return i;
	}
	return -1;
}
struct ns_estimator_group_group{
	ns_estimator_group_group():to_be_deleted(false){}
	ns_estimator_group_group(const ns_time_path_solution_stationary_drift_estimator_group * est, const ns_time_path_solution_stationary_drift_estimator_group * tgt):to_be_deleted(false),estimators(2){
		estimators[0] = est;
		estimators[1] = tgt;
	}
	typedef std::vector<const ns_time_path_solution_stationary_drift_estimator_group * > ns_estimator_list;
	ns_estimator_list estimators;
	bool to_be_deleted;
};

unsigned long  ns_time_path_solver::number_of_stationary_paths_at_time(const unsigned long t) const{
	unsigned long c(0);
	for (unsigned int k = 0; k < paths.size(); k++){
		if (t <= paths[k].max_time &&
			t >= paths[k].min_time)
			c++;
	}
	return c;
}

bool ns_time_path_solver::can_search_for_stray_points_at_time(const ns_time_element_link & l) const{
	return number_of_stationary_paths_at_time(timepoints[l.t_id].time) > number_of_unassigned_points_at_time(l);
}

bool operator < (const ns_time_path_solution_stationary_drift_estimator & l, const ns_time_path_solution_stationary_drift_estimator & r){
	return l.estimation_time < r.estimation_time;
}
typedef map<unsigned long,vector<ns_time_path_solution_stationary_drift_estimator_group *> > ns_sorted_estimator_list;
bool ns_merge_estimator_groups(const unsigned long max_dist_sq, std::vector<ns_time_path_solution_stationary_drift_estimator_group> & e){
	//sort estimators by time
	ns_sorted_estimator_list targets, estimators;
	for (int i = 0; i < e.size(); i++){
		e[i].to_be_deleted = false;
		targets[e[i].estimator().match_time].push_back(&e[i]);
		estimators[e[i].estimator().estimation_time].push_back(&e[i]);
	}
	vector<ns_time_path_solution_stationary_drift_estimator_group *> est;
	for (ns_sorted_estimator_list::iterator t = targets.begin(); t != targets.end(); t++){
		est.resize(0);
		for (ns_sorted_estimator_list::iterator e = estimators.begin(); e != estimators.end(); e++){
			if (e->first >= t->first)
				break;
			for (unsigned int i = 0; i < e->second.size(); i++){
				if (!e->second[i]->to_be_deleted)
				est.push_back(e->second[i]);
			}
		}
		int ** cost_matrix = new int *[est.size()];
		for (unsigned int i = 0; i <est.size(); i++)
			cost_matrix[i] = new int[t->second.size()];

		try{
			//i is the estimator
			for (unsigned int i = 0; i < est.size(); i++){
			
				//j is the target
				for (unsigned int j = 0; j < t->second.size(); j++){
					if (est[i] == t->second[j]){
						//dont attempt to match estimators to themselves!
						throw ns_ex("Shit!");
					}
					//don't allow estimators to chose very far away objects
					double d(est[i]->estimator().estimated_distance_time_invariant(t->second[j]->estimator()));
					if (d < 0 || d > max_dist_sq)
						cost_matrix[i][j] =  ns_hungarian_impossible_value;
					else {
						cost_matrix[i][j] = d;
					}
				}
			}
			/*ofstream o("c:\\grr.csv");
			for (unsigned int i = 0; i < est.size(); i++){
				for (unsigned int j = 0; j < tgt.size(); j++){
					if (cost_matrix[i][j] == ns_hungarian_impossible_value)
						o << ",";
					else o << cost_matrix[i][j] << ",";
				}
				o << "\n";
			}
			o.close();*/
			hungarian_problem_t matching_problem;
			hungarian_init(&matching_problem,cost_matrix,
				est.size(),//rows
				t->second.size(),	//columns
				HUNGARIAN_MODE_MINIMIZE_COST);

			hungarian_solve(&matching_problem);
		
			//merge all the groups
			for (unsigned int i = 0; i < est.size(); i++){
				if (est[i]->to_be_deleted)
					throw ns_ex("Shit shit!");
				const long linked_id = ns_find_linked(i,t->second.size(),matching_problem.assignment);
				if (linked_id != -1 && cost_matrix[i][linked_id] != ns_hungarian_impossible_value){

					//note that the group automatically sorts the new estimators such that the estimator() function will return the corrent one next time
					for (ns_time_path_solution_stationary_drift_estimator_group::ns_estimator_list::iterator p = t->second[linked_id]->estimators.begin();
							p!= t->second[linked_id]->estimators.end(); p++){

						bool element_already_existed(!est[i]->estimators.insert(*p).second);
						if (element_already_existed)
							std::cerr << "WAHA";
					}

					//and any later activity by the little fish is now accomplished by the little fish.
					t->second[linked_id]->to_be_deleted = true;
				}
			}
			hungarian_free(&matching_problem);	
			for (unsigned int i = 0; i < est.size(); i++)
				delete[] cost_matrix[i];
			delete[] cost_matrix;
		}
		catch(...){
			for (unsigned int i = 0; i < est.size(); i++)
				delete[] cost_matrix[i];
			delete[] cost_matrix;
			throw;
		}
	}

	//delete merged groups
	for (std::vector<ns_time_path_solution_stationary_drift_estimator_group>::iterator p = e.begin(); p != e.end();){
		if (p->to_be_deleted || p->estimators.size() <= 1)
			p = e.erase(p);
		else p++;
	}
	return false;
}
/*
bool ns_merge_estimator_groups(const unsigned long max_dist_sq, std::vector<ns_time_path_solution_stationary_drift_estimator_group> & estimators){
	bool changes_made(false);
	for (std::vector<ns_time_path_solution_stationary_drift_estimator_group>::iterator p = estimators.begin(); p != estimators.end();p++){
		p->to_be_deleted = false;
		if ((p->estimator().match_position-ns_vector_2i(3273,3026)).squared() < 100 ||
			(p->estimator().estimation_position-ns_vector_2i(3273,3026)).squared() < 100)
			cerr << "WHA!";
		p->use_as_a_estimator = false;
		p->use_as_a_target = false;
		for (std::vector<ns_time_path_solution_stationary_drift_estimator_group>::iterator q = estimators.begin(); q != estimators.end();q++){
			if (p == q) continue;
			if (!p->use_as_a_estimator && p->time_does_not_overlap(q->estimator())){
				const double d(p->estimator().estimated_distance_time_invariant(q->estimator()));
				if (d >= 0 && d <= max_dist_sq)
					p->use_as_a_estimator = true;
				
			}
			if (!p->use_as_a_target){
				const double d(q->estimator().estimated_distance_time_invariant(p->estimator()));
				if (d >= 0 && d <= max_dist_sq)
					p->use_as_a_target = true;
			}
			if (p->use_as_a_estimator && p->use_as_a_target)
				break;
		}
		
	//	if (!p->use_as_a_estimator && !p->use_as_a_target)
	//		p = estimators.erase(p);
	//	else p++;
	}

	
	//vector<ns_estimator_group_group> estimator_groups;
	{

		vector<ns_time_path_solution_stationary_drift_estimator_group *> est,
																         tgt;
		for (unsigned int i = 0; i < estimators.size(); i++){
			if (estimators[i].use_as_a_estimator)
				est.push_back(&estimators[i]);
			if (estimators[i].use_as_a_target)
				tgt.push_back(&estimators[i]);
		}
		hungarian_problem_t matching_problem;
	

		int ** cost_matrix = new int *[est.size()];
		for (unsigned int i = 0; i <est.size(); i++)
			cost_matrix[i] = new int[tgt.size()];

		try{
			//i is the estimator
			for (unsigned int i = 0; i < est.size(); i++){
			
				//j is the target
				for (unsigned int j = 0; j < tgt.size(); j++){
					if (est[i] == tgt[j]){
						//dont attempt to match estimators to themselves!
						cost_matrix[i][j] = ns_hungarian_impossible_value;
						continue;
					}
					//don't allow estimators to chose very far away objects
					double d(est[i]->estimator().estimated_distance_time_invariant(tgt[j]->estimator()));
					if (d < 0 || d > max_dist_sq)
						cost_matrix[i][j] =  ns_hungarian_impossible_value;
					else {
						cost_matrix[i][j] = d;
					}
				}
			}
			ofstream o("c:\\grr.csv");
			for (unsigned int i = 0; i < est.size(); i++){
				for (unsigned int j = 0; j < tgt.size(); j++){
					if (cost_matrix[i][j] == ns_hungarian_impossible_value)
						o << ",";
					else o << cost_matrix[i][j] << ",";
				}
				o << "\n";
			}
			o.close();
			hungarian_init(&matching_problem,cost_matrix,
				est.size(),//rows
				tgt.size(),	//columns
				HUNGARIAN_MODE_MINIMIZE_COST);

			hungarian_solve(&matching_problem);
			map<ns_time_path_solution_stationary_drift_estimator_group *, ns_time_path_solution_stationary_drift_estimator_group *> merge_lookup;
			for (unsigned int i = 0; i < est.size(); i++){
				merge_lookup[est[i]] = est[i];
			}
			for (unsigned int i = 0; i < tgt.size(); i++){
				merge_lookup[tgt[i]] = tgt[i];
			}
			//merge all the groups
			for (unsigned int i = 0; i < est.size(); i++){
				if (est[i]->to_be_deleted)
					continue;
				const long linked_id = ns_find_linked(i,tgt.size(),matching_problem.assignment);
				if (linked_id != -1 && cost_matrix[i][linked_id] != ns_hungarian_impossible_value){
					changes_made = true;

					map<ns_time_path_solution_stationary_drift_estimator_group *, ns_time_path_solution_stationary_drift_estimator_group *>::
						iterator little_fish(merge_lookup.find(tgt[linked_id]));
					//big fish eats the little fish
					//note that the group automatically sorts the new estimators such that the estimator() function will return the corrent one next time
					for (ns_time_path_solution_stationary_drift_estimator_group::ns_estimator_list::iterator p = little_fish->second->estimators.begin();
							p!= little_fish->second->estimators.end(); p++){

						bool element_already_existed(!est[i]->estimators.insert(*p).second);
						if (element_already_existed)
							cerr << "WAHA";
					}

					//and any later activity by the little fish is now accomplished by the little fish.
					little_fish->second->to_be_deleted = true;
					merge_lookup[tgt[linked_id]] = est[i];
				}
			}
			hungarian_free(&matching_problem);	
			for (unsigned int i = 0; i < est.size(); i++)
				delete[] cost_matrix[i];
			delete[] cost_matrix;
		}
		catch(...){
			for (unsigned int i = 0; i < est.size(); i++)
				delete[] cost_matrix[i];
			delete[] cost_matrix;
			throw;
		}
	}
	//delete merged groups
	for (std::vector<ns_time_path_solution_stationary_drift_estimator_group>::iterator p = estimators.begin(); p != estimators.end();){
		if (p->to_be_deleted)
			p = estimators.erase(p);
		else p++;
	}
	return changes_made;
}
*/
void ns_time_path_solver::handle_low_density_stationary_paths_and_stray_points(const unsigned long max_movement_distance, const double min_final_stationary_path_duration_in_minutes){
	//this is important code.  It takes all the stationary points left in the data set but at low density
	//and handles them correctly.  THis is important to get censoring right (as the censoring algorithm reasons over the moving worms,
	//and low density paths show up as moving worms if not handled correctly.
	//It's also important as the low density paths may actually belong to high density paths but not have been linked in
	//in the path detection.  They are linked in here.


	//here what we do is make a big list of all possible things that may need to be joined
	//ie low density path points, random stray points, and high density path fragments.
	//These are all combined as "estimators" which are wrappers that abstract the idea that
	//to join two objects all that needs to be done is to predict the distance away from
	//one in space the other is.
	//We then use the estimators to make a big cost matrix and run a hungarian algorithm
	//to find the optimal assignments.
	//Note that the hungarian algorithm is done *not* considering time; so everything
	//is joined without regard to how far things are appart in time

	//after everything is joined together, everything might be out of order (i.e paths linked
	//to paths before them) so we sort the joined elements in time and then merge them.
	std::vector<ns_time_path_solution_stationary_drift_estimator_group> estimators;
	estimators.resize(paths.size());

	//add an estimator for each high density path
	for (unsigned int i = 0; i < paths.size(); i++){
		estimators[i].estimators.insert(get_drift_estimator(i));

		if ((estimators[i].estimator().estimate(1316808129) - ns_vector_2d(4303,3901)).squared() < 10)
			cerr << "WHA";
	}
	const unsigned long number_of_path_estimators(estimators.size());
	const unsigned long max_dist_sq(max_movement_distance*max_movement_distance);

	unsigned long va(0),vb(0);

	//identifiy possible stray points

	//mark_unassigned_points should have been done already in previous step
	//but during debugging we do it here just to make sure
	mark_unassigned_points();
	for (unsigned int i = 0; i < low_density_paths.size(); i++){
		for (unsigned int j = 0; j < low_density_paths[i].elements.size(); j++){
			element(low_density_paths[i].elements[j]).element_assigned_in_this_round = true;
			element(low_density_paths[i].elements[j]).element_assigned = false;
		}
	}
	for (unsigned int i = 0; i < timepoints.size(); i++){
		unsigned long number_of_stationary_paths_at_current_time(0);
	
		for (unsigned int k = 0; k < number_of_path_estimators; k++){
			//doint look for points that come before the estimator.
			if (//timepoints[i].time <= estimators[k].estimator().estimation_time ||  
				!can_search_for_stray_points_at_time(ns_time_element_link(i,0)))

				continue;
				
		/*	//for timepoints where there are very few unassigned points, just add them all to the mix.
			unsigned long number_of_unassigned_points(0);
			for (unsigned int j = 0; j < timepoints[i].elements.size(); j++){
				if (!timepoints[i].elements[j].element_assigned)
					number_of_unassigned_points++;
			}*/
			
			//otherwise look through all unassigned points and add ones that can be assigned somewhere
			for (unsigned int j = 0; j < timepoints[i].elements.size(); j++){
				 if ((timepoints[i].elements[j].e.center - ns_vector_2d(4303,3901)).squared() < 10)
					 cerr << "Yes";

				if ( timepoints[i].elements[j].element_assigned || timepoints[i].elements[j].element_assigned_in_this_round)
					continue;
				const double d((timepoints[i].elements[j].e.center - estimators[k].estimator().estimate(timepoints[i].time)).squared()); 
				if (d <= max_dist_sq){
					estimators.push_back(ns_time_path_solution_stationary_drift_estimator_group(
						ns_estimator_for_point(
						timepoints[i].elements[j].e.center,timepoints[i].time,ns_time_element_link(i,j)
						)
						)
						);
					timepoints[i].elements[j].element_assigned = true; //prevent repeat additions
					va++;
				}
			}
		}
	}
	cout << "Added " << va << " from matches\n";

	for (unsigned int i = 0 ; i < low_density_paths.size(); i++){
		for (unsigned int j = 0; j < low_density_paths[i].elements.size(); j++){
			estimators.push_back(ns_estimator_for_point(element(low_density_paths[i].elements[j]).e.center,time(low_density_paths[i].elements[j]),low_density_paths[i].elements[j]));
			vb++;
		}
	}
	cout << "Added " << vb << " from low density.\n";

	{
		int i(0);
		cerr << "Fragment Merge ";
		while(true){
			cerr << "Round " << i << ": Merging " << estimators.size();
			i++;
			bool changes_made=ns_merge_estimator_groups(max_dist_sq,estimators);
			cerr << " into " << estimators.size() << "\n";
			if (!changes_made)
				break;
		}
	}
	cerr << "Done.";
	//check to see if the estimator can match any of the points, or be matched by the target
	
	/*ofstream os("c:\\estimator_groups.csv");
	os << "Estimator Group,Order in Estimator Group,Match Time, Match Position X, Match Position Y,Is A Path, Path Id, Point Position\n";
	for (unsigned int i = 0; i < estimator_groups.size(); i++){
		unsigned long path_p(0);
		for (unsigned int j = 0; j < estimator_groups[i].estimators.size(); j++){
			os << i << "," << path_p << "," << 
				estimator_groups[i].estimators[j]->match_time << ","
				<< estimator_groups[i].estimators[j]->match_position.x << ","
				<< estimator_groups[i].estimators[j]->match_position.y << ",";
			if (estimator_groups[i].estimators[j]->is_a_path()){
				os << "1," << estimator_groups[i].estimators[j]->path_id << ",,\n";
			}
			else os << "0,," << element(estimator_groups[i].estimators[j]->stray_point_id).e.center.x << ","
					<<	element(estimator_groups[i].estimators[j]->stray_point_id).e.center.y << "\n";

			path_p++;
			if (estimator_groups[i].estimators[j]->is_a_path()){
				os << i << "," << path_p << "," << 
					paths[estimator_groups[i].estimators[j]->path_id].max_time << ","
					<< paths[estimator_groups[i].estimators[j]->path_id].max_time_position.x << ","
					<< paths[estimator_groups[i].estimators[j]->path_id].max_time_position.y << ",";
				os << "1," << estimator_groups[i].estimators[j]->path_id << ",,\n";
				path_p++;
			}

		}
	}
	os.close();*/

	for (unsigned int i = 0; i < paths.size(); i++){
		paths[i].path_id = i;
	}
	set<unsigned long> paths_to_delete;
	//sort elements of the path by time, and merge them.
	for (unsigned int i = 0; i < estimators.size(); i++){
		if (estimators[i].to_be_deleted) 
			throw ns_ex("Yikes!");
		

		//find the path that will absorb all the other points/paths
		
		ns_time_path_solver_path * path(0);
		if (estimators[i].estimators.begin()->is_a_path()){
			path = &paths[estimators[i].estimators.begin()->path_id];
		}
		else{
			unsigned long s(paths.size());
			paths.resize(s+1);
			paths[s].path_id = s;
			if (estimators[i].estimators.begin()->stray_point_id.index == 16 &&
				estimators[i].estimators.begin()->stray_point_id.t_id==786)
				cerr << "WHA";


			paths[s].elements.push_back(estimators[i].estimators.begin()->stray_point_id);
			path = &paths[s];
		}

		//merge all paths and points that need to be grouped
		ns_time_path_solution_stationary_drift_estimator_group::ns_estimator_list::iterator p(estimators[i].estimators.begin());
		if ((p->estimation_position-ns_vector_2d(4303,3901)).squared() < 10)
			cerr << "WHA";
		p++;
		for (unsigned int kk = 0; kk < path->elements.size(); kk++){
					if (path->elements[kk].t_id == 752 &&
						path->elements[kk].index==2)
						cerr << "WAH";
				}
		for (; p!= estimators[i].estimators.end(); p++){
			if (p->is_a_path()){
				
				if (path->elements.begin()->t_id >= paths[p->path_id].elements.rbegin()->t_id)
					cerr << "Out of order paths were produced!\n";

				path->elements.insert(path->elements.begin(),
					paths[p->path_id].elements.begin(),
					paths[p->path_id].elements.end());
				paths_to_delete.insert(paths_to_delete.begin(),paths[p->path_id].path_id);
			}
			else{
				if (path->elements.begin()->t_id >= p->stray_point_id.t_id)
					cerr << "Out of order paths were produced!\n";
				path->elements.insert(path->elements.begin(),p->stray_point_id);
			}
		}
	}
	//delete all the paths that were merged into other paths
	unsigned long i(0);
	for (vector<ns_time_path_solver_path>::iterator p = paths.begin(); p != paths.end();){
		for (unsigned int i = 1; i < p->elements.size(); i++){
			if (p->elements[i-1].t_id <= p->elements[i].t_id)
				throw ns_ex("Out of order paths were produced!");
		}

		if (p->elements.size() < 3 || ((time(*p->elements.begin())-time(*p->elements.rbegin()))/60) < min_final_stationary_path_duration_in_minutes){
			if (can_search_for_stray_points_at_time(*p->elements.begin())
				|| can_search_for_stray_points_at_time(*p->elements.rbegin())){
				for (unsigned int i = 0; i < p->elements.size(); i++){
					element(p->elements[i]).e.low_temporal_resolution = true;
				}
			}
			p = paths.erase(p);
			continue;
		}
		
		set<unsigned long>::iterator d(paths_to_delete.find(p->path_id));
		if (d!=paths_to_delete.end()){
			p = paths.erase(p);
			continue;
		}

		p->max_time = time(*p->elements.begin());
		p->min_time = time(*p->elements.rbegin());
		p->max_time_position = element(*p->elements.begin()).e.center;
		p->min_time_position = element(*p->elements.rbegin()).e.center;
		p++;
	}
	//look for points that are inside any paths.
	//these can occur when there are a few points that aren't dense enough
	//to become high density path fragments, but are within a gap between two high-density path fragments
	//smaller than the maximum fragment joining temporal distance.
	//In this case the merge_fragment() function generates one path from thet two fragments that skip
	//over the inbetween low-density points.
	//This is actually hard to deal with elsewhere correctly, so we do it after the fact here.
	for (unsigned int i = 0; i < timepoints.size(); i++){
		for (vector<ns_time_path_solver_path>::iterator p = paths.begin(); p != paths.end();p++){
			if (p->max_time > timepoints[i].time && p->min_time < timepoints[i].time){
				for (unsigned int j = 0; j < timepoints[i].elements.size(); j++){
					for (std::vector<ns_time_element_link>::iterator q = p->elements.begin(); ;){
						std::vector<ns_time_element_link>::iterator r = q;
						r++;
						if (r==p->elements.end()) 
							throw ns_ex("Something is wrong with the path max and min times!");
						if (time(*r) == timepoints[i].time)//the path already has a point at the specified time.
							break;
						if (time(*r) < timepoints[i].time){
							ns_vector_2d path_pos = element(*q).e.center + element(*r).e.center;
							path_pos/=2.0;
							if  ((path_pos-timepoints[i].elements[j].e.center).squared() <= max_dist_sq){
								element(*q).e.low_temporal_resolution = true;
								p->elements.insert(r,ns_time_element_link(i,j));
							}
							break;
						}
						q++;
					}
				}
			}
		}
	}
}


void ns_time_path_solver::find_stationary_path_fragments(const double min_path_density_in_points_per_hour, const unsigned long min_path_duration_in_seconds, const unsigned long time_window_length_in_seconds,const unsigned long max_movement_distance){
	const unsigned long mdsq(max_movement_distance*max_movement_distance);
	
	std::vector<ns_time_path_solver_path_builder> open_paths;
	open_paths.reserve(100);
	paths.reserve(100);
	
	for (long i = (long)timepoints.size()-1; i >= 0; i--){

		//attempt to assign an element to an existing path
		assign_timepoint_elements_to_paths(timepoints[i].elements,mdsq,open_paths);
		for (unsigned int j= 0; j < timepoints[i].elements.size(); j++){
			if ((timepoints[i].elements[j].e.center - ns_vector_2d(1652,5396)).squared() < 100 &&
				!timepoints[i].elements[j].element_assigned_in_this_round)
				cerr << "A";
			//if we haven't been able to assign an element, use it to create a new seed
			if (timepoints[i].elements[j].element_assigned_in_this_round) {
				open_paths[timepoints[i].elements[j].path_id].elements.push_back(ns_time_path_solver_path_builder_point(ns_time_element_link(i,j),timepoints[i].elements[j].e.center,timepoints[i].time));
				open_paths[timepoints[i].elements[j].path_id].calculate_center(time_window_length_in_seconds);
			}
			else{
				ns_is_interesting_point(timepoints[i].elements[j].e.center);
				open_paths.push_back(ns_time_path_solver_path_builder(ns_time_path_solver_path_builder_point(ns_time_element_link(i,j),timepoints[i].elements[j].e.center,timepoints[i].time)));
			}
		}
		//close paths that have too large a time gap between their end and the current frame
		for(std::vector<ns_time_path_solver_path_builder>::iterator p = open_paths.begin(); p!=open_paths.end();){
			//the path is closed.  We either move it to the list of good paths, or delete it.
			if (p->elements.begin()->time - timepoints[i].time < time_window_length_in_seconds){
				//don't start deleting potential paths until we have a good estimate of their density
				p++;
				continue;
			}
			const double current_path_point_density_in_seconds(
				p->calculate_current_density(timepoints[i].time,time_window_length_in_seconds)
				);
			if (current_path_point_density_in_seconds*60.0*60.0 < min_path_density_in_points_per_hour){
				
				if (p->elements.size() > 1 && p->elements.begin()->time-p->elements.rbegin()->time >= min_path_duration_in_seconds)
					paths.push_back(*p);
			
				p = open_paths.erase(p);
			}
			else p++;

		}
	}
	//close any remaining open paths
	for (unsigned int i = 0; i < open_paths.size(); i++){
			//if (open_paths[i].elements.begin()->pos.y ==  4650)
		//				cerr << "WHA";
	
		const double current_path_point_density_in_seconds(open_paths[i].calculate_current_density(timepoints[0].time,time_window_length_in_seconds));
	
		if (open_paths[i].elements.size() > 1 && current_path_point_density_in_seconds*60*60 >= min_path_density_in_points_per_hour &&
			open_paths[i].elements.begin()->time-open_paths[i].elements.rbegin()->time >= min_path_duration_in_seconds)
			paths.push_back(open_paths[i]);
	}
}

unsigned long ns_time_path_solver::number_of_unassigned_points_at_time(const ns_time_element_link & l) const {
	unsigned long number_of_unassigned_points(0);
	for (unsigned int j = 0; j < timepoints[l.t_id].elements.size(); j++)
		number_of_unassigned_points+=timepoints[l.t_id].elements[j].element_assigned?0:1;
	return number_of_unassigned_points;
}
void ns_time_path_solver::find_low_density_stationary_paths(const unsigned long min_path_duration_in_seconds, const unsigned long max_movement_distance){
	const unsigned long mdsq(max_movement_distance*max_movement_distance);
	mark_unassigned_points();
	std::vector<ns_time_path_solver_path_builder> open_paths;
	open_paths.reserve(10);
	low_density_paths.resize(0);

	for (long i = (long)timepoints.size()-1; i >= 0; i--){
		const bool start_new_paths(can_search_for_stray_points_at_time(ns_time_element_link(i,0)));
		
		if (!start_new_paths)
			continue;
		//attempt to assign an element to an existing path.  Elements already in paths are ignored
		assign_timepoint_elements_to_paths(timepoints[i].elements,mdsq,open_paths);
		for (unsigned int j= 0; j < timepoints[i].elements.size(); j++){
			if (timepoints[i].elements[j].element_assigned)
				continue;
			//if we haven't been able to assign an element, use it to create a new seed
			if (timepoints[i].elements[j].element_assigned_in_this_round) {
				open_paths[timepoints[i].elements[j].path_id].elements.push_back(ns_time_path_solver_path_builder_point(ns_time_element_link(i,j),timepoints[i].elements[j].e.center,timepoints[i].time));
				open_paths[timepoints[i].elements[j].path_id].calculate_center(0);
			}
			else{
				open_paths.push_back(ns_time_path_solver_path_builder(ns_time_path_solver_path_builder_point(ns_time_element_link(i,j),timepoints[i].elements[j].e.center,timepoints[i].time)));
			}
		}
	}
	//close any remaining open paths
	for (unsigned int i = 0; i < open_paths.size(); i++){
		if (open_paths[i].elements.size() > 3 && 
			open_paths[i].elements.begin()->time-open_paths[i].elements.rbegin()->time >= min_path_duration_in_seconds)
			low_density_paths.push_back(open_paths[i]);
	}
	for (unsigned int i = 0; i < low_density_paths.size(); i++){
		low_density_paths[i].is_low_density_path = true;
		for (unsigned int j = 0; j < low_density_paths[i].elements.size(); j++){
			element(low_density_paths[i].elements[j]).e.low_temporal_resolution = true;
		}
	}
}



bool operator ==(const ns_time_element_link & a, const ns_time_element_link & b){
	return a.t_id == b.t_id && a.index == b.index;
}

void ns_time_path_solver_element::load(const ns_detected_worm_info * w){
	e = ns_time_path_element(w);
}
void ns_time_path_solver::mark_unassigned_points(){
	for (unsigned int i = 0; i < timepoints.size(); i++){
		for (unsigned int j = 0; j < timepoints[i].elements.size(); j++){
			timepoints[i].elements[j].element_assigned = false;
		}
	}
	for (unsigned int i = 0; i < paths.size(); i++){
		for (unsigned int j = 0; j < paths[i].elements.size(); j++){
			element(paths[i].elements[j]).element_assigned = true;
		}
	}
}

void ns_time_path_solver_timepoint::load(const unsigned long worm_detection_results_id,ns_image_worm_detection_results & results,ns_sql & sql){
	elements.resize(0);
	worm_detection_results = &results;
	results.id = worm_detection_results_id;
	results.load_from_db(false,sql);
	const std::vector<const ns_detected_worm_info *> & worms(results.actual_worm_list());
	elements.resize(worms.size());
	for(unsigned int i = 0; i < worms.size(); i++){
		elements[i].load(worms[i]);
	}

	//later on we might need to load worm images from the worm region visualization image.
	//thus, we load the location of each worm's image in that bitmap.
	vector<ns_vector_2i> positions;
	results.worm_collage.info().image_locations_in_collage((unsigned long)worms.size(),positions);
	
	for(unsigned int i = 0; i < worms.size(); i++){
		elements[i].e.context_image_position_in_region_vis_image = positions[i];
		//cerr << "Position : " << positions[i] << "\n";
	}
}

void ns_register_path_solver_load_error(unsigned long region_info_id,const std::string & expl, ns_sql & sql){
	ns_ex ex("For ");
	sql << "SELECT r.name,s.id,s.name,e.name FROM sample_region_image_info as r,capture_samples as s,"
			"experiments as e WHERE r.sample_id = s.id AND s.experiment_id = e.id";
	ns_sql_result res;
	sql.get_rows(res);
	if (res.size() == 0){
		ex << "region info id ";
		ex << region_info_id;
	}
	else ex <<res[0][3]<<"::" <<res[0][2] << "::" <<res[0][0];
	ex << ":" << expl;
	image_server.register_server_event(ex,&sql);

}

void ns_time_path_solver::load(unsigned long region_id, ns_sql & sql){
	sql << "SELECT time_of_last_valid_sample FROM sample_region_image_info WHERE id = " << region_id;
	ns_sql_result res;
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("ns_time_path_solver::load()::Could not load region ") << region_id << " from database.";
	unsigned long time_of_last_valid_sample = atol(res[0][0].c_str());

	sql << "SELECT worm_detection_results_id,capture_time, id FROM sample_region_images WHERE region_info_id = " 
		<< region_id << " AND worm_detection_results_id != 0 AND problem = 0 AND currently_under_processing = 0 "
		<< "AND censored = 0";
	if (time_of_last_valid_sample != 0)
		sql << " AND capture_time <= " << time_of_last_valid_sample;
	sql << " ORDER BY capture_time ASC";

	ns_sql_result time_point_result;
	sql.get_rows(time_point_result);
	timepoints.resize(time_point_result.size());
	set<long> times;
	set<long> detection_ids;
	detection_results->results.resize(time_point_result.size());
	
	cerr << "Compiling Detection Point Cloud...";
	long last_c(-2);
	for (unsigned int i = 0; i < time_point_result.size();){
		if ((long)((i*100)/time_point_result.size()) >= last_c+5){
			cerr << (i*100)/time_point_result.size() << "%...";
			last_c = i;
		}
		timepoints[i].time = atol(time_point_result[i][1].c_str());
		timepoints[i].sample_region_image_id = atol(time_point_result[i][2].c_str());
		const unsigned long worm_detection_results_id(atol(time_point_result[i][0].c_str()));
		
		if (!times.insert(timepoints[i].time).second){
			ns_register_path_solver_load_error(region_id,
			std::string("A duplicate capture sample entry was discovered at time ")
			+ ns_format_time_string_for_human(timepoints[i].time) + "(" + ns_to_string(timepoints[i].time) + ")",sql);
			timepoints.pop_back();
		}

		if (!detection_ids.insert(worm_detection_results_id).second){
			ns_register_path_solver_load_error(region_id,
			std::string("A duplicate capture sample entry was discovered at time ")
			+ ns_format_time_string_for_human(timepoints[i].time) + "(" + ns_to_string(timepoints[i].time) + ")",sql);
			timepoints.pop_back();
		}
		timepoints[i].load(worm_detection_results_id,detection_results->results[i],sql);
		
		i++;
	}cerr << "\n";
//	check_for_duplicate_events();

	for (unsigned int i = 0; i < timepoints.size(); i++){
		timepoints[i].combine_very_close_elements(0);
	}
}

void ns_time_path_solver_timepoint::combine_very_close_elements(const unsigned long max_d_squared){
	for (std::vector<ns_time_path_solver_element>::iterator p = elements.begin(); p != elements.end(); p++)
		p->element_assigned = false;

	//add duplicates as children
	for (std::vector<ns_time_path_solver_element>::iterator p = elements.begin(); p != elements.end(); p++){
		if (p->element_assigned) continue;
		std::vector<ns_time_path_solver_element>::iterator q = p;
		q++;
		for (; q != elements.end(); q++){
			if (q->element_assigned) continue;
			if ((p->e.center - q->e.center).squared() <= max_d_squared){
				p->e.part_of_a_multiple_worm_disambiguation_cluster = true;
				q->e.part_of_a_multiple_worm_disambiguation_cluster = true;
				p->extra_elements_at_current_position.push_back(q->e);
				q->element_assigned = true;
			}
		}
	}

	//remove duplicates from base list
	for (std::vector<ns_time_path_solver_element>::iterator p = elements.begin(); p != elements.end();){
		if (p->element_assigned)
			p = elements.erase(p);
		else p++;
	}
}

///void ns_time_path_solver::check_for_duplicate_events(){
//	for (unsigned int i = 0; i < timepoints.size(); i++)		
//		timepoints[i].combine_very_close_elements(4);
//}

void ns_time_path_solver::transfer_data_to_solution(ns_time_path_solution & solution){
	solution.clear();
	//transfer all worm results data
	solution.set_results(detection_results);
	solution.worms_loaded = true;
	detection_results = 0;

	//transfer all points and populate unassigned points path.
	solution.timepoints.resize(timepoints.size());
	for (unsigned int i = 0; i < timepoints.size(); i++){
		solution.timepoints[i].time = timepoints[i].time;
		solution.timepoints[i].sample_region_image_id = timepoints[i].sample_region_image_id;
		solution.timepoints[i].elements.reserve(timepoints[i].elements.size());
		for (unsigned int j = 0; j < timepoints[i].elements.size(); j++){
			solution.timepoints[i].elements.push_back(timepoints[i].elements[j].e);
	//		cerr << timepoints[i].elements[j].e.position_in_region_vis_image << "vs" << solution.timepoints[i].elements.rbegin()->position_in_region_vis_image << "\n";
			if (timepoints[i].elements[j].path_id == 0)
				solution.unassigned_points.stationary_elements.push_back(ns_time_element_link(i,j));
		}
	}

	
	solution.paths.reserve(path_groups.size());
	solution.path_groups.reserve(path_groups.size());
	for (unsigned int i = 0; i < path_groups.size(); i++){	
		unsigned long path_length(0);
		unsigned long s = (unsigned long)solution.path_groups.size();
		unsigned long number_of_uncensored_paths_in_group(0);
		for (unsigned int j = 0; j < path_groups[i].path_ids.size(); j++){
			ns_time_path_solver_path & path(paths[path_groups[i].path_ids[j]]); //path id 0 is ungrouped elements
			if (path.is_not_stationary) {
				cerr << "SKipping noise";
				continue;
			}
			if (number_of_uncensored_paths_in_group==0){
				solution.path_groups.resize(s+1);
				solution.path_groups[s].path_ids.push_back(s);
				solution.paths.resize(s+1);
				solution.paths[s].center = ns_vector_2i(0,0);
				solution.paths[s].stationary_elements.reserve(path.elements.size()*path_groups[i].path_ids.size());
				solution.paths[s].is_low_density_path = false;
			}
			unsigned long number_of_low_density_points(0),
						  number_of_high_density_points(0);
			for (unsigned int k = 0; k < path.elements.size(); k++){
				solution.paths[s].stationary_elements.push_back(path.elements[k]);
				solution.paths[s].center += element(path.elements[k]).e.center;
				number_of_low_density_points += element(path.elements[k]).e.low_temporal_resolution?1:0;
				number_of_high_density_points += element(path.elements[k]).e.low_temporal_resolution?0:1;
			}
			if (2*number_of_low_density_points >= path.elements.size()){
				solution.paths[s].is_low_density_path = true;
				if (number_of_high_density_points != 0){
					for (unsigned int k = 0; k < solution.paths[s].stationary_elements.size(); k++)
						solution.element(solution.paths[s].stationary_elements[k]).low_temporal_resolution = true;
				}
			}
			else{
				if (number_of_high_density_points != 0){
					for (unsigned int k = 0; k < solution.paths[s].stationary_elements.size(); k++)
						solution.element(solution.paths[s].stationary_elements[k]).low_temporal_resolution = false;
				}
			}
			number_of_uncensored_paths_in_group++;
		}
		if (path_length != 0)
		solution.paths[s].center = solution.paths[s].center/=path_length;
	}
	
	timepoints.resize(0);
	path_groups.resize(0);
	solution.check_for_duplicate_events();
}

void ns_time_path_solution::output_visualization_csv(ostream & o){
	ns_time_path_solution::output_visualization_csv_header(o);
	//output unassigned points
	for (unsigned int i = 0; i< unassigned_points.stationary_elements.size(); i++){
		ns_time_path_solution::output_visualization_csv_data(o,
			((float)(time(unassigned_points.stationary_elements[i])- timepoints[0].time))/60.0/60.0/24.0,
			time(unassigned_points.stationary_elements[i]),
			element(unassigned_points.stationary_elements[i]).center,
			element(unassigned_points.stationary_elements[i]).region_size,
			0,
			0,
			element(unassigned_points.stationary_elements[i]).slowly_moving,
			element(unassigned_points.stationary_elements[i]).low_temporal_resolution,
				0,0,
				ns_movement_not_calculated);
	}
	//output paths
	for (unsigned int g = 0; g < path_groups.size(); g++){
		for (unsigned int i = 0; i < path_groups[g].path_ids.size(); i++){
			for (unsigned int j = 0; j < paths[path_groups[g].path_ids[i]].moving_elements.size(); j++){
				ns_time_element_link & e(paths[path_groups[g].path_ids[i]].moving_elements[j]);
				ns_time_path_solution::output_visualization_csv_data(o,
					 ((float)(time(e)- timepoints[0].time))/60.0/60.0/24.0,
					 time(e),
					 element(e).center,
					 element(e).region_size,
					 path_groups[g].path_ids[i]+1,
					 g+1,
					 1,
					 (element(e).low_temporal_resolution ||
						paths[path_groups[g].path_ids[i]].is_low_density_path),
					 0,0,ns_movement_not_calculated
				);
			}
			for (unsigned int j = 0; j < paths[path_groups[g].path_ids[i]].stationary_elements.size(); j++){
				ns_time_element_link & e(paths[path_groups[g].path_ids[i]].stationary_elements[j]);
				ns_time_path_solution::output_visualization_csv_data(o,
					 ((float)(time(e)- timepoints[0].time))/60.0/60.0/24.0,
					 time(e),
					 element(e).center,
					 element(e).region_size,
					 path_groups[g].path_ids[i]+1,
					 g+1,
					 0,
					 (element(e).low_temporal_resolution ||
						paths[path_groups[g].path_ids[i]].is_low_density_path),
					 0,0,ns_movement_not_calculated
				);
			}
		}
	}
}
void ns_time_path_solver::output_visualization_csv(ostream & o){
	unsigned int d(1);
	ns_time_path_solution::output_visualization_csv_header(o);
	for (unsigned int i = 0; i < timepoints.size(); i+=d){
		for (unsigned int j = 0; j < timepoints[i].elements.size(); j++){
			ns_time_path_solution::output_visualization_csv_data(
				o,
				(float)(timepoints[i].time - timepoints[0].time)/60.0/60.0/24.0,
				timepoints[i].time,
				timepoints[i].elements[j].e.center,
				timepoints[i].elements[j].e.region_size,
				timepoints[i].elements[j].path_id,
				0,
				timepoints[i].elements[j].e.slowly_moving,
				timepoints[i].elements[j].e.low_temporal_resolution,
				false,
				0,
				ns_movement_not_calculated
				);
		}
	}
}


void ns_time_path_solver::assign_path_ids_to_elements(){
		//for now, just put one path per group.
	path_groups.resize(paths.size());
	for (unsigned int i = 0; i < paths.size(); i++){
		paths[i].path_id = 0;
		paths[i].group_id = i+1;
		path_groups[i].path_ids.push_back(i);
	}

	for (unsigned int i = 0; i < timepoints.size(); i++){
		for (unsigned int j = 0; j < timepoints[i].elements.size(); j++)
			timepoints[i].elements[j].path_id = 0;
	}

	for (unsigned int i = 0; i < path_groups.size(); i++){
		for (unsigned int j = 0; j < paths[i].elements.size(); j++){
			element(paths[i].elements[j]).path_id = paths[i].group_id;
		}
	}
}

typedef std::vector<ns_time_path_solver_path> ns_time_path_solver_path_list;
typedef std::vector<ns_time_path_solver_path_list::iterator> ns_time_path_solver_path_orderer_list;
typedef std::map<unsigned long,ns_time_path_solver_path_orderer_list > ns_time_path_solver_path_orderer;
void ns_time_path_solver::merge_overlapping_path_fragments(const unsigned long max_center_distance,const unsigned long max_time_gap){
	//note here that the merged paths have
	//1) All their elements sorted in order of decreasing time
	//2) Their center matched as the center of their earliest fragment
	const long max_dist_sq(max_center_distance*max_center_distance);
	ns_time_path_solver_path_orderer paths_ordered_by_max_time;
	ns_time_path_solver_path_orderer paths_ordered_by_min_time;

	
	const unsigned long erase_constant(666);
	for (std::vector<ns_time_path_solver_path>::iterator p = paths.begin(); p != paths.end();p++){
		p->group_id = 0;
	}
	bool merge_performed = false;
	//merge paths forward in time
	for (std::vector<ns_time_path_solver_path>::iterator p = paths.begin(); p != paths.end();){
		
		if (!merge_performed){
			//paths_ordered_by_max_time.clear();
			paths_ordered_by_min_time.clear();
			for (std::vector<ns_time_path_solver_path>::iterator q = paths.begin(); q != paths.end();q++){
				if (q->group_id == erase_constant)  //ignore paths marked for deletion
					continue;
				//paths_ordered_by_max_time[p->max_time].push_back(q);
				paths_ordered_by_min_time[p->min_time].push_back(q);
			}
		}
		merge_performed = false;
		for (ns_time_path_solver_path_orderer::iterator q =paths_ordered_by_min_time.begin();
				q != paths_ordered_by_min_time.end() && !merge_performed; 
				q++){
			for (ns_time_path_solver_path_orderer_list::iterator r = q->second.begin(); r != q->second.end();r++){
				if (p->max_time < (*r)->min_time &&
					p->max_time + max_time_gap >= (*r)->min_time){
					//the two paths overlap spacially
					//if (element(p->elements[0]).x
					
					if (((*r)->min_time_position - p->max_time_position).squared() > max_dist_sq){
						//not close enough
						continue;
					}
					if (p->elements.begin()->t_id > (*r)->elements.rbegin()->t_id)
						throw ns_ex("Incorrect merging!");
					p->elements.insert(p->elements.begin(),(*r)->elements.begin(),(*r)->elements.end());
					p->max_time = (*r)->max_time;
					p->max_time_position = (*r)->max_time_position;
					(*r)->group_id = erase_constant; //delete it
					merge_performed = true;
					break;
				}
			}
		}
		if (merge_performed) //if we've made a change to the current timepoint, do another search
			continue;
		p++;
	}

	for (std::vector<ns_time_path_solver_path>::iterator p = paths.begin(); p != paths.end();){
		if (p->group_id == erase_constant)
			p = paths.erase(p);
		else p++;
	}
}
