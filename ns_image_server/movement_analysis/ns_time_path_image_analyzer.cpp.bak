#include "ns_time_path_image_analyzer.h"
#include "ns_graph.h"
#include "ns_xml.h"
#include "ns_image_tools.h"

using namespace std;

#define NS_MARGIN_BACKGROUND 0
#define NS_DO_SUBPIXEL_REGISTRATION
#define NS_SUBPIXEL_REGISTRATION_CORSE ns_vector_2d(.25,.25)
#define NS_SUBPIXEL_REGISTRATION_FINE ns_vector_2d(.125,.125)

//#define NS_OUTPUT_ALGINMENT_DEBUG


ns_analyzed_image_time_path_element_measurements operator+(const ns_analyzed_image_time_path_element_measurements & a,const ns_analyzed_image_time_path_element_measurements & b){
	ns_analyzed_image_time_path_element_measurements s;

	s.movement_sum							=a.	movement_sum							+b.movement_sum;
	s.movement_alternate_worm_sum				=a.	movement_alternate_worm_sum				+b.movement_alternate_worm_sum;
	s.stationary_sum							=a.	stationary_sum							+b.stationary_sum;
	s.stationary_change_sum					=a.	stationary_change_sum					+b.stationary_change_sum;
	s.total_worm_area							=a.	total_worm_area							+b.total_worm_area;
	s.total_intensity_within_worm_area		=a.	total_intensity_within_worm_area		+b.total_intensity_within_worm_area;
	s.total_region_area						=a.	total_region_area						+b.total_region_area;
	s.total_intensity_within_region			=a.	total_intensity_within_region			+b.total_intensity_within_region;
	s.total_alternate_worm_area				=a.	total_alternate_worm_area				+b.total_alternate_worm_area;
	s.total_intensity_within_alternate_worm	=a.	total_intensity_within_alternate_worm	+b.total_intensity_within_alternate_worm;
	
	s.registration_displacement= a.registration_displacement + b.registration_displacement;

	s.mean_intensity_within_worm_area			=a.	mean_intensity_within_worm_area			+b.mean_intensity_within_worm_area;
	s.mean_intensity_within_region			=a.	mean_intensity_within_region			+b.mean_intensity_within_region;
	s.mean_intensity_within_alternate_worm	=a.	mean_intensity_within_alternate_worm	+b.mean_intensity_within_alternate_worm;
	return s;
}

void ns_analyzed_image_time_path_element_measurements::calculate_means(){
	if (total_worm_area != 0)
		mean_intensity_within_worm_area = total_intensity_within_worm_area/(double)total_worm_area;
	else mean_intensity_within_worm_area = 0;
	if (total_region_area != 0)
		mean_intensity_within_region= total_intensity_within_region/(double)total_region_area;
	else mean_intensity_within_region = 0;
	if (total_alternate_worm_area != 0)
		mean_intensity_within_alternate_worm= total_intensity_within_alternate_worm/(double)total_alternate_worm_area;
	else mean_intensity_within_alternate_worm = 0;
}

ns_analyzed_image_time_path_element_measurements operator/(const ns_analyzed_image_time_path_element_measurements & a,const int & d){
	ns_analyzed_image_time_path_element_measurements s(a);
	s.movement_sum/=d;
	s.movement_alternate_worm_sum/=d;
	s.stationary_sum/=d;
	s.stationary_change_sum/=d;
	s.total_worm_area/=d;
	s.total_intensity_within_worm_area/=d;
	s.total_region_area/=d;
	s.total_intensity_within_region/=d;
	s.total_alternate_worm_area/=d;
	s.total_intensity_within_alternate_worm/=d;

	s.registration_displacement = s.registration_displacement/d;

	s.mean_intensity_within_worm_area/=d;
	s.mean_intensity_within_region/=d;
	s.mean_intensity_within_alternate_worm/=d;
	return s;
}

void ns_analyzed_image_time_path_element_measurements::square(){
	movement_sum							*=	movement_sum;
	movement_alternate_worm_sum				*=	movement_alternate_worm_sum;
	stationary_sum							*=	stationary_sum;
	stationary_change_sum					*=	stationary_change_sum;
	total_worm_area							*=	total_worm_area;
	total_intensity_within_worm_area		*=	total_intensity_within_worm_area;
	total_region_area						*=	total_region_area;
	total_intensity_within_region			*=	total_intensity_within_region;
	total_alternate_worm_area				*=	total_alternate_worm_area;
	total_intensity_within_alternate_worm	*=	total_intensity_within_alternate_worm;

	registration_displacement.x*= registration_displacement.x;
	registration_displacement.y*= registration_displacement.y;

	mean_intensity_within_worm_area			*=	mean_intensity_within_worm_area;
	mean_intensity_within_region			*=	mean_intensity_within_region;
	mean_intensity_within_alternate_worm	*=	mean_intensity_within_alternate_worm;
}
void ns_analyzed_image_time_path_element_measurements::square_root(){
	movement_sum						=sqrt((double)		movement_sum);
	movement_alternate_worm_sum			=sqrt((double)		movement_alternate_worm_sum);
	stationary_sum						=sqrt((double)		stationary_sum);
	stationary_change_sum				=sqrt((double)		stationary_change_sum);
	total_worm_area						=sqrt((double)		total_worm_area);
	total_intensity_within_worm_area	=sqrt((double)		total_intensity_within_worm_area);
	total_region_area					=sqrt((double)		total_region_area);
	total_intensity_within_region		=sqrt((double)		total_intensity_within_region);
	total_alternate_worm_area			=sqrt((double)		total_alternate_worm_area);
	total_intensity_within_alternate_worm=sqrt((double)		total_intensity_within_alternate_worm);

	registration_displacement.x = sqrt(registration_displacement.x);
	registration_displacement.y = sqrt(registration_displacement.y);

	mean_intensity_within_worm_area		=sqrt(		mean_intensity_within_worm_area);
	mean_intensity_within_region		=sqrt(		mean_intensity_within_region);
	mean_intensity_within_alternate_worm=sqrt(		mean_intensity_within_alternate_worm);
}

void ns_analyzed_image_time_path_element_measurements::zero(){
	movement_sum=0;
	movement_alternate_worm_sum=0;
	stationary_sum=0;
	stationary_change_sum=0;
	total_worm_area=0;
	total_intensity_within_worm_area=0;
	total_region_area=0;
	total_intensity_within_region=0;
	total_alternate_worm_area=0;
	total_intensity_within_alternate_worm=0;

	registration_displacement = ns_vector_2d(0,0);

	mean_intensity_within_worm_area=0;
	mean_intensity_within_region=0;
	mean_intensity_within_alternate_worm=0;
}

class ns_chunk_generator{
public:
	ns_chunk_generator(const unsigned long chunk_size_, const unsigned long minimum_first_chunk_size_,const ns_analyzed_image_time_path & path_):path(&path_),chunk_size(chunk_size_),minimum_first_chunk_size(minimum_first_chunk_size_),current_chunk(0,0){}
	bool update_and_check_for_new_chunk( ns_analyzed_time_image_chunk & new_chunk){

		for (;current_chunk.stop_i < path->element_count() && path->element(current_chunk.stop_i).path_aligned_image_is_loaded(); 
			current_chunk.stop_i++);
		const unsigned long cur_size(current_chunk.stop_i-current_chunk.start_i);
		if ( cur_size >= chunk_size ||
			(cur_size > 0 && current_chunk.stop_i == path->element_count())){
			
				new_chunk = current_chunk;
				current_chunk.start_i = current_chunk.stop_i;
				return true;
		}
		return false;
	}
	bool no_more_chunks(){return current_chunk.stop_i == path->element_count();}
private:
	unsigned long chunk_size;
	unsigned long minimum_first_chunk_size;
	ns_analyzed_time_image_chunk current_chunk;
	const ns_analyzed_image_time_path * path;
};
void ns_time_path_image_movement_analyzer::delete_from_db(const unsigned long region_id,ns_sql & sql){
	sql << "DELETE FROM path_data WHERE region_id = " << region_id;
	sql.send_query();
	sql << "UPDATE sample_region_image_info SET path_movement_images_are_cached=0 WHERE id = " << region_id;
	sql.send_query();
}

void ns_movement_posture_visualization_summary::to_xml(std::string & text){
	ns_xml_simple_writer xml;
	xml.add_tag("rid",region_id);
	xml.add_tag("fn",frame_number);
	xml.add_tag("afn",alignment_frame_number);
	for (unsigned int i = 0; i < worms.size(); i++){
		xml.start_group("w");
		xml.add_tag("swp",ns_xml_simple_writer::format_pair(worms[i].worm_in_source_image.position.x,worms[i].worm_in_source_image.position.y));
		xml.add_tag("swz",ns_xml_simple_writer::format_pair(worms[i].worm_in_source_image.size.x,worms[i].worm_in_source_image.size.y));

		xml.add_tag("spp",ns_xml_simple_writer::format_pair(worms[i].path_in_source_image.position.x,worms[i].path_in_source_image.position.y));
		xml.add_tag("spz",ns_xml_simple_writer::format_pair(worms[i].path_in_source_image.size.x,worms[i].path_in_source_image.size.y));

		xml.add_tag("vp",ns_xml_simple_writer::format_pair(worms[i].path_in_visualization.position.x,worms[i].path_in_visualization.position.y));
		xml.add_tag("vz",ns_xml_simple_writer::format_pair(worms[i].path_in_visualization.size.x,worms[i].path_in_visualization.size.y));

		xml.add_tag("mp",ns_xml_simple_writer::format_pair(worms[i].metadata_in_visualizationA.position.x,worms[i].metadata_in_visualizationA.position.y));
		xml.add_tag("mz",ns_xml_simple_writer::format_pair(worms[i].metadata_in_visualizationA.size.x,worms[i].metadata_in_visualizationA.size.y));

		xml.add_tag("pi",worms[i].stationary_path_id.path_id);
		xml.add_tag("gi",worms[i].stationary_path_id.group_id);
		xml.add_tag("gt",worms[i].stationary_path_id.detection_set_id);
		xml.add_tag("ps",worms[i].path_time.start_time);
		xml.add_tag("pf",worms[i].path_time.end_time);
		xml.add_tag("tt",worms[i].image_time);
		xml.end_group();
	}
	text = xml.result();
}
inline ns_vector_2i ns_get_integer_pair(const std::string & s){
	std::string::size_type t(s.find(","));
	if (t == std::string::npos)
		throw ns_ex("Could not find pair information in '") << s << "'";
	else return ns_vector_2i(atol(s.substr(0,t).c_str()),(atol(s.substr(t+1,std::string::npos).c_str())));
}
void ns_movement_posture_visualization_summary::from_xml(const std::string & text){
	ns_xml_simple_object_reader o;
	o.from_string(text);
	worms.resize(0);
	if (o.objects.size() == 0) return;
	worms.reserve(o.objects.size()-1);
	frame_number = 0;
	alignment_frame_number = 0;
	try{
		for (unsigned int i = 0; i < o.objects.size(); i++){
			if (o.objects[i].name == "rid"){
				region_id = atol(o.objects[i].value.c_str());
				continue;
			}
			if (o.objects[i].name == "fn"){
				frame_number = atol(o.objects[i].value.c_str());
				continue;
			}
			if (o.objects[i].name == "afn"){
				alignment_frame_number = atol(o.objects[i].value.c_str());
				continue;
			}
			else if (o.objects[i].name!= "w")
				throw ns_ex("Unknown posture visualization summary tag: ") << o.objects[i].name;
			string::size_type s = worms.size();
			worms.resize(s+1);
			
			worms[s].worm_in_source_image.position = ns_get_integer_pair(o.objects[i].tag("swp"));
			worms[s].worm_in_source_image.size = ns_get_integer_pair(o.objects[i].tag("swz"));
			worms[s].path_in_source_image.position = ns_get_integer_pair(o.objects[i].tag("spp"));
			worms[s].path_in_source_image.size = ns_get_integer_pair(o.objects[i].tag("spz"));
			worms[s].path_in_visualization.position = ns_get_integer_pair(o.objects[i].tag("vp"));
			worms[s].path_in_visualization.size = ns_get_integer_pair(o.objects[i].tag("vz"));
			worms[s].metadata_in_visualizationA.position = ns_get_integer_pair(o.objects[i].tag("mp"));
			worms[s].metadata_in_visualizationA.size = ns_get_integer_pair(o.objects[i].tag("mz"));
			worms[s].stationary_path_id.path_id = atol(o.objects[i].tag("pi").c_str());
			worms[s].stationary_path_id.group_id = atol(o.objects[i].tag("gi").c_str());
			worms[s].stationary_path_id.detection_set_id = atol(o.objects[i].tag("gt").c_str());

			worms[s].path_time.start_time= atol(o.objects[i].tag("ps").c_str());
			worms[s].path_time.end_time= atol(o.objects[i].tag("pf").c_str());
			worms[s].image_time = atol(o.objects[i].tag("tt").c_str());
		}
	}
	catch(ns_ex & ex){
		worms.clear();
		throw ex;
	}
}
#ifdef NS_OUTPUT_ALGINMENT_DEBUG
string debug_path_name;
#endif
void ns_time_path_image_movement_analyzer::calculate_from_solution(const unsigned long region_id,const ns_time_path_solution & solution_,ns_sql & sql, const long group_number){
	analysis_id = ns_current_time();
	region_info_id = region_id;
	const unsigned long clear_lag((ns_analyzed_image_time_path::movement_time_kernel_width > ns_analyzed_image_time_path::alignment_time_kernel_width )?
									ns_analyzed_image_time_path::movement_time_kernel_width:ns_analyzed_image_time_path::alignment_time_kernel_width);
	try{
		load_from_solution(solution_,group_number);
		crop_paths_to_final_time(region_id,sql);
		acquire_region_image_specifications(region_id,sql);
		load_movement_image_db_info(region_id,sql);
		get_output_image_storage_locations(region_id,sql);

		unsigned long p(0);
	//	image_server.register_server_event(ns_image_server_event("Calculating Movement",false),&sql);
		
		//initiate chunk generator and alignment states
		const unsigned long chunk_size(10);
		const unsigned long minimum_chunk_size(ns_analyzed_image_time_path::alignment_time_kernel_width);
		vector<vector<ns_chunk_generator> > chunk_generators;
		vector<vector<ns_alignment_state> > alignment_states;
		chunk_generators.resize(groups.size());
		alignment_states.resize(groups.size());
		for (unsigned int i = 0; i < groups.size(); i++){
			alignment_states[i].resize(groups[i].paths.size());
			chunk_generators[i].reserve(groups[i].paths.size());
			for (unsigned int j = 0; j < groups[i].paths.size(); j++)
				chunk_generators[i].push_back(ns_chunk_generator(chunk_size,minimum_chunk_size,groups[i].paths[j]));
		}


		for (unsigned int t = 0; t < region_image_specifications.size(); t+=chunk_size){
			cerr << (100*t)/region_image_specifications.size() << "%...";
			//load a chunk of images
			unsigned long stop_t = t+chunk_size;
			if (stop_t > region_image_specifications.size())
				stop_t = region_image_specifications.size();
		//	cerr << "Loading images " << t << "-" << stop_t << "\n";
			load_region_visualization_images(t,stop_t,sql);
			
			for (unsigned int i = 0; i < groups.size(); i++){
				for (unsigned int j = 0; j < groups[i].paths.size(); j++){
					ns_analyzed_time_image_chunk chunk;
					//only continue if a chunk's worth of data is loaded
					if (!chunk_generators[i][j].update_and_check_for_new_chunk(chunk))
						continue;

		//			cerr << "Processing path " << i <<"." << j << ":(" << chunk.start_i << "-" << chunk.stop_i << ")\n";
					#ifdef NS_OUTPUT_ALGINMENT_DEBUG
					cerr << "PATH " << i << "," << j << "\n";
					debug_path_name = string("path") + ns_to_string(i) + "_" + ns_to_string(j);
					#endif			
					groups[i].paths[j].calculate_image_registration(chunk,alignment_states[i][j]);
					//cerr << "Calculating Movement...";
					groups[i].paths[j].generate_movement_images(chunk);
					groups[i].paths[j].quantify_movement(chunk);
					groups[i].paths[j].save_movement_images(chunk,sql);
				//	return;;
	//				cerr << "Clearing path aligned images " << i <<"." << j << ":(" << 0 << "-" << (long)chunk.stop_i-(long)clear_lag-1 << ")\n";
					for (long k = chunk.start_i; k < (long)chunk.stop_i; k++)
						groups[i].paths[j].elements[k].clear_movement_images();
					for (long k = 0; k < ((long)chunk.stop_i-(long)clear_lag); k++)
						groups[i].paths[j].elements[k].clear_path_aligned_images();

			//		cerr << "\n";
				}
			}
		}
		
		image_loading_temp.clear();
		
		const unsigned long persistance_time(stationary_cutoff_duration());
		for (unsigned int i = 0; i < groups.size(); i++){
			for (unsigned int j = 0; j < groups[i].paths.size(); j++){
				groups[i].paths[j].analyze_movement(persistance_time,ns_stationary_path_id(i,j,analysis_id));
				groups[i].paths[j].calculate_movement_quantification_summary();
			}
		}
		generate_movement_description_series();
		mark_path_images_as_cached_in_db(region_id,sql);
		movement_analyzed = true;
	}
	catch(...){
		delete_from_db(region_id,sql);
		throw;
	}
}
unsigned long ns_time_path_image_movement_analyzer::stationary_cutoff_duration() const{

	if (solution->timepoints.size() == 0)
		return 0;

	//for really short experiments (i.e. heat shock), lower the duration for which animals must be stationary 
	//before being annotated as such.
	unsigned long experiment_length = solution->timepoints.rbegin()->time - solution->timepoints[0].time;
	if (experiment_length < 5*24*60*60)
		return 0;  //no permanance for really short experiments. we assume the worms are being killed rapidly

	return 4*60*60;  //half a day
}

/*void ns_analyzed_image_time_path::out_histograms(std::ostream & o) const{
	o << "Value,Stationary Count, Movement Count\n";
	for (unsigned long i = 0; i < 256; i++)
		o << i << "," << (unsigned long)stationary_histogram[i] << "," << (unsigned long)movement_histogram[i] << "\n";
}*/

void ns_time_path_image_movement_analyzer::load_from_solution(const ns_time_path_solution & solution_, const long group_number){
	solution = &solution_;
	groups.clear();
	extra_non_path_events.clear();
	
	if (region_info_id == 0)
		throw ns_ex("load_from_solution()::No Region ID Specified!");
	for (unsigned int i = 0; i < solution_.timepoints.size(); i++){
		if (solution_.timepoints[i].time > last_timepoint_in_analysis_)
			last_timepoint_in_analysis_ = solution_.timepoints[i].time;
	}
	number_of_timepoints_in_analysis_ = solution_.timepoints.size();
	
	groups.reserve(solution_.path_groups.size());
	if (group_number != -1){
		groups.push_back(ns_analyzed_image_time_path_group(group_number,region_info_id,solution_,extra_non_path_events));
		for (unsigned int i = 0; i < groups.rbegin()->paths.size(); i++){
			if (groups.rbegin()->paths[i].elements.size() < ns_analyzed_image_time_path::alignment_time_kernel_width)
				throw ns_ex("ns_time_path_image_movement_analyzer::load_from_solution::Path loaded that is too short.");
		}
		if (groups.rbegin()->paths.size() == 0)
			groups.pop_back();
	}
	else{
		for (unsigned int i = 0; i < solution_.path_groups.size(); i++){
			groups.push_back(ns_analyzed_image_time_path_group(i,region_info_id,solution_,extra_non_path_events));
			for (unsigned int j = 0; j < groups.rbegin()->paths.size(); j++){
				if (groups.rbegin()->paths[j].elements.size() < ns_analyzed_image_time_path::alignment_time_kernel_width)
					throw ns_ex("ns_time_path_image_movement_analyzer::load_from_solution::Path loaded that is too short.");
			}
			if (groups.rbegin()->paths.size() == 0)
				groups.pop_back();
		}
	}
	if (solution_.timepoints.size() == 0)
		return;

	//add annotations for fast moving animals
	unsigned long last_time = solution_.timepoints.rbegin()->time;
	const unsigned long current_time(ns_current_time());
	for (unsigned int i = 0; i < solution_.unassigned_points.stationary_elements.size(); i++){
		const ns_time_path_element &e(solution_.element(solution_.unassigned_points.stationary_elements[i]));
		std::string expl("NP");
		extra_non_path_events.add(
				ns_death_time_annotation(ns_fast_moving_worm_observed,
				0,region_info_id,
				ns_death_time_annotation_time(solution_.time(solution_.unassigned_points.stationary_elements[i]),solution_.time(solution_.unassigned_points.stationary_elements[i])),
				e.region_position,
				e.region_size,ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
				e.part_of_a_multiple_worm_disambiguation_cluster?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
				ns_stationary_path_id(),false,
				expl)
		);
	}

	
	get_processing_stats_from_solution(solution_);
}


void ns_time_path_image_movement_analyzer::get_output_image_storage_locations(const unsigned long region_id,ns_sql & sql){

	string region_name,sample_name,experiment_name;
	unsigned long sample_id,experiment_id;
	ns_region_info_lookup::get_region_info(region_id,&sql,region_name,sample_name,sample_id, experiment_name, experiment_id);
	
	ns_file_location_specification region_info(image_server.image_storage.get_base_path_for_region(region_id,&sql));
	sql << "SELECT id, image_id FROM path_data WHERE region_id = " << region_id << " AND group_id >= " << groups.size();
	ns_sql_result res;
	sql.get_rows(res);
	for (unsigned int i = 0; i < res.size(); i++){
		ns_image_server_image im;
		im.load_from_db(atol(res[i][1].c_str()),&sql);
		image_server.image_storage.delete_from_storage(im,ns_delete_both_volatile_and_long_term,&sql);
		sql << "DELETE FROM images WHERE id = " << im.id;
		sql.send_query();
	}
	if (res.size() > 0){
		sql << "DELETE FROM path_data WHERE region_id = " << region_id << " AND group_id >= " << groups.size();
		sql.send_query();
	}

	for (unsigned int i = 0; i < groups.size(); i++){
		for (unsigned int j = 0; j < groups[i].paths.size(); j++){
			ns_image_server_image & im(groups[i].paths[j].output_image);
			if (im.id == 0){
				im = image_server.image_storage.get_storage_for_path(region_info, j, i,
																region_id, region_name,experiment_name, sample_name);
				im.save_to_db(0,&sql);
				if (im.id == 0)
					throw ns_ex("ns_time_path_image_movement_analyzer::save_movement_images()::Could not generate a new path id image id.");
				if (groups[i].paths[j].path_db_id == 0){
					sql << "INSERT INTO path_data SET image_id = " << im.id << ", region_id = " << region_id << ",group_id = " << i << ",path_id = " << j;
					groups[i].paths[j].path_db_id = sql.send_query_get_id();
				}
				else{
					sql << "UPDATE path_data SET image_id = " << im.id << " WHERE id = " << groups[i].paths[j].path_db_id;
					sql.send_query();
				}
			}
		}
	}
}
void ns_time_path_image_movement_analyzer::crop_paths_to_final_time(const unsigned long region_id, ns_sql & sql){
	sql << "SELECT time_of_last_valid_sample FROM sample_region_image_info WHERE id = " << region_id;
	ns_sql_result res;
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("ns_time_path_image_movement_analyzer::crop_paths_to_final_time()::Could not load time of last sample from database.");
	if (res.size() == 0)
		return;
	const unsigned long last_time = atol(res[0][0].c_str());
	
	if (last_time == 0)
		return;

	for (unsigned int i = 0; i < groups.size(); i++){
		for (unsigned int j = 0; j < groups[i].paths.size(); j++){
			if(groups[i].paths[j].elements.size() == 0)
				continue;

			for (unsigned int k = 0; k < groups[i].paths[j].elements.size(); k++){
				if (groups[i].paths[j].elements[k].absolute_time > last_time)
					groups[i].paths[j].elements[k].excluded = true;
			}
		/*	std::vector<ns_analyzed_image_time_path_element>::iterator p = groups[i].paths[j].elements.end();
			p--;
			while(true){
				bool is_first_element(p == groups[i].paths[j].elements.begin());
				if (p->absolute_time > last_time){
					p = groups[i].paths[j].elements.erase(p);
				}
				if ( groups[i].paths[j].elements.empty() || is_first_element)
					break;
				p--;
			}
		}*/
		}
	}
	for (std::vector<ns_death_time_annotation>::iterator p = extra_non_path_events.events.begin(); p != extra_non_path_events.events.end();){
		if (p->time.end_time > last_time)
			p = extra_non_path_events.erase(p);
		else ++p;
	}
}

void ns_time_path_image_movement_analyzer::populate_movement_quantification_from_file(ns_sql & sql){
	
	sql << "SELECT movement_image_analysis_quantification_id FROM sample_region_image_info WHERE id = " << this->region_info_id;
	ns_sql_result res;
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("ns_time_path_image_movement_analyzer::load_movement_data_from_db():Could not load info from db");
	ns_image_server_image im;
	im.id = atol(res[0][0].c_str());
	if (im.id == 0)
		throw ns_ex("Movement quantification data has not been stored in db");
	ifstream * i(image_server.image_storage.request_metadata_from_disk(im,false,&sql));

	try{
		load_movement_data_from_disk(*i,false);
		delete i;
	}
	catch(...){
		delete i;
		throw;
	}
};
void ns_time_path_image_movement_analyzer::load_movement_data_from_db(const unsigned long region_id,const ns_time_path_solution & solution_, ns_sql & sql, bool exclude_movement_quantification){
	region_info_id = region_id;
	load_from_solution(solution_);
	crop_paths_to_final_time(region_info_id,sql);
	load_movement_image_db_info(region_info_id,sql);

	for (unsigned long g = 0; g < groups.size(); g++){
		for (unsigned long p = 0; p < groups[g].paths.size(); p++)
			for (unsigned int i = 0; i < groups[g].paths[p].death_time_annotations().events.size(); i++){
				groups[g].paths[p].by_hand_annotation_event_times.resize((int)ns_number_of_movement_event_types,-1);
				groups[g].paths[p].death_time_annotation_set.events[i].region_info_id = region_info_id;
			}
	}

	populate_movement_quantification_from_file(sql);
	if (exclude_movement_quantification)
		return;

	const unsigned long persistance_time(stationary_cutoff_duration());
	for (unsigned long g = 0; g < groups.size(); g++)
		for (unsigned long p = 0; p < groups[g].paths.size(); p++){
			groups[g].paths[p].analyze_movement(persistance_time,ns_stationary_path_id(g,p,analysis_id));
			groups[g].paths[p].calculate_movement_quantification_summary();
		}
	//generate_movement_description_series();
	movement_analyzed = true;
}
void ns_time_path_image_movement_analyzer::save_movement_data_to_db(const unsigned long region_id, ns_sql & sql){

	sql << "SELECT movement_image_analysis_quantification_id FROM sample_region_image_info WHERE id = " << region_id;
	ns_sql_result res;
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("ns_time_path_image_movement_analyzer::save_movement_data_to_db():Could not load info from db");
	ns_image_server_image im;
	im.id = atol(res[0][0].c_str());
	bool update_db(false);
	if (im.id == 0){
		im = image_server.image_storage.get_region_movement_metadata_info(region_id,"time_path_movement_image_analysis_quantification",sql);
		update_db = true;
	}
	ofstream * o(image_server.image_storage.request_metadata_output(im,"csv",false,&sql));
	im.save_to_db(im.id,&sql);
	try{
		save_movement_data_to_disk(*o);
		delete o;
	}
	catch(...){
		delete o;
		throw;
	}
	if (update_db){
		sql << "UPDATE sample_region_image_info SET movement_image_analysis_quantification_id = " << im.id << " WHERE id = " << region_id;
		sql.send_query();
	}

}

void ns_time_path_image_movement_analyzer::load_movement_data_from_disk(istream & in, bool skip_movement_data){

	ns_get_int get_int;
	ns_get_double get_double;
	get_int(in,this->analysis_id);
	if (in.fail())
		throw ns_ex("Empty Specification!");
	if (skip_movement_data)
		return;
		
	for (unsigned int i = 0; i < groups.size(); i++){
		for (unsigned int j = 0; j < groups[i].paths.size(); j++){
			for (unsigned int k = 0; k < groups[i].paths[j].elements.size(); k++){
				groups[i].paths[j].elements[k].absolute_time = 0;
			}
		}
	}

	while(true){
		unsigned long group_id,path_id,element_id;
		get_int(in,group_id);
		if(in.fail()) break;

		get_int(in,path_id);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,element_id);
		if(in.fail()) throw ns_ex("Invalid Specification");

		if (group_id >= groups.size())
			throw ns_ex("ns_time_path_image_movement_analyzer::load_movement_data_from_disk()::Invalid group id ") << group_id;
		if (path_id >= groups[group_id].paths.size())
			throw ns_ex("ns_time_path_image_movement_analyzer::load_movement_data_from_disk()::Invalid path id ") << path_id;
		if (element_id >= groups[group_id].paths[path_id].elements.size())
			throw ns_ex("ns_time_path_image_movement_analyzer::load_movement_data_from_disk()::Element is too large ") << path_id;
		get_int(in,groups[group_id].paths[path_id].elements[element_id].absolute_time);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,groups[group_id].paths[path_id].elements[element_id].measurements.movement_sum);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,groups[group_id].paths[path_id].elements[element_id].measurements.movement_alternate_worm_sum);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,groups[group_id].paths[path_id].elements[element_id].measurements.stationary_sum);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,groups[group_id].paths[path_id].elements[element_id].measurements.stationary_change_sum);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,groups[group_id].paths[path_id].elements[element_id].measurements.total_worm_area);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,groups[group_id].paths[path_id].elements[element_id].measurements.total_intensity_within_worm_area);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,groups[group_id].paths[path_id].elements[element_id].measurements.total_region_area);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,groups[group_id].paths[path_id].elements[element_id].measurements.total_intensity_within_region);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,groups[group_id].paths[path_id].elements[element_id].measurements.total_alternate_worm_area);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_int(in,groups[group_id].paths[path_id].elements[element_id].measurements.total_intensity_within_alternate_worm);
		if(in.fail()) throw ns_ex("Invalid Specification");

		int t;
		get_int(in,t);
		if(in.fail()) throw ns_ex("Invalid Specification");
		groups[group_id].paths[path_id].elements[element_id].saturated_offset = (t!=0);

		get_double(in,groups[group_id].paths[path_id].elements[element_id].registration_offset.x);
		if(in.fail()) throw ns_ex("Invalid Specification");
		get_double(in,groups[group_id].paths[path_id].elements[element_id].registration_offset.y);
		if(in.fail()) throw ns_ex("Invalid Specification");

		string tmp;
		//open for future use
		for (unsigned int i = 0; i < 2; i++){
			get_int(in,tmp);
				if(in.fail()) throw ns_ex("Invalid Specification");
		}

	}
	//check all data is loaded
	for (unsigned int i = 0; i < groups.size(); i++){
		for (unsigned int j = 0; j < groups[i].paths.size(); j++){
			for (unsigned int k = 0; k < groups[i].paths[j].elements.size(); k++){
				if (groups[i].paths[j].elements[k].absolute_time == 0)
					throw ns_ex(" ns_time_path_image_movement_analyzer::load_movement_data_from_disk():Not all data specified in file!");
			}
		}
	}
}
void ns_time_path_image_movement_analyzer::get_processing_stats_from_solution(const ns_time_path_solution & solution_){
	number_of_timepoints_in_analysis_ = solution_.timepoints.size();
	
	last_timepoint_in_analysis_ = 0;
	for (unsigned int i = 0; i < solution_.timepoints.size(); i++){
		if (solution_.timepoints[i].time > last_timepoint_in_analysis_)
			last_timepoint_in_analysis_ = solution_.timepoints[i].time;
	}

}

void ns_time_path_image_movement_analyzer::save_movement_data_to_disk(ostream & o) const{
	o << this->analysis_id << "\n";
	for (unsigned long i = 0; i < groups.size(); i++){
		for (unsigned long j = 0; j < groups[i].paths.size(); j++){
			for (unsigned long k = 0; k < groups[i].paths[j].elements.size(); k++){
				o << i << ","
				  << j << "," 
				  << k << ","
				  << groups[i].paths[j].elements[k].absolute_time << ","
				  << groups[i].paths[j].elements[k].measurements.movement_sum << ","
				  << groups[i].paths[j].elements[k].measurements.movement_alternate_worm_sum << ","
				  << groups[i].paths[j].elements[k].measurements.stationary_sum << ","
				  << groups[i].paths[j].elements[k].measurements.stationary_change_sum << ","
				  << groups[i].paths[j].elements[k].measurements.total_worm_area << ","
				  << groups[i].paths[j].elements[k].measurements.total_intensity_within_worm_area << ","
				  << groups[i].paths[j].elements[k].measurements.total_region_area << ","
				  << groups[i].paths[j].elements[k].measurements.total_intensity_within_region << ","
				  << groups[i].paths[j].elements[k].measurements.total_alternate_worm_area << ","
				  << groups[i].paths[j].elements[k].measurements.total_intensity_within_alternate_worm << ","
				  << (groups[i].paths[j].elements[k].saturated_offset?"1":"0") << ","
				  << groups[i].paths[j].elements[k].registration_offset.x << ","
				  << groups[i].paths[j].elements[k].registration_offset.y <<",,\n";
			}
		}
	}
}


std::string ns_calc_rel_time_by_index(const unsigned long time, const long offset_index, const std::vector<ns_analyzed_image_time_path_element> & elements){
	if (offset_index == -1)
		return "";
	return ns_to_string_short((((long)time)-(long)elements[offset_index].absolute_time)/(60.0*60*24),3);
}


std::string ns_normalize_indexed_time(const long offset_index, const unsigned long time, const std::vector<ns_analyzed_image_time_path_element> & elements){
	if (offset_index == -1)
		return "";
	return ns_to_string_short((((long)elements[offset_index].absolute_time-(long)time))/(60.0*60*24),4);
}


std::string ns_normalize_abs_time(const long abs_time, const unsigned long time){
	if (abs_time == -1)
		return "";
	return ns_to_string_short((((long)abs_time-(long)time))/(60.0*60*24),4);
}

std::string ns_calc_rel_time_by_time(const unsigned long time, const long offset_time){
	if (offset_time == -1)
		return "";
	return ns_to_string_short((((long)time)-offset_time)/(60.0*60*24),3);
}
void ns_analyzed_image_time_path::write_detailed_movement_quantification_analysis_header(std::ostream & o){
	ns_region_metadata::out_JMP_plate_identity_header_short(o);
	o << ",";
	o << "Group ID, Path ID, Position X, Position Y,Censored, Extra Worm Count,Absolute Time, Age Relative Time,"
		 "Machine Death Relative Time, Machine Slow Movement Cessation Relative Time, Machine Fast Movement Cessation Relative Time,"
		 "By Hand Death Relative Time, By Hand Slow Movement Cessation Relative Time, By Hand Fast Movement Cessation Relative Time,"
		 "By Hand Death Posture Relaxation Time,"
		 "Movement Sum, Movement Alternate Worm Sum, Stationary Sum, Stationary Change Sum, Movement Ratio, Total Worm Area, Total Worm Intensity, Total Region Area, Total Region Intensity, Saturated Registration\n";
}

void ns_analyzed_image_time_path::write_summary_movement_quantification_analysis_header(std::ostream & o){
	ns_region_metadata::out_JMP_plate_identity_header(o);
	o << ",";
	o << "By Handed Excluded, By Hand Censored, Misc Flags,"
	  << "Group ID, Path ID, Position X, Position Y,"
		 "Machine Death Time, Machine Slow Movement Cessation Time, Machine Fast Movement Cessation Time,"
		 "By Hand Death Time, By Hand Slow Movement Cessation Time, By Hand Fast Movement Cessation Time,"
		 "Worm Intensity Mean Overall, Worm Intensity Variability Overall, Neighborhood Intensity Mean Overall, Neighborhood Intensity Variability Overall, Alternate Worm Intensity Mean Overall, Alternate Worm Intensity Variability Overall,"
		 "Worm Intensity Mean Before Death, Worm Intensity Variability Before Death, Neighborhood Intensity Mean Before Death, Neighborhood Intensity Variability Before Death, Alternate Worm Intensity Mean Before Death, Alternate Worm Intensity Variability Before Death,"
		
		 "Worm Registration Offset X Mean Overall, Worm Registration Offset X Variability Overall,"
		 "Worm Registration Offset Y Mean Overall, Worm Registration Offset Y Variability Overall,"
		 "Worm Registration Offset Magnitude Mean Overall, Worm Registration Offset Magnitude Variability Overall,"
		 "Worm Area Mean Overall, Worm Area Variability Overall, Registration Region Area Mean Overall, Registration Region Area Variability Overall, Worm Area to Region Area Average Ratio Overall,"
		
		 "Worm Registration Offset X Mean Before Death, Worm Registration Offset X Variability Before Death,"
		 "Worm Registration Offset Y Mean Before Death, Worm Registration Offset Y Variability Before Death,"
		 "Worm Registration Offset Magnitude Mean Before Death, Worm Registration Offset Magnitude Variability Before Death,"
		 "Worm Area Mean Before Death, Worm Area Variability Before Death, Registration Region Area Mean Before Death, Registration Region Area Variability Before Death, Worm Area to Region Area Average Ratio Before Death,"
		
		 "Number of Frames Before Death, Number of Frames After Death, Death as % of frames,"
		 "Average Movement Ratio Before Death, % Saturated Frames Before Death, % Saturated Frames Total";
}


void ns_analyzed_image_time_path::write_analysis_optimization_data_header(std::ostream & o){
	o << "Detection Set ID,Group ID,Path ID,Movement Ratio Threshold, Min Hold Time (Hours), Death Time (Date), By Hand Death Time Specified, Difference Between Machine and By Hand Death Times (Days)";
}

std::vector< std::vector < unsigned long > > static_messy_death_time_matrix;
void ns_analyzed_image_time_path::write_analysis_optimization_data(const ns_stationary_path_id & id, const std::vector<double> & thresholds, const std::vector<double> & hold_times, std::ostream & o) const{
	
	long death_time(by_hand_annotation_event_times[(int)ns_movement_cessation]);
	if (death_time == -1)
		return;
	calculate_analysis_optimization_data(thresholds,hold_times,static_messy_death_time_matrix);
	for (unsigned int i = 0; i < thresholds.size(); i++)
		for (unsigned int j = 0; j < hold_times.size(); j++){
			o << id.detection_set_id << "," << id.group_id << "," << id.path_id << ","
				<< thresholds[i] << "," << (hold_times[j])/60.0/60.0 << "," 
				<< static_messy_death_time_matrix[i][j] << ",";
			/*if (death_time == -1)
				o << "0,0\n";
			else */o << "1," << ((double)static_messy_death_time_matrix[i][j] - death_time)/(60.0*60.0*24) << "\n";
		}
}

void ns_analyzed_image_time_path::calculate_analysis_optimization_data(const std::vector<double> & thresholds, const std::vector<double> & hold_times, std::vector< std::vector < unsigned long > > & death_times) const{
	
	std::vector<std::vector<unsigned long> > last_time_point_at_which_movement_was_found(thresholds.size(),std::vector<unsigned long>(hold_times.size(),elements[0].absolute_time));

	death_times.resize(0);
	death_times.resize(thresholds.size(),std::vector<unsigned long>(hold_times.size(),0));

	for (long t = 0; t < elements.size(); t++){
		
		if (elements[t].excluded) continue;

		double r(elements[t].measurements.new_movement_ratio());
		const unsigned long &cur_time (elements[t].absolute_time);
		//keep on pushing the last posture time and last sationary
		//times forward until we hit a low enough movement ratio
		//to meet the criteria.  At that point, the last posture 
		//and last stationary cutoffs stick
		
		for (unsigned int thresh = 0; thresh < thresholds.size(); thresh++){
			for (unsigned int hold_t = 0; hold_t < hold_times.size(); hold_t++){
				if (death_times[thresh][hold_t] != 0) continue;
				if (r >= thresholds[thresh])
					last_time_point_at_which_movement_was_found[thresh][hold_t] = cur_time;
				if (last_time_point_at_which_movement_was_found[thresh][hold_t] != 0 &&
					cur_time - last_time_point_at_which_movement_was_found[thresh][hold_t] > hold_times[hold_t])
						death_times[thresh][hold_t] = last_time_point_at_which_movement_was_found[thresh][hold_t];
			}
		}
	}
}


void ns_analyzed_image_time_path::write_summary_movement_quantification_analysis_data(const ns_region_metadata & m, const unsigned long group_id, const unsigned long path_id, std::ostream & o)const{
	m.out_JMP_plate_identity_data(o);
	o << ",";
	o << (censoring_and_flag_details.is_excluded()?ns_death_time_annotation::exclusion_value(censoring_and_flag_details.excluded):0) << ","
		<< (censoring_and_flag_details.is_censored()?ns_death_time_annotation::exclusion_value(censoring_and_flag_details.excluded):0) << ","
		<< censoring_and_flag_details.flag.label() << ",";
	o << group_id<<","<<path_id<<","
		<< path_region_position.x << ","
		<< path_region_position.y << ","
		<< ns_normalize_indexed_time(event_indices[(int)ns_movement_cessation],m.time_at_which_animals_had_zero_age,elements) << ","
		<< ns_normalize_indexed_time(event_indices[(int)ns_translation_cessation],m.time_at_which_animals_had_zero_age,elements) << ","
		<< ns_normalize_indexed_time(event_indices[(int)ns_fast_movement_cessation],m.time_at_which_animals_had_zero_age,elements) << ","
		<< ns_normalize_abs_time(by_hand_annotation_event_times[(int)ns_movement_cessation],m.time_at_which_animals_had_zero_age) << ","
		<< ns_normalize_abs_time(by_hand_annotation_event_times[(int)ns_translation_cessation],m.time_at_which_animals_had_zero_age) << ","
		<< ns_normalize_abs_time(by_hand_annotation_event_times[(int)ns_fast_movement_cessation],m.time_at_which_animals_had_zero_age) << ",";
	o << quantification_summary.mean_all.mean_intensity_within_worm_area << "," << quantification_summary.variability_all.mean_intensity_within_worm_area << ","
	  << quantification_summary.mean_all.mean_intensity_within_region << "," << quantification_summary.variability_all.mean_intensity_within_region << ","
	  << quantification_summary.mean_all.mean_intensity_within_alternate_worm << "," << quantification_summary.variability_all.mean_intensity_within_alternate_worm << ",";
	
	o << quantification_summary.mean_before_death.mean_intensity_within_worm_area << "," << quantification_summary.variability_before_death.mean_intensity_within_worm_area << ","
	  << quantification_summary.mean_before_death.mean_intensity_within_region << "," << quantification_summary.variability_before_death.mean_intensity_within_region << ","
	  << quantification_summary.mean_before_death.mean_intensity_within_alternate_worm << "," << quantification_summary.variability_before_death.mean_intensity_within_alternate_worm << ",";
	
	o << quantification_summary.mean_all.registration_displacement.x << "," << quantification_summary.variability_all.registration_displacement.x << ","
		<< quantification_summary.mean_all.registration_displacement.y << "," << quantification_summary.variability_all.registration_displacement.y << ","
		<< quantification_summary.mean_all.registration_displacement.mag() << "," << quantification_summary.variability_all.registration_displacement.mag() << ","

	  << quantification_summary.mean_all.total_worm_area << "," << quantification_summary.variability_all.total_worm_area << ","
	  << quantification_summary.mean_all.total_region_area << "," << quantification_summary.variability_all.total_region_area << ",";
	if (quantification_summary.mean_all.total_region_area != 0)
		o << quantification_summary.mean_all.total_worm_area/(double)quantification_summary.mean_all.total_region_area << ",";
	else o<< "0,";

	o << quantification_summary.mean_before_death.registration_displacement.x << "," << quantification_summary.variability_before_death.registration_displacement.x << ","
	  << quantification_summary.mean_before_death.registration_displacement.y << "," << quantification_summary.variability_before_death.registration_displacement.y << ","
	  << quantification_summary.mean_before_death.registration_displacement.mag() << "," << quantification_summary.variability_before_death.registration_displacement.mag() << ","
	  << quantification_summary.mean_before_death.total_worm_area << "," << quantification_summary.variability_before_death.total_worm_area << ","
	  << quantification_summary.mean_before_death.total_region_area << "," << quantification_summary.variability_before_death.total_region_area << ",";
	if (quantification_summary.mean_all.total_region_area != 0)
		o << quantification_summary.mean_all.total_worm_area/(double)quantification_summary.mean_all.total_region_area << ",";
	else o << "0,";
	o << quantification_summary.count_before_death << "," << quantification_summary.count_after_death << 100*quantification_summary.count_before_death/(double)quantification_summary.count_all << ","
		<< quantification_summary.mean_before_death.new_movement_ratio() << ",";
	if (quantification_summary.count_before_death != 0)
		o << 100*quantification_summary.number_of_registration_saturated_frames_before_death/(double)quantification_summary.count_before_death << ",";
	else o << "0,";
	if (quantification_summary.count_after_death != 0)
		o << 100*quantification_summary.number_of_registration_saturated_frames_after_death/(double)quantification_summary.count_after_death << ",";
	else o << "0,";
	if (quantification_summary.count_all != 0)
		o << 100*(quantification_summary.number_of_registration_saturated_frames_before_death+quantification_summary.number_of_registration_saturated_frames_after_death)/(double)quantification_summary.count_all << "\n";
	else o << "0\n";

}
void ns_analyzed_image_time_path::calculate_movement_quantification_summary(){

	quantification_summary.mean_before_death.zero();
	quantification_summary.mean_after_death.zero();
	quantification_summary.variability_all.zero();
	quantification_summary.variability_before_death.zero();
	quantification_summary.variability_after_death.zero();
	quantification_summary.mean_all.zero();
	quantification_summary.count_after_death = 0;
	quantification_summary.count_before_death = 0;
	quantification_summary.count_all = 0;
	quantification_summary.number_of_registration_saturated_frames_before_death = 0;
	quantification_summary.number_of_registration_saturated_frames_after_death = 0;
	for (unsigned int i  = 0; i < elements.size(); i++)
		elements[i].measurements.registration_displacement = elements[i].registration_offset;

	const unsigned long death_index(event_indices[(int)ns_movement_cessation]);
	if (death_index != -1){
		for (unsigned int i = 0; i <= death_index; i++){
			quantification_summary.count_before_death++;
			elements[i].measurements.calculate_means();
			quantification_summary.mean_before_death = quantification_summary.mean_before_death + elements[i].measurements;
			if (elements[i].saturated_offset)
				quantification_summary.number_of_registration_saturated_frames_before_death++;
		}
	}	
	for (unsigned int i = death_index+1; i < elements.size();i++){
	quantification_summary.count_after_death++;
		elements[i].measurements.calculate_means();
		quantification_summary.mean_after_death = quantification_summary.mean_after_death + elements[i].measurements;
		if (elements[i].saturated_offset)
			quantification_summary.number_of_registration_saturated_frames_after_death++;
	}
	
	quantification_summary.count_all = quantification_summary.count_before_death + quantification_summary.count_after_death;
	quantification_summary.mean_all = quantification_summary.mean_before_death + quantification_summary.mean_after_death;
	
	if (quantification_summary.count_all != 0) 
		quantification_summary.mean_all = quantification_summary.mean_all / quantification_summary.count_all;
	if (quantification_summary.count_before_death != 0) 
		quantification_summary.mean_before_death = quantification_summary.mean_before_death / quantification_summary.count_before_death;
	if (quantification_summary.count_after_death != 0) 
		quantification_summary.mean_after_death = quantification_summary.mean_after_death / quantification_summary.count_after_death;

	if (death_index != -1){
		for (unsigned int i = 0; i <= death_index; i++){
			
			ns_analyzed_image_time_path_element_measurements dif((elements[i].measurements + quantification_summary.mean_before_death/-1));
			dif.square();
			quantification_summary.variability_before_death = quantification_summary.variability_before_death + dif;

			dif = (elements[i].measurements + quantification_summary.mean_all/-1);
			dif.square();
			quantification_summary.variability_all = quantification_summary.variability_all + dif;
		}
	}	
	for (unsigned int i = death_index+1; i < elements.size();i++){
		ns_analyzed_image_time_path_element_measurements dif((elements[i].measurements + quantification_summary.mean_after_death/-1));
		dif.square();
		quantification_summary.variability_after_death = quantification_summary.variability_after_death + dif;

		dif = (elements[i].measurements + quantification_summary.mean_all/-1);
		dif.square();
		quantification_summary.variability_all = quantification_summary.variability_all + dif;
	}

	quantification_summary.variability_after_death.square_root();
	quantification_summary.variability_before_death.square_root();
	quantification_summary.variability_all.square_root();

	if (quantification_summary.count_all != 0) 
		quantification_summary.variability_all = quantification_summary.variability_all / quantification_summary.count_all;
	if (quantification_summary.count_before_death != 0) 
		quantification_summary.variability_before_death = quantification_summary.variability_before_death / quantification_summary.count_before_death;
	if (quantification_summary.count_after_death != 0) 
		quantification_summary.variability_after_death = quantification_summary.variability_after_death / quantification_summary.count_after_death;
}

void ns_analyzed_image_time_path::write_detailed_movement_quantification_analysis_data(const ns_region_metadata & m, const unsigned long group_id, const unsigned long path_id, std::ostream & o)const{

	for (unsigned long k = 0; k < elements.size(); k++){
		m.out_JMP_plate_identity_data_short(o);
		o << ",";
		o << group_id<<","<<path_id<<","
			<< path_region_position.x << ","
			<< path_region_position.y << ","
			<< (censoring_and_flag_details.excluded == ns_death_time_annotation::ns_not_excluded?"0":"1") << ","
			<< elements[k].number_of_extra_worms_observed_at_position << ","
			<< elements[k].absolute_time << ","
			<< ns_to_string_short((elements[k].absolute_time - m.time_at_which_animals_had_zero_age)/(60.0*60*24),3) << ","

			<< ns_calc_rel_time_by_index(elements[k].absolute_time,event_indices[(int)ns_movement_cessation],elements) << ","
			<< ns_calc_rel_time_by_index(elements[k].absolute_time,event_indices[(int)ns_translation_cessation],elements) << ","
			<< ns_calc_rel_time_by_index(elements[k].absolute_time,event_indices[(int)ns_fast_movement_cessation],elements) << ","

			<< ns_calc_rel_time_by_time(elements[k].absolute_time,by_hand_annotation_event_times[(int)ns_movement_cessation]) << ","
			<< ns_calc_rel_time_by_time(elements[k].absolute_time,by_hand_annotation_event_times[(int)ns_translation_cessation]) << ","
			<< ns_calc_rel_time_by_time(elements[k].absolute_time,by_hand_annotation_event_times[(int)ns_fast_movement_cessation]) << ","
			<< ns_calc_rel_time_by_time(elements[k].absolute_time,by_hand_annotation_event_times[(int)ns_worm_death_posture_relaxation_termination]) << ",";


		o   << elements[k].measurements.movement_sum << ","
			<< elements[k].measurements.movement_alternate_worm_sum << ","
			<< elements[k].measurements.stationary_sum << ","
			<< elements[k].measurements.stationary_change_sum << ","
			<< elements[k].measurements.new_movement_ratio() << ","
			<< elements[k].measurements.total_worm_area << ","
			<< elements[k].measurements.total_intensity_within_worm_area << ","
			<< elements[k].measurements.total_region_area << ","
			<< elements[k].measurements.total_intensity_within_region << ","
			<< elements[k].measurements.total_alternate_worm_area << ","
			<< elements[k].measurements.total_intensity_within_alternate_worm << ","
			<< (elements[k].saturated_offset?"1":"0") << "\n";

	}
}

void ns_time_path_image_movement_analyzer::write_summary_movement_quantification_analysis_data(const ns_region_metadata & m, std::ostream & o)const{

	for (unsigned long i = 0; i < groups.size(); i++){
		for (unsigned long j = 0; j < groups[i].paths.size(); j++){

			if (groups[i].paths[j].event_indices.size() != ns_number_of_movement_event_types)
				throw ns_ex("ns_time_path_image_movement_analyzer::write_summary_movement_quantification_analysis_data()::Event Indicies not loaded properly!");
			groups[i].paths[j].write_summary_movement_quantification_analysis_data(m,i,j,o);
		}
	}
}


void ns_time_path_image_movement_analyzer::write_analysis_optimization_data(const std::vector<double> & thresholds, const std::vector<double> & hold_times, std::ostream & o) const{
	ns_stationary_path_id id;
	id.detection_set_id = db_analysis_id();
	for (unsigned int i = 0; i < groups.size(); i++){
		id.group_id = i;
			for (unsigned int j = 0; j < groups[i].paths.size(); j++){
				id.path_id = j;
					groups[i].paths[j].write_analysis_optimization_data(id,thresholds,hold_times,o);
			}
	}
}
void ns_time_path_image_movement_analyzer::write_detailed_movement_quantification_analysis_data(const ns_region_metadata & m, std::ostream & o)const{

	for (unsigned long i = 0; i < groups.size(); i++){
		for (unsigned long j = 0; j < groups[i].paths.size(); j++){

			if (groups[i].paths[j].event_indices.size() != ns_number_of_movement_event_types)
				throw ns_ex("ns_time_path_image_movement_analyzer::write_movement_quantification_analysis_data()::Event Indicies not loaded properly!");
			groups[i].paths[j].write_detailed_movement_quantification_analysis_data(m,i,j,o);
		}
	}
}

/* When making animated graphs of time series data, we want to place a marker on the data point corresponding
	to the current time in the animation.  This marker moves accross data demonstrating the passage of time.
	When set_marker(time,graph) is called, the x_axis of the graph column is read to locate the time
	closest to the time specified as a function argument.  A marker is created in the graph object
	at the time closest to that requested.*/
class ns_marker_manager{
public:
	void set_marker(const unsigned long time,ns_graph & graph){
		unsigned int marker_position = 0;
		if (time == -1){
			for (unsigned int i = 0; i < graph.contents[marker_id].y.size(); i++){
				graph.contents[marker_id].y[i] = -1;
				return;
			}
		}
		unsigned int i;
		for (i = 0; i < graph.contents[x_axis_id].x.size(); i++){
			if (graph.contents[x_axis_id].x[i] >= (unsigned long)time)
				break;
			graph.contents[marker_id].y[i] = -1;
		}
		if (i == graph.contents[x_axis_id].x.size())
			return;
		graph.contents[marker_id].y[i] = graph.contents[y_axis_id].y[i];
		for (i = i+1; i < graph.contents[marker_id].y.size(); i++)
			graph.contents[marker_id].y[i] = -1;
	}
private:
	enum{y_axis_id = 0,x_axis_id=1,marker_id=2};
};
/*Movement is measured by collecting statistics on pixel changes over time.
ns_make_path_movement_graph produces a graph of those statistics
*/
void ns_make_path_movement_graph(const ns_analyzed_image_time_path & path,ns_graph & graph){

	const unsigned long number_of_measurements(path.element_count());
	if (number_of_measurements == 1)
		throw ns_ex("Not enough measurements!");

	ns_graph_object	movement_ratios(ns_graph_object::ns_graph_dependant_variable);
	movement_ratios.y.resize(number_of_measurements);
	ns_graph_object graph_x_axis(ns_graph_object::ns_graph_independant_variable);
	graph_x_axis.x.resize(number_of_measurements);

	ns_graph_object cutoff_posture(ns_graph_object::ns_graph_dependant_variable),
				    cutoff_stationary(ns_graph_object::ns_graph_dependant_variable);

	cutoff_posture.y.resize(number_of_measurements);
	cutoff_stationary.y.resize(number_of_measurements);

	ns_graph_object transition_posture(ns_graph_object::ns_graph_vertical_line),
				    transition_stationary(ns_graph_object::ns_graph_vertical_line);

	ns_graph_object marker(ns_graph_object::ns_graph_dependant_variable);
	marker.y.resize(number_of_measurements,-1);

	

	for (unsigned int i = 0; i < path.element_count(); i++){
		movement_ratios.y[i] = path.element(i).measurements.new_movement_ratio();
		graph_x_axis.x[i] = path.element(i).absolute_time;
		cutoff_stationary.y[i] = ns_analyzed_image_time_path::stationary_cutoff_ratio();
		cutoff_posture.y[i] = ns_analyzed_image_time_path::posture_cutoff_ratio();
	}

	bool slow(true),posture(true);
//	transition_posture.y[0] = -1;
//	transition_stationary.y[0] = -1;
	for (unsigned int i = 1; i < path.element_count(); i++){
		ns_movement_state m(path.movement_state(path.element(i).absolute_time));
		if (slow && m == ns_movement_posture){
			transition_posture.x.push_back(path.element(i).absolute_time);
			transition_posture.y.push_back(movement_ratios.y[i]);
			//transition_posture.y[i]=0; 
			slow = false;
		}
	//	else transition_posture.y[i]=-1;
		

		if (posture && m == ns_movement_stationary){
			transition_stationary.x.push_back(path.element(i).absolute_time);
			transition_stationary.y.push_back(movement_ratios.y[i]);
			posture = false;
		}
	//	else transition_stationary.y[i]=-1;
	}

	marker.properties.line.draw = 0;
	marker.properties.area_fill.draw = 0;
	marker.properties.point.draw = true;
	marker.properties.point.color = marker.properties.area_fill.color;
	marker.properties.point.width = 3;
	marker.properties.point.edge_width = marker.properties.point.width/3;
	marker.properties.point.edge_color = ns_color_8(255,255,175);
	marker.properties.draw_negatives = false;

	cutoff_stationary.properties.point.draw = false;
	cutoff_stationary.properties.line.draw = true;
	cutoff_stationary.properties.line.width = 2;
	cutoff_stationary.properties.line_hold_order = ns_graph_properties::ns_first;
	cutoff_stationary.properties.draw_vertical_lines = ns_graph_properties::ns_no_line;
	cutoff_stationary.properties.line.color = ns_color_8(175,0,0);
	cutoff_posture.properties = cutoff_stationary.properties;
	cutoff_posture.properties.line.color = ns_color_8(0,175,0);

	transition_posture.properties = cutoff_posture.properties;
	transition_posture.properties.draw_vertical_lines = ns_graph_properties::ns_full_line;
	transition_posture.properties.line_hold_order = ns_graph_properties::ns_zeroth_centered;
	transition_posture.properties.draw_negatives = false;
	transition_posture.properties.line.color = ns_color_8(0,255,0);

	transition_stationary.properties = cutoff_stationary.properties;
	transition_stationary.properties.draw_vertical_lines = ns_graph_properties::ns_full_line;
	transition_stationary.properties.line_hold_order = ns_graph_properties::ns_zeroth_centered;
	transition_stationary.properties.draw_negatives = false;
	transition_stationary.properties.line.color = ns_color_8(255,0,0);

	movement_ratios.properties.point.draw = false;
	movement_ratios.properties.line.draw = true;
	movement_ratios.properties.line.width = 2;
	movement_ratios.properties.line_hold_order = ns_graph_properties::ns_first;
	movement_ratios.properties.draw_vertical_lines = ns_graph_properties::ns_no_line;
	movement_ratios.properties.line.color=ns_color_8(125,125,125);

	graph.x_axis_properties.line.color=ns_color_8(175,175,175);
	graph.x_axis_properties.text.draw =false;
	graph.x_axis_properties.point.color=ns_color_8(175,175,175);
	graph.x_axis_properties.area_fill.color=ns_color_8(0,0,0);
	graph.x_axis_properties.draw_tick_marks = false;
	graph.y_axis_properties = 
		graph.area_properties = 
		graph.title_properties = 
		graph.x_axis_properties;



	graph.contents.push_back(movement_ratios);
	graph.contents.push_back(graph_x_axis);
	graph.contents.push_back(marker);
	graph.contents.push_back(cutoff_stationary);
//	graph.contents.push_back(cutoff_posture);
	graph.contents.push_back(transition_stationary);
	graph.contents.push_back(transition_posture);
	ns_graph_axes axes;
	graph.set_graph_display_options("",axes);

}
/*
void ns_analyzed_image_time_path::output_image_movement_summary(std::ostream & o){

	o << "Time,Movement Abs,Stationary,Ratio,State\n";
	for (unsigned int i = 0; i < elements.size(); i++){
		float r(elements[i].movement_ratio());
		o << elements[i].absolute_time << "," <<
			elements[i].
			<< elements[i].movement - elements[i].movement_alternate_worm_sum << ","
			<< elements[i].stationary_sum << ","
			<< r << ","
			<< this->movement_state(elements[i].absolute_time) << "\n";
	}
}*/

void ns_analyzed_image_time_path::add_death_time_events_to_set(ns_death_time_annotation_set & set) const{
	for (unsigned int i = 0; i < death_time_annotation_set.events.size(); i++)
		if (death_time_annotation_set.events[i].region_info_id == death_time_annotation_set.events[i].region_id)
			cerr << "YIKES!";
	set.add(death_time_annotation_set);
}
//unsigned long number_equal(0),number_not_equal(0);
void ns_analyzed_image_time_path::generate_annotations_from_movement_quantification(const unsigned long permanance_time_required_in_seconds,const ns_stationary_path_id & path_id, ns_death_time_annotation_set & set){
	event_indices.clear();
	event_indices.resize((int)ns_number_of_movement_event_types,-1);
	by_hand_annotation_event_times.resize((int)ns_number_of_movement_event_types,-1);

	unsigned long current_time(ns_current_time());
	const double stationary_cutoff(stationary_cutoff_ratio()),
				posture_cutoff(posture_cutoff_ratio());
	set.clear();
	if (elements.size() == 0) return;


	unsigned long first_valid_element_id = elements.size(),
				  last_valid_element_id = 0;
	for (unsigned int i = 0; i < elements.size(); i++)
		if (!elements[i].excluded){
			if (first_valid_element_id > i)
				first_valid_element_id = i;
			if (last_valid_element_id < i)
				last_valid_element_id = i;
		}
	if (first_valid_element_id == elements.size())
		return;
	
	//if the experiment is cropped before the current path ends, then we don't add a stationary worm is lost event.
	unsigned long actual_time_of_first_measurement_after_path_end(time_of_first_measurement_after_path_end);
	if (last_valid_element_id+1 < elements.size())
		actual_time_of_first_measurement_after_path_end = 0;
		



	//if the path has been declared as not having enough information
	//for annotation, register it as so.
	if (this->is_low_density_path()){
		for (unsigned int i = 0; i < elements.size(); i++){
			if (elements[i].excluded) continue;
			set.add(
				ns_death_time_annotation(ns_movement_censored_worm_observed,
				0,region_info_id,
				ns_death_time_annotation_time(elements[i].absolute_time,elements[i].absolute_time),
				elements[i].region_offset_in_source_image(),
				elements[i].worm_region_size(),
				ns_death_time_annotation::ns_machine_excluded,
				0,
				current_time,ns_death_time_annotation::ns_lifespan_machine,
				elements[i].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
				path_id,false));
		}
		return;
	}/*
	if (this->is_not_stationary()){
		for (unsigned int i = 0; i < elements.size(); i++){
			if (elements[i].excluded) continue;
			set.add(
				ns_death_time_annotation(ns_slow_moving_worm_observed,
				0,region_info_id,
				ns_death_time_annotation_time(elements[i].absolute_time,elements[i].absolute_time),
				elements[i].region_offset_in_source_image(),
				elements[i].worm_region_size(),ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
				elements[i].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
				path_id,"NS",false)
				);
		}
		return;
	}*/

	event_indices[ns_fast_movement_cessation] = first_valid_element_id;

	//go forward through the path
	//and find the last time animals were moving
	//fast enough to be marked as changing posture (last_posture time)
	//or f
	//unsigned long last_stationary_time(elements[0].absolute_time),
	//			  last_posture_time(elements[0].absolute_time),
	unsigned long last_time_point_at_which_slow_movement_was_observed(0),
				  last_time_point_at_which_posture_changes_were_observed(0);

	//unsigned long posture_start_time(0),
	//			  stationary_start_time(0);
	
	bool found_slow_movement_cessation(false),
		 found_posture_change_cessation(false);


	//since the movement images are calculated as image[t]-image[t-1], that means the movement occurred between time points t and t-1.
	//thus if the movement ratio drops below a threshold at time t, the animal died between time t and t-1.
	//thus when an animal's movement ratio drops below some threshold at time t, we annotate it's death at time t.

	//an exception is made for animals whose movement ratio drops below a threshold at the second frame.
	//this is because we can't calculate reasonable movement ratios in the first frame, and thus assume the animals 
	//died the frame before it.

	for (long t = 0; t < elements.size(); t++){
		
		if (elements[t].excluded) continue;

		double r(elements[t].measurements.new_movement_ratio());
		const unsigned long &cur_time (elements[t].absolute_time);
		//keep on pushing the last posture time and last sationary
		//times forward until we hit a low enough movement ratio
		//to meet the criteria.  At that point, the last posture 
		//and last stationary cutoffs stick
		
		
		if (r > posture_cutoff)
			last_time_point_at_which_slow_movement_was_observed = t;
		if (r > stationary_cutoff)
			last_time_point_at_which_posture_changes_were_observed = t;

		if (!found_slow_movement_cessation &&

			//if the last time the worm was moving slowly enough to count 
			//as changing posture or remaining stationary is a long time ago
			//mark that time as the change.
			(cur_time - elements[last_time_point_at_which_slow_movement_was_observed].absolute_time) > permanance_time_required_in_seconds){
				//posture_start_time = elements[last_posture_index+1].absolute_time;
				found_slow_movement_cessation = true;
				//since we can't make accurate measurements of the first time point, if an event falls one after it,
				//shift it all the way to the first time point.
				if (last_time_point_at_which_slow_movement_was_observed == 1)
					last_time_point_at_which_slow_movement_was_observed = 0;
				event_indices[ns_translation_cessation] = last_time_point_at_which_slow_movement_was_observed;
			
		}
		

		if (!found_posture_change_cessation &&

			(cur_time - elements[last_time_point_at_which_posture_changes_were_observed].absolute_time) > permanance_time_required_in_seconds){
				//stationary_start_time = elements[last_stationary_index+1].absolute_time;
				found_posture_change_cessation = true;
				if (last_time_point_at_which_posture_changes_were_observed == 1)
					last_time_point_at_which_posture_changes_were_observed = 0;
				event_indices[ns_movement_cessation] = last_time_point_at_which_posture_changes_were_observed;
				break;
			}
	}
	const bool part_of_a_full_trace(found_posture_change_cessation);

	//we mark the beginning time of the path as the cessation of fast movement.
	set.add(
		ns_death_time_annotation(ns_fast_movement_cessation,
		0,region_info_id,
		ns_death_time_annotation_time(elements[first_valid_element_id].absolute_time,elements[first_valid_element_id].absolute_time),
		elements[first_valid_element_id].region_offset_in_source_image(),  //register the position of the object at that time point
		elements[first_valid_element_id].worm_region_size(),
		ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
		elements[first_valid_element_id].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
		path_id,part_of_a_full_trace));


	//if the worm never slowed down to posture speed, mark all points as depicting slow-moving worms
	if (!found_slow_movement_cessation){
		for (unsigned int i = 0; i < elements.size(); i++){
			if (elements[i].excluded) continue;

			set.add(
				ns_death_time_annotation(ns_slow_moving_worm_observed,
				0,region_info_id,
				ns_death_time_annotation_time(elements[i].absolute_time,elements[i].absolute_time),
				elements[i].region_offset_in_source_image(),
				elements[i].worm_region_size(),ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
				elements[i].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
				path_id,part_of_a_full_trace,"NSM")
				);
		}
		return;
	}

	//if we find the worm to slow down to posture speed at any point, mark times before that as
	//the worm moving slowly

	for (unsigned int i = 0; i < event_indices[ns_translation_cessation]; i++){
		
		if (elements[i].excluded) continue;

		set.add(
			ns_death_time_annotation(ns_slow_moving_worm_observed,
			0,region_info_id,
			ns_death_time_annotation_time(elements[0].absolute_time,elements[i].absolute_time),
			elements[i].region_offset_in_source_image(),  //register the position of the object at that time point
			elements[i].worm_region_size(),
			ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
			elements[i].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
			path_id,part_of_a_full_trace));
	}

	set.add(
		ns_death_time_annotation(ns_translation_cessation,
		0,region_info_id,
		ns_death_time_annotation_time(elements[event_indices[ns_translation_cessation]].absolute_time,elements[event_indices[ns_translation_cessation]].absolute_time),
		elements[event_indices[ns_translation_cessation]].region_offset_in_source_image(),  //register the position of the object at that time point
		elements[event_indices[ns_translation_cessation]].worm_region_size(),
		ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
		elements[event_indices[ns_translation_cessation]].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
		path_id,part_of_a_full_trace));

	//if the worm slows down to posture speed but never stops, mark all points from it's posture speed start time 
	//until the end of the path as changing posture.
	if (!found_posture_change_cessation){
		for (unsigned int i = event_indices[ns_translation_cessation]; i < elements.size(); i++){
			if (elements[i].excluded) continue;
			set.add(
				ns_death_time_annotation(ns_posture_changing_worm_observed,
				0,region_info_id,
				ns_death_time_annotation_time(elements[i].absolute_time,elements[i].absolute_time),
				elements[i].region_offset_in_source_image(),  //register the position of the object at that time point
				elements[i].worm_region_size(),
				ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
				elements[i].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
				path_id,part_of_a_full_trace));
		}
		return;
	}
	//if the worm finally stops, mark the times up until it stops as changing posture, and the times afterward as not moving.


	for (unsigned int i = event_indices[ns_translation_cessation]; i < event_indices[ns_movement_cessation]; i++){
		if (elements[i].excluded) continue;
		set.add(
			ns_death_time_annotation(ns_posture_changing_worm_observed,
			0,region_info_id,
			ns_death_time_annotation_time(elements[i].absolute_time,elements[i].absolute_time),
			elements[i].region_offset_in_source_image(),
			elements[i].worm_region_size(),
			ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
			elements[i].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
			path_id,part_of_a_full_trace));
	}

	for (unsigned int i = event_indices[ns_movement_cessation]; i < elements.size(); i++){
		if (elements[i].excluded) continue;
		set.add(
			ns_death_time_annotation(ns_stationary_worm_observed,
			0,region_info_id,
			ns_death_time_annotation_time(event_indices[ns_movement_cessation],elements[i].absolute_time),
			elements[i].region_offset_in_source_image(),
			elements[i].worm_region_size(),
			ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
			elements[i].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
			path_id,part_of_a_full_trace));
	}

/*	if (event_indices[ns_translation_cessation] != event_indices[ns_fast_movement_cessation])
		number_not_equal++;
	else number_equal++;
	cerr << (100*number_equal)/(number_not_equal + number_equal) << " animals  have identical fast and slow movement spans.\n";
	*/
	set.add(
		ns_death_time_annotation(ns_movement_cessation,
		0,region_info_id,
		ns_death_time_annotation_time(elements[event_indices[ns_movement_cessation]].absolute_time,elements[event_indices[ns_movement_cessation]].absolute_time),
		elements[event_indices[ns_movement_cessation]].region_offset_in_source_image(),
		elements[event_indices[ns_movement_cessation]].worm_region_size(),
		ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
		elements[event_indices[ns_movement_cessation]].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
		path_id,part_of_a_full_trace));

	if (actual_time_of_first_measurement_after_path_end != 0){
		set.add(
			ns_death_time_annotation(ns_stationary_worm_disappearance,
			0,region_info_id,
			ns_death_time_annotation_time(actual_time_of_first_measurement_after_path_end,actual_time_of_first_measurement_after_path_end),
			elements[last_valid_element_id].region_offset_in_source_image(),
			elements[last_valid_element_id].worm_region_size(),
			ns_death_time_annotation::ns_not_excluded,0,current_time,ns_death_time_annotation::ns_lifespan_machine,
			elements[last_valid_element_id].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
			path_id,part_of_a_full_trace));
	}
}
void ns_analyzed_image_time_path::analyze_movement(const unsigned long permanance_time_required_in_seconds,const ns_stationary_path_id & path_id){
	
	generate_annotations_from_movement_quantification(permanance_time_required_in_seconds,path_id,death_time_annotation_set);
	
}

ns_movement_state ns_analyzed_image_time_path::movement_state(const unsigned long & t) const{
	//if (this->is_not_stationary())
//		return ns_movement_fast;
	if (this->is_low_density_path())
		return ns_movement_machine_excluded;

	ns_event_index_list::const_iterator p;
	if (event_indices[ns_fast_movement_cessation] == -1
		||  t < elements[event_indices[ns_fast_movement_cessation]].absolute_time)
		return ns_movement_fast;
	
	if (event_indices[ns_translation_cessation]== -1
		|| t < elements[event_indices[ns_translation_cessation]].absolute_time)
		return ns_movement_slow;

	
	if (event_indices[ns_movement_cessation] == -1 
		|| t < elements[event_indices[ns_movement_cessation]].absolute_time)
		return ns_movement_posture;

	return ns_movement_stationary;
}
void ns_time_path_image_movement_analyzer::produce_death_time_annotations(ns_death_time_annotation_set & set,ns_worm_movement_summary_series & summary_series) const{
	
	set.clear();
	for (unsigned long j = 0; j < groups.size(); j++){
		for (unsigned long k = 0; k < groups[j].paths.size(); k++){
			groups[j].paths[k].add_death_time_events_to_set(set);
		}
	}

	//add animals that are fast moving at the last time point
	set.add(extra_non_path_events);

	ns_death_time_annotation_compiler comp;
	comp.add(set);
	summary_series.clear();
	summary_series.from_death_time_annotations(comp,false);
	summary_series.calculate_survival();
	summary_series.calculate_missing_moving_worms();
	for (unsigned int i = 1; i < summary_series.measurements.size(); i++){
		unsigned long number_of_worms_that_went_missing(summary_series.measurements[i].processed_number_of_animals_lost - summary_series.measurements[i-1].processed_number_of_animals_lost);
		for (unsigned int j = 0; j < number_of_worms_that_went_missing; j++)
			set.add(
					 ns_death_time_annotation(ns_moving_worm_disappearance,
					 0,region_info_id,
					 ns_death_time_annotation_time(summary_series.measurements[i].time,summary_series.measurements[i].time),
					 ns_vector_2i(0,0),
					 ns_vector_2i(0,0),
					 ns_death_time_annotation::ns_censored,
					 0,ns_current_time(),
					 ns_death_time_annotation::ns_lifespan_machine,
					 ns_death_time_annotation::ns_single_worm,
					 ns_stationary_path_id(),false,
					 "Worm Went Missing")
				);
	}
	
}

void ns_analyzed_image_time_path_group::clear_images(){
	for (unsigned int i = 0; i < paths.size(); i++)
		for (unsigned int j = 0; j < paths[i].elements.size(); j++){
			paths[i].elements[j].clear_movement_images();
			paths[i].elements[j].clear_path_aligned_images();

		}

}

//transfers a line from a rbg image to a grayscale one.
class ns_output_subline{
public:
	template<class ns_component, class ns_component_2>
		inline void operator()(const ns_image_whole<ns_component> & source, 
			const unsigned long & source_x_offset, 
			const unsigned long & dest_x_offset,
			const unsigned long & width, 
			const unsigned long &source_y, 
			const unsigned long &dest_y,
			ns_image_whole<ns_component_2> & dest,const unsigned long & channel){

			for (unsigned int x = 0; x < dest_x_offset; x++)
				dest[dest_y][x] = 0;
			for (unsigned int x = 0; x < width; x++)
				dest[dest_y][x+dest_x_offset] = (ns_component_2)source[source_y][3*(x+source_x_offset)+channel];
			for (unsigned int x = width+dest_x_offset; x < dest.properties().width; x++)
				dest[dest_y][x] = 0;
		}	
	template<class ns_component, class ns_component_2>
		inline void output_specific_value(const ns_image_whole<ns_component> & source, 
			const unsigned long & source_x_offset, 
			const unsigned long & dest_x_offset,
			const unsigned long & width, 
			const unsigned long &source_y, 
			const unsigned long &dest_y,
			ns_image_whole<ns_component_2> & dest,const unsigned long & channel, const ns_component desired_val){

			for (unsigned int x = 0; x < dest_x_offset; x++)
				dest[dest_y][x] = 0;
			for (unsigned int x = 0; x < width; x++)
				dest[dest_y][x+dest_x_offset] = (ns_component_2)(source[source_y][3*(x+source_x_offset)+channel] == desired_val);
			for (unsigned int x = width+dest_x_offset; x < dest.properties().width; x++)
				dest[dest_y][x] = 0;
		}
};



bool ns_analyzed_image_time_path::region_image_is_required(const unsigned long time){
	for (unsigned int k = 0; k < elements.size(); k++){
		if (time == elements[k].absolute_time) return true;
	}
	return false;
}

//generates path_aligned_image from region visualiation
//note that the region images contain context images (ie. the extra boundary around the region_image)
bool ns_analyzed_image_time_path::populate_images_from_region_visualization(const unsigned long time,const ns_image_standard &region_visualization){
	
	ns_image_properties path_aligned_image_image_properties(region_visualization.properties());
	set_path_alignment_image_dimensions(path_aligned_image_image_properties);

	ns_output_subline output_subline;
	for (unsigned int k = 0; k < elements.size(); k++){
		if (time != elements[k].absolute_time) continue;
	
		ns_analyzed_image_time_path_element & e(elements[k]);

		e.path_aligned_image.init(path_aligned_image_image_properties);
		e.path_aligned_region_threshold.init(path_aligned_image_image_properties);
		e.path_aligned_worm_threshold.init(path_aligned_image_image_properties);
		//offset_from_path is the distance the region image is from the bounding box around the path
		const ns_vector_2i tl_worm_context_position_in_pa(ns_analyzed_image_time_path::maximum_alignment_offset()+e.offset_from_path);

		for (long y = 0; y < tl_worm_context_position_in_pa.y; y++){
			for (unsigned long x = 0; x < path_aligned_image_image_properties.width; x++){
				e.path_aligned_image[y][x] = 0;
				e.path_aligned_region_threshold[y][x] = 0;
				e.path_aligned_worm_threshold[y][x] = 0;
			}
		}

		//fill in center
		ns_vector_2i br_worm_context_position_in_pa(tl_worm_context_position_in_pa + e.worm_context_size());
		if (br_worm_context_position_in_pa.x >= path_aligned_image_image_properties.width)
			throw ns_ex("Overflow in worm position!");
		if (br_worm_context_position_in_pa.y >= path_aligned_image_image_properties.height)
			throw ns_ex("Overflow in worm position!");

		for (long y = 0; y < e.worm_context_size().y; y++){		
			output_subline(region_visualization,							//source
			e.context_offset_in_region_visualization_image().x,		//source x offset
			tl_worm_context_position_in_pa.x,									//dest x offset
			e.worm_context_size().x,										//width
			y+e.context_offset_in_region_visualization_image().y,	//source y offset
			y+tl_worm_context_position_in_pa.y,												//dest y offset
			e.path_aligned_image,1);	

			output_subline.output_specific_value(region_visualization,							//source
			e.context_offset_in_region_visualization_image().x,		//source x offset
			tl_worm_context_position_in_pa.x,							//dest x offset
			e.worm_context_size().x,										//width
			y+e.context_offset_in_region_visualization_image().y,	//source y offset
			y+tl_worm_context_position_in_pa.y,										//dest y offset
			e.path_aligned_worm_threshold,2,(ns_8_bit)NS_REGION_VIS_WORM_THRESHOLD_VALUE);										//dest


			output_subline.output_specific_value(region_visualization,							//source
			e.context_offset_in_region_visualization_image().x,		//source x offset
			tl_worm_context_position_in_pa.x,											//dest x offset
			e.worm_context_size().x,										//width
			y+e.context_offset_in_region_visualization_image().y,	//source y offset
			y+tl_worm_context_position_in_pa.y,												//dest y offset
			e.path_aligned_region_threshold,2,(ns_8_bit)NS_REGION_VIS_ALL_THRESHOLDED_OBJECTS_VALUE);										//dest		
		}


		//fill in gap at bottom
		for (long y = br_worm_context_position_in_pa.y; y < path_aligned_image_image_properties.height; y++){
			for (unsigned long x = 0; x < path_aligned_image_image_properties.width*path_aligned_image_image_properties.components; x++){
				e.path_aligned_image[y][x] = 0;
				e.path_aligned_region_threshold[y][x] = 0;
				e.path_aligned_worm_threshold[y][x] = 0;
			}

		}
		return true;
	}
	return false;
}
void ns_output_subimage(const ns_image_standard & im,const long offset,ns_image_standard & out){
	const ns_image_properties & prop(out.properties());
	const ns_image_properties & prop_i(im.properties());
	
	for (long y = 0; y < prop.height; y++)
		for (unsigned int x = 0; x < prop.width*prop.components; x++)
			out[y][x] = im[y+offset][x/prop_i.components];
}

void ns_time_path_image_movement_analyzer::add_by_hand_annotation_event_times(const ns_death_time_annotation_compiler & annotations){
	ns_death_time_annotation_compiler::ns_region_list::const_iterator p(annotations.regions.find(region_info_id));
	if (p != annotations.regions.end()){
		for (ns_death_time_annotation_compiler_region::ns_location_list::const_iterator q = p->second.locations.begin(); q != p->second.locations.end(); q++){
			for (unsigned int k = 0; k < q->annotations.size(); k++){
				if (q->annotations[k].annotation_source == ns_death_time_annotation::ns_posture_image ||
					q->annotations[k].annotation_source == ns_death_time_annotation::ns_storyboard ||
					q->annotations[k].annotation_source == ns_death_time_annotation::ns_region_image)
					add_by_hand_annotation_event_time(q->annotations[k]);
			}
		}
	}
}

void ns_time_path_image_movement_analyzer::add_by_hand_annotation_event_time(const ns_death_time_annotation & e){
	if (e.excluded == ns_death_time_annotation::ns_not_excluded &&
		e.type != ns_translation_cessation &&
		e.type != ns_movement_cessation &&		
		e.type != ns_fast_movement_cessation &&
		e.type != ns_worm_death_posture_relaxation_termination)
		return;
	
	ns_analyzed_image_time_path * p(0);
	//try to use path specification
	if (e.stationary_path_id.specified()){
		bool found(false);
		for (unsigned int i = 0; i < groups.size() && !found; i++){
			for (unsigned int j = 0; j < groups[i].paths.size() && !found; j++){
				for (unsigned int k = 0; k < groups[i].paths[j].death_time_annotations().size(); k++){
					if (groups[i].paths[j].death_time_annotations()[k].stationary_path_id == e.stationary_path_id){
						p = &groups[i].paths[j];
						found = true;
						break;
					}
				}
			}
		}
	}
	//otherwise search by time and location
	bool found(false);
	for (unsigned int i = 0; i < groups.size() && !found; i++){
		for (unsigned int j = 0; j < groups[i].paths.size() && !found; j++){

			ns_death_time_annotation_time t(groups[i].paths[j].start_time(),groups[i].paths[j].stop_time());
			if (t.overlap(e.time) && 
				(groups[i].paths[j].path_region_position - e.position).mag() < ns_death_time_annotation_compiler::match_distance){
				p = &groups[i].paths[j];
				found = true;
				break;
			}
		}
	}
	if (p != 0){
		e.transfer_sticky_properties(p->censoring_and_flag_details);
		if (e.type != ns_no_movement_event)
			p->by_hand_annotation_event_times[(int)e.type] = e.time.end_time;
	}
}

void ns_time_path_image_movement_analyzer::output_visualization(const string & base_directory) const{

	ns_dir::create_directory_recursive(base_directory);
	unsigned long p(0);

	string all_quant_filename(base_directory + DIR_CHAR_STR + "all_quant.csv");
	ofstream all_quant(all_quant_filename.c_str());
	all_quant << "path_id,time,stationary,movement,alt_movement\n";

	for (unsigned int i = 0; i < groups.size(); i++){
		for (unsigned int j = 0; j < groups[i].paths.size(); j++){
		//	cerr << "Writing out visualization for path " << p << "\n";
			if (groups[i].paths[j].element_count() == 0) continue;
			string base_dir2(base_directory + DIR_CHAR_STR + "path_" + ns_to_string(p));
			ns_dir::create_directory(base_dir2);

		//	string hist_filename(base_dir2 + DIR_CHAR_STR + "hist.csv");
		//	ofstream hist(hist_filename.c_str());
//			groups[i].paths[j].out_histograms(hist);
	//		hist.close();

			string quant_filename(base_dir2 + DIR_CHAR_STR + "quant.csv");
			ofstream quant(quant_filename.c_str());
			
			quant << "path_id,time,stationary,movement,alt_movement\n";


			string dir(base_dir2 + DIR_CHAR_STR + "raw");
			string dir_aligned(base_dir2 + DIR_CHAR_STR "registered");
			string dir_movement(base_dir2 + DIR_CHAR_STR "movement");
			
			ns_dir::create_directory_recursive(dir);
			
			ns_dir::create_directory_recursive(dir_aligned);
			ns_dir::create_directory_recursive(dir_movement);

			ns_image_standard out;	
			//ns_image_properties prop(groups[i].paths[j].element(0).path_aligned_image.properties());
			//prop.width = groups[i].paths[j].size.x;
			//prop.height = groups[i].paths[j].size.y;
			//out.init(prop);

			ns_image_standard out_c;

			for (unsigned int k = 0; k < groups[i].paths[j].element_count(); k++){
				quant << p << "," << groups[i].paths[j].element(k).relative_time/(60*60*24.0) << ","
					<< groups[i].paths[j].element(k).measurements.stationary_sum << "," 
					<< groups[i].paths[j].element(k).measurements.movement_sum << "," 
					<< groups[i].paths[j].elements[k].measurements.movement_alternate_worm_sum <<"\n";
				
				all_quant << p << "," << groups[i].paths[j].element(k).relative_time/(60*60*24.0) << ","
					<< groups[i].paths[j].element(k).measurements.stationary_sum << "," 
					<< groups[i].paths[j].element(k).measurements.movement_sum  << ","
					<< groups[i].paths[j].elements[k].measurements.movement_alternate_worm_sum <<"\n";

				string num;
				if (k < 10)
					num+="00";
				else if ( k < 100)
					num+="0";
				num+=ns_to_string(k);
				string filename = string(DIR_CHAR_STR) + "im_" + num + ".tif";

			//	ns_image_standard im(groups[i].paths[j].element(k).path_aligned_image);

			//	ns_image_properties prop(im.properties());
			//	prop.width = groups[i].paths[j].size.x;
			//	prop.height = groups[i].paths[j].size.y;
			//	out.init(prop);

			//	ns_output_subimage(im,ns_analyzed_image_time_path::maximum_alignment_offset,out);
			//	ns_save_image<ns_8_bit>(dir + filename,groups[i].paths[j].element(k).path_aligned_image);

			//	ns_output_subimage(im,ns_analyzed_image_time_path::maximum_alignment_offset + groups[i].paths[j].element(k).vertical_registration,out);
			//	ns_save_image(dir_aligned + filename,out);

			//	groups[i].paths[j].element(k).generate_movement_visualization(out_c);
		//		ns_save_image<ns_8_bit>(dir_movement + filename,out_c);

			}

			p++;
		}
	}
}

class ns_calc_best_alignment{
public:
	ns_calc_best_alignment(const ns_vector_2d & corse_step_,const ns_vector_2d & fine_step_, const ns_vector_2i & max_offset_, const ns_vector_2i &local_offset_,const ns_vector_2i &bottom_offset_,const ns_vector_2i &size_offset_):
		max_offset(max_offset_),local_offset(local_offset_),bottom_offset(bottom_offset_),size_offset(size_offset_),corse_step(corse_step_),fine_step(fine_step_){}

	ns_vector_2d operator()(ns_alignment_state & state,const ns_image_standard & image, bool & saturated_offset) {
		
		//ofstream foo("c:\\tst.txt");
		double min_diff(DBL_MAX);
		ns_vector_2d best_offset(0,0);


	//	const ns_vector_2i br_s(image.properties().width-size_offset.x,image.properties().height-size_offset.y);
		
		//double area_2(((br.y-tl.y+1)/2)*((br.x-tl.x+1)/2));
		ns_vector_2d offset_range_l(state.registration_offset_average()-local_offset),
					 offset_range_h(state.registration_offset_average()+local_offset);
		saturated_offset=false;

		if (offset_range_l.x-1+fine_step.x < -max_offset.x){
			offset_range_l.x = -max_offset.x+1-fine_step.x;
			saturated_offset = true;
		}
		if (offset_range_l.y-1+fine_step.y < -max_offset.y){
			offset_range_l.y = -max_offset.y+1-fine_step.y;
			saturated_offset = true;
		}
		if (offset_range_h.x+1-fine_step.x > max_offset.x){
			offset_range_h.x = max_offset.x-1+fine_step.x;
			saturated_offset = true;
		}
		if (offset_range_h.y+1-fine_step.y > max_offset.y){
			offset_range_h.y = max_offset.y-1+fine_step.y;
			saturated_offset = true;
		}
		//if (saturated_offset)
			//cerr << "Saturated Offset!\n";

		const ns_vector_2i tl(bottom_offset),
					br((long)image.properties().width-size_offset.x,
					(long)image.properties().height-size_offset.y);
		double area((br.y-tl.y)*(br.x-tl.x));

		//very corse first search
		for (int dy = (int)offset_range_l.y; dy <= (int)offset_range_h.y; dy++){
			for (int dx = (int)offset_range_l.x; dx <= (int)offset_range_h.x; dx++){
				double sum(0);
				for (long y = tl.y; y < br.y; y++){
					for (long x = tl.x; x < br.x; x++){
						const double s(state.consensus_count[y  ][x  ]?state.consensus_count[y  ][x  ]:1);
						//the value of the consensus image is it's mean: consensus[y][x]/consensus_count[y][x]
						sum+=fabs(state.consensus[y+dy][x+dx]/s - (double)image[y][x]);
					}
				}
				sum/=(area);
				if (min_diff > sum){
					min_diff = sum;
					best_offset.y = dy;
					best_offset.x = dx;
				}
			}
		}
		#ifdef NS_DO_SUBPIXEL_REGISTRATION
		//subpixel search
		ns_vector_2d center = best_offset;
		for (double dy = center.y-1+corse_step.y; dy < center.y+1; dy+=corse_step.y){
			for (double dx = center.x-1+corse_step.x; dx < center.x+1; dx+=corse_step.x){
				double sum(0);
				int count(0);
				for (long y = tl.y; y < br.y; y++){
					for (long x = tl.x; x < br.x; x++){
						const double s[4]={state.consensus_count[y  ][x  ]?state.consensus_count[y  ][x  ]:1,
										   state.consensus_count[y+1][x  ]?state.consensus_count[y+1][x  ]:1,
										   state.consensus_count[y  ][x+1]?state.consensus_count[y  ][x+1]:1,
										   state.consensus_count[y+1][x+1]?state.consensus_count[y+1][x+1]:1
										  };
						//the value of the consensus image is it's mean: consensus[y][x]/consensus_count[y][x]
						sum+=fabs(state.consensus.sample_weighted(y+dy,x+dx,s[0],s[1],s[2],s[3]) - (double)image[y][x]);
						count++;
					}
				}
				sum/=count;
			//	o << cur_diff << ",";
				if (min_diff > sum){
					min_diff = sum;
					best_offset.y = dy;
					best_offset.x = dx;
				}
			}
		}

		center = best_offset;
		for (double dy = center.y-corse_step.y+fine_step.y; dy < center.y+corse_step.y; dy+=fine_step.y){
			for (double dx = center.x-corse_step.x+fine_step.x; dx < center.x+corse_step.x; dx+=fine_step.x){
				double sum(0);
				int count(0);
				for (long y = tl.y; y < br.y; y++){
					for (long x = tl.x; x < br.x; x++){
						const double s[4]={state.consensus_count[y  ][x  ]?state.consensus_count[y  ][x  ]:1,
										   state.consensus_count[y+1][x  ]?state.consensus_count[y+1][x  ]:1,
										   state.consensus_count[y  ][x+1]?state.consensus_count[y  ][x+1]:1,
										   state.consensus_count[y+1][x+1]?state.consensus_count[y+1][x+1]:1
										  };
						//the value of the consensus image is it's mean: consensus[y][x]/consensus_count[y][x]
						sum+=fabs(state.consensus.sample_weighted(y+dy,x+dx,s[0],s[1],s[2],s[3]) - (double)image[y][x]);
						count++;
					}
				}
				sum/=count;
				if (min_diff > sum){
					min_diff = sum;
					best_offset.y = dy;
					best_offset.x = dx;
				}
			}
		}
		#endif
		return best_offset;
	}

private:
	const ns_vector_2d corse_step, fine_step;
	const ns_vector_2d max_offset,local_offset,bottom_offset,size_offset;

};


void ns_analyzed_image_time_path_element::generate_movement_visualization(ns_image_standard & out) const{
	ns_image_properties p(registered_movement_image_.properties());
	p.components = 3;
	out.init(p);
	for (unsigned int y = 0; y < p.height; y++)
		for (unsigned int x = 0; x < p.width; x++){
			unsigned int r(2*(registered_movement_image_[y][x]>0)?(registered_movement_image_[y][x]):0);
			//r=0;
			if (r>255)r=255;
			r = (r+registered_image[y][x]);
			if (r >= 255)r=255;
			out[y][3*x] = r;
			out[y][3*x+1] = 
			out[y][3*x+2] = registered_image[y][x];
		}
}

class ns_debug_image_out{
public:
	void operator ()(const string &dir, const string & filename, const unsigned long kernal_size,const ns_image_whole<double> & im, const ns_image_whole<ns_16_bit> & consensus_count, const ns_image_whole<ns_8_bit> & unaligned_image){
		string filename_im(dir + DIR_CHAR_STR + "consensus" + DIR_CHAR_STR + filename),
			   filename_count(dir + DIR_CHAR_STR + "count" + DIR_CHAR_STR + filename),
			   filename_unaligned(dir + DIR_CHAR_STR + "unaligned" + DIR_CHAR_STR + filename);
		ns_dir::create_directory_recursive(dir + DIR_CHAR_STR + "consensus");
		ns_dir::create_directory_recursive(dir + DIR_CHAR_STR + "count");
		ns_dir::create_directory_recursive(dir + DIR_CHAR_STR + "unaligned");
		ns_image_properties prop(im.properties());
		count_swap.init(prop);
		im_swap.init(prop);

		for (unsigned int y = 0; y < prop.height; y++){
			for (unsigned int x = 0; x < prop.width; x++){
				im_swap[y][x] = (ns_8_bit)(im[y][x]/consensus_count[y][x]);
				count_swap[y][x] = (ns_8_bit)((((unsigned long)255)*consensus_count[y][x])/(kernal_size));
			}
		}
		ns_save_image<ns_8_bit>(filename_im,im_swap);
		ns_save_image(filename_count,count_swap);
		ns_save_image(filename_unaligned,unaligned_image);
	}
private:
	ns_image_whole<ns_8_bit> count_swap;
	ns_image_whole<ns_8_bit> im_swap;
};
//possible range of a sobel operator: (0,255)
inline ns_8_bit ns_sobel(const ns_image_standard & im,const unsigned long &x, const unsigned long & y){
	const unsigned long c(ns_analyzed_image_time_path::sobel_operator_width);
	const long sobel_y((long)im[y-c][x-c]+2*(long)im[y-c][x]+(long)im[y-c][x+c]
					  -(long)im[y+c][x-c]-2*(long)im[y+c][x]-(long)im[y+c][x+c]);
	const long sobel_x((long)im[y-c][x-c]+2*(long)im[y][x-c]+(long)im[y+c][x-c]
					  -(long)im[y-c][x+c]-2*(long)im[y][x+c]-(long)im[y+c][x+c]);
	return (ns_8_bit)(sqrt((double)(sobel_x*sobel_x+sobel_y*sobel_y))/5.65685);
}

void ns_analyzed_image_time_path::quantify_movement(const ns_analyzed_time_image_chunk & chunk){
	
	/*for (unsigned long i = 0; i < 256; i++){
		movement_histogram[i]=0;
		stationary_histogram[i]=0;
	}*/

	for (unsigned int i = chunk.start_i; i < chunk.stop_i; i++){
		elements[i].measurements.zero();

		if (elements[i].excluded) continue;
	//	elements[i].measurements.registration_offset = elements[i].registration_offset.mag();
		for (unsigned long y = 0; y < elements[i].registered_movement_image_.properties().height; y++){
			for (unsigned long x = 0; x < elements[i].registered_movement_image_.properties().width; x++){
				
		//		movement_histogram[elements[i].registered_movement_image_[y][x]]++;
		//		stationary_histogram[elements[i].registered_image[y][x]]++;
				const bool worm_threshold(elements[i].registered_worm_neighborhood_threshold[y][x]);

				const bool alternate_worm_threshold(elements[i].registered_region_threshold[y][x] == 1 && 
													!worm_threshold);

				elements[i].measurements.movement_sum+= worm_threshold?abs(elements[i].registered_movement_image_[y][x]):0;
				elements[i].measurements.stationary_sum+=worm_threshold?elements[i].registered_image[y][x]:0;

				if (i < movement_time_kernel_width)
					elements[i].measurements.stationary_change_sum = 0;
				else elements[i].measurements.stationary_change_sum = elements[i].measurements.stationary_sum - elements[i-movement_time_kernel_width].measurements.stationary_sum;
				

				elements[i].measurements.movement_alternate_worm_sum+= (alternate_worm_threshold)?
															(abs(elements[i].registered_movement_image_[y][x])):0;

				elements[i].measurements.total_worm_area += (worm_threshold?1:0);
				elements[i].measurements.total_intensity_within_worm_area += worm_threshold?elements[i].registered_image[y][x]:0;
				
				elements[i].measurements.total_alternate_worm_area += (alternate_worm_threshold?1:0);
				elements[i].measurements.total_intensity_within_alternate_worm += alternate_worm_threshold?elements[i].registered_image[y][x]:0;
				
				
				elements[i].measurements.total_intensity_within_region+=elements[i].registered_image[y][x];
				elements[i].measurements.total_region_area++;
			}
		}
	}
}
void ns_analyzed_image_time_path::generate_movement_images(const ns_analyzed_time_image_chunk & chunk){
	const long n(movement_detection_kernal_half_width);
	const long kernel_area((2*n+1)*(2*n+1));
	const long dt(movement_time_kernel_width);

	const unsigned long C(256);
	const unsigned long C_sqrt(16);
	ns_image_properties prop(elements[chunk.start_i].path_aligned_image.properties());
	set_path_alignment_image_dimensions(prop);
	if (!(prop == elements[chunk.start_i].path_aligned_image.properties()))
		throw ns_ex("The path aligned image has the wrong size!");

	registered_image_properties = prop;
	prop.components = 1;
	double m_min(FLT_MAX),m_max(0);

	
	const unsigned long movement_start_i((chunk.start_i>dt)?chunk.start_i:dt);

	
	for (unsigned int i = chunk.start_i; i < chunk.stop_i; i++){

		if (elements[i].excluded) continue;
		
		elements[i].registered_movement_image_.init(prop);
		elements[i].registered_image.init(prop);
		elements[i].registered_region_threshold.init(prop);
		elements[i].registered_worm_threshold_.init(prop);
		elements[i].registered_worm_neighborhood_threshold.init(prop);

		
		//fill in top border

		//mapping from pixels in im to pixels in im_1


		//ok the tricky thing here is that each individual image is valid between [0, elements[i].worm_context_size()]
		//but the *intersection* between two consecutive frames, which we want to quantify
		//is only valid within the overlapping range [0 + offset, elements[i].worm_context_size+offset].
		//For each image we output the entire [0,element[i].worm_context_size()] offset by v0
		//to registered_image, registered_region_threshold, and registered_worm_threshold
		//but for the registered_movement_image we only output the minimal overlap which is
		// [maximum_alignment_offset()
		const ns_vector_2d v0(elements[i].registration_offset);

		ns_vector_2i tl(maximum_alignment_offset()+elements[i].offset_from_path);
		ns_vector_2i br(tl+elements[i].worm_context_size());
		if (br.x > prop.width-maximum_alignment_offset().x)
			br.x = prop.width-maximum_alignment_offset().x;
		if (br.y > prop.width-maximum_alignment_offset().y)
			br.y = prop.width-maximum_alignment_offset().y;

		//here we crop 2i
		//so the registered image rage may be slightly smaller than it could be
		//as we miss the left or right fraction of a pixel
		ns_vector_2i tl_registered(maximum_alignment_offset()+ns_vector_2i(v0.x,v0.y)+elements[i].offset_from_path);
		ns_vector_2i br_registered(tl_registered+elements[i].worm_context_size());
		//ns_vector_2i br(ns_vector_2i(elements[0].path_aligned_image.properties().width,elements[0].path_aligned_image.properties().height)-maximum_alignment_offset());

		//fill bottom
		for (long y = 0; y < tl_registered.y; y++){
			for (long x = 0; x < prop.width; x++){
				elements[i].registered_image			[y][x] = NS_MARGIN_BACKGROUND;
				elements[i].registered_region_threshold	[y][x] = NS_MARGIN_BACKGROUND;
				elements[i].registered_worm_threshold_	[y][x] = NS_MARGIN_BACKGROUND;
			}
		}	
		
		for (long y = tl_registered.y; y < br_registered.y; y++){
			//fill in left gap
			for (long x = 0; x < (tl_registered.x); x++){
				elements[i].registered_image			[y][x] = NS_MARGIN_BACKGROUND;
				elements[i].registered_region_threshold	[y][x] = NS_MARGIN_BACKGROUND;
				elements[i].registered_worm_threshold_	[y][x] = NS_MARGIN_BACKGROUND;
			}
			//fill in center
			for (long x = tl_registered.x; x < br_registered.x; x++){
				elements[i].registered_image		   [y][x] =		       elements[i].path_aligned_image			.sample(y-v0.y,x-v0.x);
				elements[i].registered_worm_threshold_  [y][x] =(ns_8_bit) (elements[i].path_aligned_worm_threshold	.sample(y-v0.y,x-v0.x)>.5)?1:0;
				elements[i].registered_region_threshold[y][x] = (ns_8_bit) (elements[i].path_aligned_region_threshold.sample(y-v0.y,x-v0.x)>.5)?1:0;
			}
			//fill in right gap
			for (long x = (br_registered.x); x < prop.width; x++){
				elements[i].registered_image[y][x] = NS_MARGIN_BACKGROUND;
				elements[i].registered_region_threshold[y][x] = NS_MARGIN_BACKGROUND;
				elements[i].registered_worm_threshold_[y][x] = NS_MARGIN_BACKGROUND;
			}
		}
		//fill in top
		for (long y = br_registered.y; y < prop.height; y++){
			for (long x = 0; x < prop.width; x++){
				elements[i].registered_image[y][x] = NS_MARGIN_BACKGROUND;
				elements[i].registered_worm_threshold_[y][x] = NS_MARGIN_BACKGROUND;
				elements[i].registered_region_threshold[y][x] = NS_MARGIN_BACKGROUND;
			}
		}
		//now we generate the movement image
		bool first_frames(i < movement_start_i);
		const ns_vector_2d v1(first_frames?ns_vector_2d(0,0):elements[i-dt].registration_offset);
		//fill in bottom
		for (long y = 0; y < tl.y+n; y++){
			for (long x = 0; x < prop.width; x++){
				elements[i].registered_movement_image_	[y][x] = NS_MARGIN_BACKGROUND;
			}
		}	
		for (long y = tl.y+n; y < br.y-n; y++){
			//fill in left gap
			for (long x = 0; x < (tl.x+n); x++)
				elements[i].registered_movement_image_	[y][x] = NS_MARGIN_BACKGROUND;
			
			//fill in center
			for (long x = tl.x+n; x < br.x-n; x++){
				
				#ifdef NS_DEBUG_IMAGE_ACCESS
				if (y >= elements[i].registered_image.properties().height ||
					x >= elements[i].registered_image.properties().width)
					throw ns_ex("Yikes");
				#endif

				double d_numerator(0),
						  d_denominator(0);
				//if we're at the beginning there is no previous frames to use, so we just assume all pixels are moving
				//and output the worm image as the movement image
				if (first_frames){
					for (long dy=-n; dy <= n; dy++){
						for (long dx=-n; dx <= n; dx++){
					//		const long grad(ns_sobel(im,x+dx,y+dy+vr0));
					//		d_numerator+=labs((long)im_1[y+dy+vr1][x+dx]-(long)im[y+dy+vr0][x+dx])*grad;
					//		d_denominator+=grad*grad;
							double d(elements[i].   path_aligned_image.sample(y-(v0.y) + dy,
												x-(v0.x) + dx));
							d*=elements[i].path_aligned_worm_threshold.sample(y-(v0.y) + dy,
												x-(v0.x) + dx);
						///OLD STYLE	d_numerator+=(d>0?d:0);
							d_numerator+=d;
						}
					}
				}
				else{
					for (long dy=-n; dy <= n; dy++){
						for (long dx=-n; dx <= n; dx++){
					//		const long grad(ns_sobel(im,x+dx,y+dy+vr0));
					//		d_numerator+=labs((long)im_1[y+dy+vr1][x+dx]-(long)im[y+dy+vr0][x+dx])*grad;
					//		d_denominator+=grad*grad;
							double d(elements[i].   path_aligned_image.sample(y-(v0.y) + dy,
												x-(v0.x) + dx) 
												-
									 elements[i-dt].path_aligned_image.sample(y-(v1.y) + dy,
												x-(v1.x) + dx));  //subtract vr0 from both because y is in global reference frame and for im_1 we've already added vr1 so the result is vr1-vr0 which gives us the desired offset.
						///OLD_STYLE	d_numerator+=(d>0?d:0);
							d_numerator+=d;
						}
					}
				}
				
				double val = d_numerator/=kernel_area;
				if (val < m_min)
					m_min = val;
				if (val > m_max)
					m_max = val;
				///OLD_STYLE	if (val > 255) val = 255;
				//note that the absolute value of val can never be greater than 255  
				//so val contains 9 bits of information

				elements[i].registered_movement_image_[y][x] = (short)val;

			}
			//fill in right gap
			for (long x = (br.x-n); x < prop.width; x++){
				elements[i].registered_movement_image_[y][x] = NS_MARGIN_BACKGROUND;
			}
		}
		//fill in top
		for (long y = br.y-n; y < prop.height; y++){
			for (long x = 0; x < prop.width; x++){
				elements[i].registered_movement_image_[y][x] = NS_MARGIN_BACKGROUND;
			}
		}
		ns_dilate<16,ns_image_bitmap,ns_image_bitmap>(elements[i].registered_worm_threshold_,elements[i].registered_worm_neighborhood_threshold);
	}

	
	//
	//for (unsigned int i = chunk.start_i; i < movement_start_i; i++){
	//	elements[start_i].registered_movement_image.pump(elements[i].registered_movement_image,1024);
		//elements[start_i].registered_image.pump(elements[i].registered_image,1024);
		//elements[start_i].registered_region_threshold.pump(elements[i].registered_region_threshold,1024);
		//elements[start_i].registered_worm_threshold.pump(elements[i].registered_worm_threshold,1024);
	//}
/*	for (unsigned int i = chunk.start_i; i < chunk.stop_i; i++){
		string filename = "y:\\debug\\im_";
		filename += ns_to_string(i);
		ns_save_image(filename + "path.tif",elements[i].path_aligned_image);
		ns_save_image(filename + "reg.tif",elements[i].registered_image);
		ns_save_image(filename + "mov.tif",elements[i].registered_movement_image);

	}*/
}
ns_analyzed_time_image_chunk ns_analyzed_image_time_path::initiate_image_registration(const ns_analyzed_time_image_chunk & chunk,ns_alignment_state & state){
	const unsigned long time_kernel(alignment_time_kernel_width);
	if (chunk.stop_i < time_kernel)
		throw ns_ex("ns_analyzed_image_time_path::initiate_image_registration()::First chunk must be >= time kernel width!");
	ns_analyzed_time_image_chunk remaining(chunk);
	remaining.start_i = time_kernel;

	ns_image_properties prop(elements[0].path_aligned_image.properties());
	set_path_alignment_image_dimensions(prop);

	state.consensus.init(prop);
	state.consensus_count.init(prop);

	//image is offset by maximum_alignment offset in each direction
	//but we the largest vertical alignment in either direction is actually half that,
	//because two consecutive frames can be off by -max and max, producing a overal differential of 2*max offset between the two images


	//if (max_alignment_offset.x < 0) max_alignment_offset.x = 0;
	//if  (max_alignment_offset.y < 0) max_alignment_offset.y = 0;

	const ns_vector_2i bottom_offset(maximum_alignment_offset());
	const ns_vector_2i top_offset(maximum_alignment_offset());

	ns_calc_best_alignment align(NS_SUBPIXEL_REGISTRATION_CORSE,NS_SUBPIXEL_REGISTRATION_FINE,maximum_alignment_offset(),maximum_local_alignment_offset(),bottom_offset,top_offset);


	//load first consensus kernal
	
	const ns_vector_2i d(maximum_alignment_offset());	
	const ns_vector_2i h_sub(ns_vector_2i(state.consensus.properties().width,
										  state.consensus.properties().height)
										  -d);
	for (unsigned long y = 0; y < prop.height; y++){
		for (unsigned long x = 0; x < prop.width; x++){
			state.consensus[y][x] = 0;
			state.consensus_count[y][x] = 0;
		}
	}
	for (long y = d.y; y < h_sub.y; y++){
			for (long x = d.x; x < h_sub.x; x++){
			state.consensus[y][x] = elements[0].path_aligned_image[y][x];
			state.consensus_count[y][x] = 1;
		}
	}
	state.registration_offset_sum = ns_vector_2i(0,0);
	state.registration_offset_count=1;

	#ifdef NS_OUTPUT_ALGINMENT_DEBUG
	ns_debug_image_out out;
	out("c:\\movement",debug_path_name + "0.tif",alignment_time_kernel_width,state.consensus,state.consensus_count,elements[0].path_aligned_image);
	#endif
	elements[0].registration_offset = ns_vector_2i(0,0);
	//ns_vector_2i test_alignment = align(state,elements[0].path_aligned_image);
	//cerr << "TAlignment: " << test_alignment << "\n";
	
	for (long i = 1; i < time_kernel; i++){
		if ( elements[i].path_aligned_image.properties().height == 0)
			throw ns_ex("ns_analyzed_image_time_path::calculate_vertical_registration()::Element ")  << i << " was not assigned!";
		
		elements[i].registration_offset = align(state,elements[i].path_aligned_image,elements[i].saturated_offset);
	//	cerr << "Alignment: " << elements[i].registration_offset << "\n";
		
		state.registration_offset_sum = state.registration_offset_sum + elements[i].registration_offset;
		state.registration_offset_count++;

	//	cerr << "O:" << elements[i].vertical_registration << "\n";
		//cerr << i << ":" << (unsigned long)consensus[10][21] << "<-" << (unsigned long)elements[i].path_aligned_image[10-maximum_alignment_offset()-elements[i].vertical_registration][21] << "\n";
		for (long y = d.y; y < h_sub.y; y++){
			for (long x = d.x; x < h_sub.x; x++){
				state.consensus[y][x] += elements[i].path_aligned_image.sample(y-elements[i].registration_offset.y,
																			   x-elements[i].registration_offset.x);
				state.consensus_count[y][x]++;
			}
		}
		#ifdef NS_OUTPUT_ALGINMENT_DEBUG
		out("c:\\movement",debug_path_name + ns_to_string(i) + ".tif",alignment_time_kernel_width,state.consensus,state.consensus_count,elements[i].path_aligned_image);
		#endif
		} 

	return remaining;
}

void ns_analyzed_image_time_path::calculate_image_registration(const ns_analyzed_time_image_chunk & chunk_,ns_alignment_state & state){
	ns_analyzed_time_image_chunk chunk(chunk_);
	//if the registration needs to be initialized, do so.
	if (chunk.start_i == 0)
		chunk = initiate_image_registration(chunk_,state);

	//make alignment object
		//image is offset by maximum_alignment offset in each direction
	//but we the largest vertical alignment in either direction is actually half that,
	//because two consecutive frames can be off by -max and max, producing a overal differential of 2*max offset between the two images

	ns_vector_2i max_alignment_offset(maximum_alignment_offset().x/2-movement_detection_kernal_half_width,
											maximum_alignment_offset().y/2-movement_detection_kernal_half_width);
	if (max_alignment_offset.x < 0) max_alignment_offset.x = 0;
	if (max_alignment_offset.y < 0) max_alignment_offset.y = 0;

	const ns_vector_2i bottom_offset(maximum_alignment_offset());
	const ns_vector_2i top_offset(maximum_alignment_offset());
	
	ns_calc_best_alignment align(NS_SUBPIXEL_REGISTRATION_CORSE,NS_SUBPIXEL_REGISTRATION_FINE,maximum_alignment_offset(),maximum_local_alignment_offset(),bottom_offset,top_offset);

	const unsigned long time_kernal(alignment_time_kernel_width);

	//define some constants
	ns_image_properties prop;
	set_path_alignment_image_dimensions(prop);
	ns_vector_2i d(maximum_alignment_offset());	
	const ns_vector_2i h_sub(ns_vector_2i(state.consensus.properties().width,
										  state.consensus.properties().height)
										  -d);

	for (long i = chunk.start_i; i < chunk.stop_i; i++){

		if (elements[i].excluded) continue;

		if (!elements[i-time_kernal].path_aligned_image_is_loaded()){
			throw ns_ex("Image for ") << i-time_kernal << " isn't loaded.\n";
		}
		elements[i].registration_offset = align(state,elements[i].path_aligned_image,elements[i].saturated_offset);
	//	cerr << "Alignment: " << elements[i].registration_offset << "\n";

		state.registration_offset_sum = state.registration_offset_sum + elements[i].registration_offset - elements[i-time_kernal].registration_offset;

		for (long y = d.y; y < h_sub.y; y++){
			for (long x = d.x; x < h_sub.x; x++){
				state.consensus		 [y][x]+= elements[i            ].path_aligned_image.sample(y-elements[i].registration_offset.y,x-elements[i].registration_offset.x);
				state.consensus_count[y][x]++;

				state.consensus		 [y][x]-= elements[i-time_kernal].path_aligned_image.sample(y-elements[i-time_kernal].registration_offset.y,x-elements[i-time_kernal].registration_offset.x);
				state.consensus_count[y][x]--;
			
			}
		}
		#ifdef NS_OUTPUT_ALGINMENT_DEBUG
		ns_debug_image_out out;
		out("c:\\movement\\",debug_path_name + ns_to_string(i) + ".tif",alignment_time_kernel_width,state.consensus,state.consensus_count,elements[i].path_aligned_image);
		#endif
	}
}

template<class T> 
struct ns_index_orderer{
	ns_index_orderer<T>(const unsigned long i,const T * d):index(i),data(d){}
	bool operator<(const ns_index_orderer<T> & r) const {return *data < *r.data;}
	unsigned long index;
	const T * data;
};

ns_analyzed_image_time_path_group::ns_analyzed_image_time_path_group(unsigned long group_id_, const unsigned long region_info_id,const ns_time_path_solution & solution_, ns_death_time_annotation_set & rejected_annotations){
	
	paths.reserve(solution_.path_groups[group_id_].path_ids.size());
	unsigned long current_path_id(0);
	for (unsigned int i = 0; i < solution_.path_groups[group_id_].path_ids.size(); i++){
		const unsigned long & path_id(solution_.path_groups[group_id_].path_ids[i]);
		const ns_time_path & source_path(solution_.paths[path_id]);
		paths.resize(current_path_id+1);
		ns_analyzed_image_time_path &path(paths[current_path_id]);

		path.path = &source_path;
		path.path_id = path_id;
		path.group_id = group_id_;
		path.solution = &solution_;
		path.region_info_id = region_info_id;
		
		if (source_path.stationary_elements.size() == 0)
			throw ns_ex("ns_analyzed_image_time_path_group::ns_analyzed_image_time_path_group()::Empty timepath found!");
		
		vector<ns_index_orderer<unsigned long> > ordered_time;
		ordered_time.reserve(source_path.stationary_elements.size());
		for (unsigned int j = 0; j < source_path.stationary_elements.size(); j++)
			ordered_time.push_back(ns_index_orderer<unsigned long>(j,&solution_.time(source_path.stationary_elements[j])));
		std::sort(ordered_time.begin(),ordered_time.end());
		
		//set the time of the first measurement after the path ends.
		//this is used to annotate the time at which the path disappears
		const unsigned long last_time_index(source_path.stationary_elements[ordered_time.rbegin()->index].t_id);
		if (last_time_index+1 >= solution_.timepoints.size())
			path.time_of_first_measurement_after_path_end = 0;
		else path.time_of_first_measurement_after_path_end = solution_.timepoints[last_time_index+1].time;

			
		path.elements.reserve(source_path.stationary_elements.size());
		for (unsigned int j = 0; j < source_path.stationary_elements.size(); j++){
			
			const unsigned long s = path.elements.size();
			const unsigned long absolute_time(solution_.time(source_path.stationary_elements[ordered_time[j].index]));
			if (s > 0 && path.elements[s-1].absolute_time == absolute_time){
				if (path.elements[s-1].excluded) continue;
				//add an annotation that there is an extra worm at the specified position
				std::string expl("PD");
				rejected_annotations.events.push_back(
					 ns_death_time_annotation(ns_movement_censored_worm_observed,
					 0,region_info_id,
					 ns_death_time_annotation_time(solution_.time(source_path.stationary_elements[ordered_time[j].index]),solution_.time(source_path.stationary_elements[ordered_time[j].index])),
					 solution_.element(source_path.stationary_elements[ordered_time[j].index]).region_position,
					 solution_.element(source_path.stationary_elements[ordered_time[j].index]).region_size,
					 ns_death_time_annotation::ns_machine_excluded,
					 1,ns_current_time(),
					 ns_death_time_annotation::ns_lifespan_machine,
					 solution_.element(source_path.stationary_elements[ordered_time[j].index]).part_of_a_multiple_worm_disambiguation_cluster?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
					 ns_stationary_path_id(),false,
					 expl)
				);
				path.elements[s-1].number_of_extra_worms_observed_at_position++;
				continue; //skip frames taken at duplicate times
			}

			path.elements.resize(s+1);
			path.elements[s].absolute_time = absolute_time;
			path.elements[s].relative_time = path.elements[s].absolute_time - path.elements[0].absolute_time;
			path.elements[s].context_position_in_region_vis_image = solution_.element(source_path.stationary_elements[ordered_time[j].index]).context_image_position_in_region_vis_image;
	
			path.elements[s].worm_region_size_ = solution_.element(source_path.stationary_elements[ordered_time[j].index]).region_size;
			path.elements[s].worm_context_size_ = solution_.element(source_path.stationary_elements[ordered_time[j].index]).context_image_size;

			path.elements[s].part_of_a_multiple_worm_disambiguation_group = solution_.element(source_path.stationary_elements[ordered_time[j].index]).part_of_a_multiple_worm_disambiguation_cluster;
			
			//we inherited a path_position_offset offset due to the extra margin
			//of context pixels included in the region_visualization image.
			//thus, the absolute position of all our pixels are actually offset
			path.elements[s].region_position_in_source_image = 
				solution_.element(source_path.stationary_elements[ordered_time[j].index]).region_position;
			path.elements[s].context_position_in_source_image = 
				solution_.element(source_path.stationary_elements[ordered_time[j].index]).context_image_position;
		  
			//we'll subtract out the path location later 
		//	path.elements[s].offset_from_path =  path.elements[s].context_position_in_source_image;
		}
		//if this path was shrunk down below the minimum size for analysis, remove it.
		const unsigned long current_time(ns_current_time());
		if (path.elements.size() < ns_analyzed_image_time_path::alignment_time_kernel_width){
			for (unsigned int j = 0; j < path.elements.size(); j++){
				
				if (path.elements[j].excluded) continue;
				 rejected_annotations.events.push_back(
					 ns_death_time_annotation(ns_fast_moving_worm_observed,
					 0,region_info_id,
					 ns_death_time_annotation_time(path.elements[j].absolute_time,path.elements[j].absolute_time),
					 path.elements[j].region_offset_in_source_image(),
					 path.elements[j].worm_region_size(),
					 ns_death_time_annotation::ns_not_excluded,
					 0,current_time,ns_death_time_annotation::ns_lifespan_machine,
					 path.elements[j].part_of_a_multiple_worm_disambiguation_group?ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster:ns_death_time_annotation::ns_single_worm,
					 ns_stationary_path_id(),false,
					 "PTS")
					 );
			}
			path.elements.resize(0);
			paths.pop_back();
			continue;
		}
		
		//first we calculate the path bounding box in absolute coordinates
		ns_vector_2i tl(path.elements[0].context_position_in_source_image),
					 br(path.elements[0].context_position_in_source_image+path.elements[0].worm_context_size_);
		
		for (unsigned int j = 1; j < path.elements.size(); j++){
			const ns_analyzed_image_time_path_element & e(path.elements[j]);
			const ns_vector_2i & pos(e.context_position_in_source_image);
			const ns_vector_2i & size(e.worm_context_size_);

			if (pos.x < tl.x)
				tl.x = pos.x;
			if (pos.y < tl.y)
				tl.y = pos.y;
			if (pos.x + size.x > br.x)
				br.x = pos.x + size.x;
			if (pos.y + size.y > br.y)
				br.y = pos.y + size.y; 
		}
		//the absolute coordinates of the path
		path.path_context_position = tl;
		path.path_context_size = br - tl;

		//we want to map from region positions to context positions
		path.path_region_position = tl + solution_.element(source_path.stationary_elements[ordered_time[0].index]).region_position  
													 - solution_.element(source_path.stationary_elements[ordered_time[0].index]).context_image_position;
		path.path_region_size = path.path_context_size + solution_.element(source_path.stationary_elements[ordered_time[0].index]).region_size
												 - solution_.element(source_path.stationary_elements[ordered_time[0].index]).context_image_size;

	//	path.worm_size = path.region_size;

		for(unsigned int j = 0; j < path.elements.size(); j++)
			path.elements[j].offset_from_path = path.elements[j].context_position_in_source_image - path.path_context_position;

		current_path_id++;
	}
}

void ns_movement_image_collage_info::from_path(const ns_analyzed_image_time_path * p, const unsigned long only_output_first_n_lines){
	const unsigned long max_width(3000);

	if (p->element_count() == 0){
		frame_dimensions = ns_vector_2i(0,0);
		grid_dimensions = ns_vector_2i(0,0);
		prop.width = 0;
		prop.height = 0;
		prop.components = 0;
		prop.resolution = 0;
		return;
	}
	ns_image_properties pp;
	p->set_path_alignment_image_dimensions(pp);
	frame_dimensions.x = pp.width;
	frame_dimensions.y = pp.height;
	//frame_dimensions = p->path_context_size;
	if (frame_dimensions.x > max_width)
		throw ns_ex("ns_movement_image_collage_info()::Frame too large!");

	//int frames_per_row(max_width/frame_dimensions.x);
	int frames_per_row = 1;
	//we could get a lot nicer images by having multiple frames per row.
	//however, this would mean we'd not be able to output frames one at a time, which would complicate things.

	//if (frame_dimensions.x*p.element_count() < max_width)
	//	frames_per_row = p.element_count();
	unsigned long frame_count(only_output_first_n_lines);
	if (frame_count == 0)
		frame_count= p->element_count();
	grid_dimensions = ns_vector_2i(frames_per_row,frame_count/frames_per_row  + (unsigned long)((frame_count % frames_per_row)>0));

	prop = p->registered_image_properties;

	prop.width = grid_dimensions.x*frame_dimensions.x;
	prop.height = grid_dimensions.y*frame_dimensions.y;
	//if (prop.height > 1500000)
	//	throw ns_ex("ns_movement_image_collage_info::Movement collage would require an enormous image:") << prop.width << "x" << prop.height;
	prop.components = 3;
//	prop.description = xml.result();
//		cerr << p.element_count() << ": " << frames_per_row << " " << grid_dimensions << " " << frame_dimensions << " " <<
//			prop.width << "x" << prop.height << "\n";
}


void ns_analyzed_image_time_path::save_movement_images(const ns_analyzed_time_image_chunk & chunk,ns_sql & sql){
	//handle small or non-existant images
	ns_movement_image_collage_info d(this
		/*,chunk.stop_i-chunk.start_i*/);
	if(d.prop.width == 0 || d.prop.height == 0){
		if (chunk.start_i > 0)
			return;
		ns_image_properties p(d.prop);
		p.height = 1;
		p.width = 1;
		if (p.components == 0)
			p.components = 3;
		ns_image_standard im;
		im.init(p);
		for (unsigned int c = 0; c < p.components; c++)
			im[0][c] = 0;	
		bool had_to_use_volatile_storage;
		output_reciever = new ns_image_storage_reciever_handle<ns_8_bit>(image_server.image_storage.request_storage(output_image,ns_tiff,1024,&sql,had_to_use_volatile_storage,false,false));	
		im.pump(output_reciever->output_stream(),1024);
		return;
	}

	if (chunk.start_i == 0){
		bool had_to_use_volatile_storage;
		output_reciever = new ns_image_storage_reciever_handle<ns_8_bit>(image_server.image_storage.request_storage(output_image,ns_tiff,1024,&sql,had_to_use_volatile_storage,false,false));
				
		output_reciever->output_stream().init(d.prop);
	}
	save_movement_images(chunk,*output_reciever);
	for (unsigned int i = chunk.start_i; i < chunk.stop_i; i++){
		elements[i].registered_image.clear();
		elements[i].registered_movement_image_.clear();
		elements[i].registered_region_threshold.clear();
		elements[i].registered_worm_threshold_.clear();
		elements[i].registered_worm_neighborhood_threshold.clear();
	}

	if (
	///**/	true || 
		chunk.stop_i == elements.size()){
		output_reciever->output_stream().finish_recieving_image();
		delete output_reciever;
		output_reciever = 0;
	//**/	exit(0);
	}
}
void ns_analyzed_image_time_path::save_movement_images(const ns_analyzed_time_image_chunk & chunk,ns_image_storage_reciever_handle<ns_8_bit> & out){
	
	if (elements.size() == 0) return;

	ns_movement_image_collage_info d(this);
	//this is the range within the entire path image that we are currently writing out
	unsigned long start_y = d.frame_dimensions.y*(chunk.start_i/d.grid_dimensions.x);
	unsigned long stop_y = d.frame_dimensions.y*((chunk.stop_i-1)/d.grid_dimensions.x + 1);

	//this is the size of the buffer we need to allocate to store the current chunk of the entire path image
	ns_image_stream_buffer_properties p;
	p.height = stop_y - start_y;

	const unsigned long h(p.height);
	p.width = d.prop.width*d.prop.components;
	ns_image_stream_static_buffer<ns_8_bit> buffer(p);

	//we output the range of the entire path image in h sized chunks
	for (unsigned long y = start_y; y < stop_y; y+=h){
		
		unsigned long dh(h);	
		if(h + y > d.prop.height) dh = d.prop.height-y;
		for (unsigned long dy = 0; dy < dh; dy++){
			//cy is the current line of the output buffer we are writing
			const unsigned long cy(y+dy);
			//i_offset is the index of the first path element we are going to write on this line of the output_buffer
			const unsigned long i_offset = d.grid_dimensions.x*(cy/d.frame_dimensions.y);
			//y_im_offset is the y within the current path element that we want to write.
			const unsigned long y_im_offset = cy%d.frame_dimensions.y;

			for (unsigned long i = 0; i < d.grid_dimensions.x; i++){
				//l_x is the position on the current line that we want to write the path element i+i_offset
				const unsigned long l_x(i*d.frame_dimensions.x);
				//r_x is one beyond the position on the current line that we want to write the path element i+i_offset
				const unsigned long r_x((i+1)*d.frame_dimensions.x);
				//if we've outputted all the elements; fill in the rest black.
				if (i_offset+i >= elements.size()){
					for (unsigned int x = 3*l_x; x < 3*r_x; x++)	
						buffer[dy][x] =  0;
	
				}
				else{

					const ns_analyzed_image_time_path_element &e(elements[i+i_offset]);	
					for (unsigned int x = l_x; x < r_x; x++){
						buffer[dy][3*x] =  abs(e.registered_movement_image_[y_im_offset][x-l_x]);  //unsigned value of movement difference.
						buffer[dy][3*x+1] =  e.registered_image[y_im_offset][x-l_x];
						buffer[dy][3*x+2] =   (((ns_8_bit)((e.registered_movement_image_[y_im_offset][x-l_x]<0)?1:0))) | //sign of movement difference
											 (((ns_8_bit)((e.registered_worm_neighborhood_threshold[y_im_offset][x-l_x]>0)?1:0))<<3) |
											 (((ns_8_bit)((e.registered_worm_threshold_[y_im_offset][x-l_x]>0)?1:0))<<4) | 
											 (((ns_8_bit)((e.registered_region_threshold[y_im_offset][x-l_x]>0)?1:0))<<5);
											;		
					}
				}
			}
		}
	//	cerr << y << "->" << dh << "\n";
		out.output_stream().recieve_lines(buffer,dh);
	}
		
}


void ns_analyzed_image_time_path::initialize_movement_image_loading(ns_image_storage_source_handle<ns_8_bit> & in){
	if (elements.size() == 0) return;
	movement_loading_collage_info.from_path(this);


	if (in.input_stream().properties().width != movement_loading_collage_info.prop.width ||
		in.input_stream().properties().height != movement_loading_collage_info.prop.height ||
		in.input_stream().properties().components != movement_loading_collage_info.prop.components){
			throw ns_ex("ns_analyzed_image_time_path::load_movement_images_from_file()::Unexpected collage size: ")
				<< in.input_stream().properties().width << "x" << in.input_stream().properties().height << ":" << (long)in.input_stream().properties().components << "," << (long)in.input_stream().properties().resolution << " vs "
				<< movement_loading_collage_info.prop.width << "x" << movement_loading_collage_info.prop.height << ":" << movement_loading_collage_info.prop.components << "," << movement_loading_collage_info.prop.resolution << "\n";
	}
	
	ns_image_stream_buffer_properties p;
	p.height = 2048;
	if (p.height > movement_loading_collage_info.prop.height)
		p.height = movement_loading_collage_info.prop.height;
	p.width = movement_loading_collage_info.prop.width*movement_loading_collage_info.prop.components;
	movement_loading_buffer.resize(p);

}
void ns_analyzed_image_time_path::end_movement_image_loading(ns_image_storage_source_handle<ns_8_bit> & in){
		movement_loading_buffer.resize(ns_image_stream_buffer_properties(0,0));
}

void ns_analyzed_image_time_path::load_movement_images(const ns_analyzed_time_image_chunk & chunk,ns_image_storage_source_handle<ns_8_bit> & in){
	
	ns_image_stream_buffer_properties p(movement_loading_buffer.properties());
	const unsigned long h(p.height);

	for (unsigned int i = chunk.start_i; i < chunk.stop_i; i++){
		ns_image_properties pr(in.input_stream().properties());
		set_path_alignment_image_dimensions(pr);
		elements[i].registered_movement_image_.init(pr);
		elements[i].registered_image.init(pr);
		elements[i].registered_worm_threshold_.init(pr);
		elements[i].registered_worm_neighborhood_threshold.init(pr);
		elements[i].registered_region_threshold.init(pr);
	}

	unsigned long start_y(movement_loading_collage_info.frame_dimensions.y*(chunk.start_i/movement_loading_collage_info.grid_dimensions.x));
	
	unsigned long stop_y(movement_loading_collage_info.frame_dimensions.y*(chunk.stop_i/movement_loading_collage_info.grid_dimensions.x));

	for (unsigned long y = start_y; y < stop_y; y+=h){
		
		unsigned long dh(h);	
		if(h + y > stop_y) dh = stop_y-y;
		in.input_stream().send_lines(movement_loading_buffer,dh);

		for (unsigned long dy = 0; dy < dh; dy++){
			const unsigned long cy(y+dy);
			const unsigned long i_offset = movement_loading_collage_info.grid_dimensions.x*(cy/movement_loading_collage_info.frame_dimensions.y);
			const unsigned long y_im_offset = cy%movement_loading_collage_info.frame_dimensions.y;
			for (unsigned long i = 0; i < movement_loading_collage_info.grid_dimensions.x; i++){
				const unsigned long l_x(i*movement_loading_collage_info.frame_dimensions.x);
				const unsigned long r_x((i+1)*movement_loading_collage_info.frame_dimensions.x);
				//if we've outputted all the elements; fill in the rest black.
				if (i_offset+i >= chunk.stop_i)
					throw ns_ex("YIKES!");

				ns_analyzed_image_time_path_element &e(elements[i+i_offset]);	
	//			cerr << "" << i + i_offset << ",";
			
				for (unsigned int x = l_x; x < r_x; x++){
					//unsigned value is stored in channel 0.  the sign of the value is stored in the first bit of channel 3
					 e.registered_movement_image_[y_im_offset][x-l_x] = movement_loading_buffer[dy][3*x] * (((movement_loading_buffer[dy][3*x+2])&1)?-1:1);
					 e.registered_image[y_im_offset][x-l_x] = movement_loading_buffer[dy][3*x+1];
					 e.registered_worm_neighborhood_threshold[y_im_offset][x-l_x] =   ((movement_loading_buffer[dy][3*x+2])&(((ns_8_bit)1)<<3))>0;
					 e.registered_worm_threshold_[y_im_offset][x-l_x] =   ((movement_loading_buffer[dy][3*x+2])&(((ns_8_bit)1)<<4))>0;
					 e.registered_region_threshold[y_im_offset][x-l_x] = ((movement_loading_buffer[dy][3*x+2])&(((ns_8_bit)1)<<5))>0;
				}
			}
		}
	//	cerr << "(" << y << "->" << dh << ")\n";
	}
}

void ns_time_path_image_movement_analyzer::load_movement_image_db_info(const unsigned long region_id,ns_sql & sql){
	if (image_db_info_loaded)
		return;
	sql << "SELECT group_id,path_id,image_id, id FROM path_data WHERE region_id = " << region_id;
	ns_sql_result res;
	sql.get_rows(res);
	for (unsigned int i = 0; i < res.size(); i++){
		unsigned long group_id(atol(res[i][0].c_str())),
					  path_id(atol(res[i][1].c_str())),
					  image_id(atol(res[i][2].c_str())),
					  db_id(atol(res[i][3].c_str()));

		if (group_id >= groups.size() || path_id >= groups[group_id].paths.size()){
			sql << "DELETE from path_data WHERE id = " << db_id;
			sql.send_query();
		}
		else{
			groups[group_id].paths[path_id].output_image.id = image_id;
			groups[group_id].paths[path_id].path_db_id = db_id;
		}
		
	}
	image_db_info_loaded = true;
	
}

void ns_time_path_image_movement_analyzer::load_images_for_group(const unsigned long group_id, unsigned long number_of_images_to_load,ns_sql & sql, const bool load_images_after_last_valid_sample){
	if (groups[group_id].paths.size() == 0)
		return;
	const unsigned long number_of_images_loaded(groups[group_id].paths[0].number_of_images_loaded);
	if (number_of_images_loaded == 0){
		(region_info_id,sql);
		if (group_id >= size())
			throw ns_ex("ns_time_path_image_movement_analyzer::load_images_for_group()::Invalid group: ") << group_id;
	}
	if (number_of_images_loaded >= number_of_images_to_load)
		return;

	const unsigned long chunk_size(10);

	for (unsigned int j = 0; j < groups[group_id].paths.size(); j++){
		unsigned long number_of_valid_elements(0);
		if (load_images_after_last_valid_sample)
			number_of_valid_elements = groups[group_id].paths[j].elements.size();
		else{
			for (int k = (int)groups[group_id].paths[j].elements.size()-1; k >= number_of_images_loaded; k--){
				if (!groups[group_id].paths[j].elements[k].excluded){
					number_of_valid_elements = k+1;
					break;
				}
			}
		}
		
		if (number_of_images_loaded == 0){
			groups[group_id].paths[j].output_image.load_from_db(groups[group_id].paths[j].output_image.id,&sql);
			groups[group_id].paths[j].movement_image_storage = image_server.image_storage.request_from_storage(groups[group_id].paths[j].output_image,&sql);
			groups[group_id].paths[j].initialize_movement_image_loading(groups[group_id].paths[j].movement_image_storage);
		}

		
		if (number_of_images_to_load > number_of_valid_elements)
			number_of_images_to_load = number_of_valid_elements;
			//throw ns_ex("ns_time_path_image_movement_analyzer::load_images_for_group()::Requesting to many images!");
		if (number_of_images_to_load == 0)
			return;

		unsigned long number_of_new_images_to_load(number_of_images_to_load-number_of_images_loaded);
			
		//load in chunk by chunk
		for (unsigned int k = 0; k < number_of_new_images_to_load; k+=chunk_size){
			ns_analyzed_time_image_chunk chunk(k,k+chunk_size);
			if (chunk.stop_i >= number_of_new_images_to_load)
				chunk.stop_i = number_of_new_images_to_load;
			chunk.start_i+=number_of_images_loaded;
			chunk.stop_i+=number_of_images_loaded;

					
			groups[group_id].paths[j].load_movement_images(chunk,groups[group_id].paths[j].movement_image_storage);
//				groups[i].paths[j].save_movement_images(chunk,dbg_im);
		//	groups[i].paths[j].quantify_movement(chunk);
		//	for (long l = chunk.start_i; l < (long)chunk.stop_i; l++)
		//		groups[i].paths[j].elements[l].clear_movement_images();
		}
		if (number_of_images_to_load == number_of_valid_elements){
			groups[group_id].paths[j].end_movement_image_loading(groups[group_id].paths[j].movement_image_storage);
			groups[group_id].paths[j].movement_image_storage.clear();
		}
		groups[group_id].paths[j].number_of_images_loaded = number_of_images_to_load;
		//groups[i].paths[j].analyze_movement(persistance_time,ns_stationary_path_id(i,j,analysis_id));
			
	//	debug_name += ".csv";
	//	ofstream tmp(debug_name.c_str());
	//	groups[i].paths[j].output_image_movement_summary(tmp);
	}
}

void ns_time_path_image_movement_analyzer::clear_images_for_group(const unsigned long group_id){
	if (groups.size() <= group_id)
		return;
	for (unsigned int j = 0; j < groups[group_id].paths.size(); j++){
		for (unsigned int k = 0; k < groups[group_id].paths[j].elements.size(); k++){
			groups[group_id].paths[j].elements[k].clear_movement_images();
		}
		groups[group_id].paths[j].number_of_images_loaded = 0;
	}
}


void ns_time_path_image_movement_analyzer::calculate_from_movement_images(const unsigned long region_id,const ns_time_path_solution & solution_,ns_sql & sql,const bool load_images_after_last_valid_sample){
	const unsigned long chunk_size(10);
	analysis_id = ns_current_time();
	try{
		load_from_solution(solution_);
		crop_paths_to_final_time(region_id,sql);
		region_info_id = region_id;
		load_movement_image_db_info(region_id,sql);

		for (unsigned int i = 0; i < groups.size(); i++)
			for (unsigned int j = 0; j < groups[i].paths.size(); j++)
				if (groups[i].paths[j].output_image.id == 0)
					throw ns_ex("Could not find movement image in db for region ") << region_id << " group " << i << " path " << j;

		//we need to load in the movement quantification file because it holds the registration offsets used to generate
		//the registered movement images, and these values need to be written to the new movement quantification file.
		populate_movement_quantification_from_file(sql);

		const unsigned long persistance_time(stationary_cutoff_duration());
		for (unsigned int i = 0; i < groups.size(); i++){
			cout << (100*i)/groups.size() << "%...";
			for (unsigned int j = 0; j < groups[i].paths.size(); j++){
				groups[i].paths[j].output_image.load_from_db(groups[i].paths[j].output_image.id,&sql);
				ns_image_storage_source_handle<ns_8_bit> storage(image_server.image_storage.request_from_storage(groups[i].paths[j].output_image,&sql));
				groups[i].paths[j].initialize_movement_image_loading(storage);


				unsigned long number_of_valid_elements(0);
				if (load_images_after_last_valid_sample)
					number_of_valid_elements = groups[i].paths[j].elements.size();
				else{
					for (int k = (int)groups[i].paths[j].elements.size()-1; k >= 0; k--){
						if (!groups[i].paths[j].elements[k].excluded){
							number_of_valid_elements = k+1;
							break;
						}
					}
				}


				//load in chunk by chunk
				for (unsigned int k = 0; k < number_of_valid_elements; k+=chunk_size){
					ns_analyzed_time_image_chunk chunk(k,k+chunk_size);
					if (chunk.stop_i >= number_of_valid_elements)
						chunk.stop_i = number_of_valid_elements;
					
					groups[i].paths[j].load_movement_images(chunk,storage);
	//				groups[i].paths[j].save_movement_images(chunk,dbg_im);
					groups[i].paths[j].quantify_movement(chunk);
					for (long l = chunk.start_i; l < (long)chunk.stop_i; l++)
						groups[i].paths[j].elements[l].clear_movement_images();
				}
				groups[i].paths[j].end_movement_image_loading(storage);
				groups[i].paths[j].analyze_movement(persistance_time,ns_stationary_path_id(i,j,analysis_id));
				
				groups[i].paths[j].calculate_movement_quantification_summary();
			
			//	debug_name += ".csv";
			//	ofstream tmp(debug_name.c_str());
			//	groups[i].paths[j].output_image_movement_summary(tmp);
			}
		}
		cout << "\n";
		generate_movement_description_series();
		movement_analyzed = true;
	}
	catch(...){
		delete_from_db(region_id,sql);
		throw;
	}
}
void ns_time_path_image_movement_analyzer::mark_path_images_as_cached_in_db(const unsigned long region_id, ns_sql & sql){
	sql << "UPDATE sample_region_image_info SET path_movement_images_are_cached = 1 WHERE id = " << region_id;
	sql.send_query();
}
void ns_time_path_image_movement_analyzer::acquire_region_image_specifications(const unsigned long region_id,ns_sql & sql){
	const string col(ns_processing_step_db_column_name(ns_process_region_vis));
	sql << "SELECT " << col << ",capture_time, worm_detection_results_id FROM sample_region_images WHERE region_info_id = " << region_id << " AND " << col << "!= 0 ORDER BY capture_time ASC";
	ns_sql_result res;
	sql.get_rows(res);
	region_image_specifications.resize(res.size());
	for (unsigned long i = 0; i < res.size(); i++){
		//load image
		region_image_specifications[i].time = atol(res[i][1].c_str());
		region_image_specifications[i].region_image.load_from_db(atol(res[i][0].c_str()),&sql);
	}
}

void ns_time_path_image_movement_analyzer::generate_movement_description_series(){
	//group sizes and position
	description_series.group_region_sizes.resize(groups.size(),ns_vector_2i(0,0));
	description_series.group_region_position_in_source_image.resize(groups.size(),ns_vector_2i(0,0));
	description_series.group_context_sizes.resize(groups.size(),ns_vector_2i(0,0));
	description_series.group_context_position_in_source_image.resize(groups.size(),ns_vector_2i(0,0));
	for (unsigned int i = 0; i < groups.size(); i++){
		if (groups[i].paths.size()==0)
			continue;
		description_series.group_region_sizes[i] = groups[i].paths[0].path_region_size;
		description_series.group_region_position_in_source_image[i] = groups[i].paths[0].path_region_position;
		description_series.group_context_sizes[i] = groups[i].paths[0].path_context_size;
		description_series.group_context_position_in_source_image[i] = groups[i].paths[0].path_context_position;
	}


	//populate timepoints from solution
	description_series.timepoints.resize(solution->timepoints.size());
	for (unsigned int i = 0; i < solution->timepoints.size(); i++){
		description_series.timepoints[i].time = solution->timepoints[i].time;
		description_series.timepoints[i].worms.reserve(10);
	}
	//add fast moving worms
	for (unsigned int i = 0; i < solution->unassigned_points.stationary_elements.size(); i++){
		description_series.timepoints[solution->unassigned_points.stationary_elements[i].t_id].worms.push_back(
			ns_worm_movement_measurement_description(
				0,
				ns_movement_fast,
				solution->element(solution->unassigned_points.stationary_elements[i]).region_position,
				solution->element(solution->unassigned_points.stationary_elements[i]).region_size,
				-1
				));
	}
	//we go through all paths, assigning path elements to the currect time point in one pass.
	//We keep track of where we are in each path by including the current
	//element id in group_path_current_element_id[].

	for (unsigned int t = 0; t < description_series.timepoints.size(); t++){
		for (unsigned int i = 0; i < groups.size(); i++){
			for (unsigned int j = 0; j < groups[i].paths.size(); j++){
				//see if this path is defined at the provided time point
				const ns_movement_state s(groups[i].paths[j].movement_state(description_series.timepoints[t].time));
				if (s == ns_movement_not_calculated) continue;

				//find the position of the worm at time tt.
				long tt;
				for (tt = 0; tt < (long)groups[i].paths[j].elements.size()-1; tt++){
					if (groups[i].paths[j].elements[tt+1].absolute_time > description_series.timepoints[t].time)
						break;
				}
				
				description_series.timepoints[t].worms.push_back(
					ns_worm_movement_measurement_description(
					0,
					s,
					groups[i].paths[j].elements[tt].region_offset_in_source_image(),
					groups[i].paths[j].elements[tt].worm_region_size(),
					i
					));
			}
		}
	}
}


ns_analyzed_image_time_path_event_index ns_analyzed_image_time_path::find_event_index(const ns_movement_event & event_to_align){
	if (event_indices[(int)event_to_align]==-1)
		return ns_analyzed_image_time_path_event_index( ns_no_movement_event,-1);
	return ns_analyzed_image_time_path_event_index(event_to_align,event_indices[(int)event_to_align]);
}

ns_analyzed_image_time_path_event_index ns_analyzed_image_time_path::find_event_index_with_fallback(const ns_movement_event & event_to_align){
	ns_analyzed_image_time_path_event_index ret(find_event_index(event_to_align));
	//if we've found a result, or can't fallback, return the result
	if (event_to_align ==  ns_fast_movement_cessation || ret.event_type != ns_no_movement_event) return ret;

	//if we don't have the result, fall back one step
	if (event_to_align == ns_translation_cessation)
		return find_event_index(ns_fast_movement_cessation);
	return find_event_index_with_fallback(ns_translation_cessation);
};


void ns_time_path_image_movement_analyzer::generate_death_aligned_movement_posture_visualizations(const bool include_motion_graphs,const unsigned long region_id,const ns_movement_event & event_to_align,const ns_time_path_solution & solution,ns_sql & sql){
	
	unsigned long sample_id(0),experiment_id(0);
	string region_name,sample_name,experiment_name;

	ns_region_info_lookup::get_region_info(region_id,&sql,region_name,sample_name,sample_id,experiment_name,experiment_id);
	
	const long thickness(2);

	ns_marker_manager marker_manager;
	
	const ns_vector_2i graph_dimensions(include_motion_graphs?ns_vector_2i(300,200):ns_vector_2i(0,0));
	ns_worm_movement_description_series series = description_series;	

	series.calculate_visualization_grid(graph_dimensions);
	if (series.group_positions_on_visualization_grid.size() != groups.size() ||
		series.group_should_be_displayed.size() != groups.size() ||
		series.group_region_sizes.size() != groups.size())
		throw ns_ex("calculate_visualization_grid() returned an inconsistant result");

	//find time for which each animal needs to be aligned
	vector<ns_analyzed_image_time_path_event_index> path_aligned_event_index(groups.size());
	
	unsigned long alignment_position(0);
	unsigned long aligned_size(0);

	for (unsigned int i = 0; i < groups.size(); i++){
		if (!series.group_should_be_displayed[i])
			path_aligned_event_index[i] = ns_analyzed_image_time_path_event_index(ns_no_movement_event,-1);
		else{
			if (groups[i].paths[0].elements.size() == 0)
				throw ns_ex("ns_time_path_image_movement_analyzer::generate_death_aligned_movement_posture_visualizations()::"
							"Empty path found!");

			path_aligned_event_index[i] = groups[i].paths[0].find_event_index_with_fallback(event_to_align);
			
			//if worms never slow down, align the path to it's final point.
			if (path_aligned_event_index[i].event_type == ns_no_movement_event){
				path_aligned_event_index[i].index = groups[i].paths[0].elements.size()-1;
				path_aligned_event_index[i].event_type = ns_fast_moving_worm_observed;
			}

			if (path_aligned_event_index[i].index > alignment_position)
				alignment_position = path_aligned_event_index[i].index;
		}
	
	}
	//find the last time point in the aligned image series
	for (unsigned int i = 0; i < groups.size(); i++){
		long lp(groups[i].paths[0].elements.size()+alignment_position - path_aligned_event_index[i].index);
		if (lp > aligned_size)
			aligned_size = lp;
	}
	//we now have aligned the different groups.
	//all animals die at index alignment_position
	//and there are latest_aligned_index frames in the video.
	
	vector<ns_image_storage_source_handle<ns_8_bit> > path_image_source;
	vector<ns_graph> path_movement_graphs(groups.size());
	path_image_source.reserve(groups.size());

	ns_image_standard output_image;
	ns_image_properties prop;
	prop.components = 3;
	prop.width = series.visualization_grid_dimensions.x;
	prop.height = series.visualization_grid_dimensions.y;
	output_image.init(prop);

	
	ns_image_properties graph_prop(prop);
	ns_image_standard graph_temp;
	if (include_motion_graphs){
		graph_prop.width = series.metadata_dimensions.x;
		graph_prop.height = series.metadata_dimensions.y;
		graph_temp.init(graph_prop);
	}
	else
		graph_prop.width = graph_prop.height = 0;

	//initialize path movement image source for first frame
	for (unsigned int i = 0; i < groups.size(); i++){
		if (!series.group_should_be_displayed[i]){
			path_image_source.push_back(ns_image_storage_source_handle<ns_8_bit>(0)); //we want the index of groups[i] and path_image_source[i] to match so we fill unwanted groups with a dummy entry.
			continue;
		}
		groups[i].paths[0].output_image.load_from_db(groups[i].paths[0].output_image.id,&sql);
		path_image_source.push_back(image_server.image_storage.request_from_storage(groups[i].paths[0].output_image,&sql));
		groups[i].paths[0].initialize_movement_image_loading(path_image_source[i]);
	}

	//make movement graphs
	if (include_motion_graphs){
		for (unsigned int i = 0; i < groups.size(); i++){
			if (!series.group_should_be_displayed[i]) continue;
			ns_make_path_movement_graph(groups[i].paths[0],path_movement_graphs[i]);
			path_movement_graphs[i].draw(graph_temp);
		}
	}

	//load first frame of all paths
	/*for (unsigned int g = 0; g < groups.size(); g++){
		if (!series.group_should_be_displayed[g]) continue;
		groups[g].paths[0].load_movement_images(ns_analyzed_time_image_chunk(0,1),path_image_source[g]);
	}*/

	//now go through each measurement time for the solution
	for (unsigned long t = 0; t < aligned_size; t++){
		cerr << (100*t)/aligned_size << "%...";

		ns_movement_posture_visualization_summary vis_summary;
		vis_summary.region_id = region_id;
		vis_summary.frame_number = t;
		vis_summary.alignment_frame_number = alignment_position;

		//init output image
		for (unsigned long y = 0; y < prop.height; y++)
			for (unsigned long x = 0; x < 3*prop.width; x++)
				output_image[y][x] = 0;

		bool image_to_output(false);

		//go through each path
		for (unsigned int g = 0; g < groups.size(); g++){
			const unsigned long path_id(0);
			ns_analyzed_image_time_path & path(groups[g].paths[path_id]);

			long i((long)t-((long)alignment_position - (long)path_aligned_event_index[g].index));
			
			if (!series.group_should_be_displayed[g] || i >= (long)path.elements.size()) 
				continue;

	
			
			ns_color_8 c;
			if (i > path.elements.size()){
				c = ns_movement_colors::color(ns_movement_not_calculated);
				if (include_motion_graphs)marker_manager.set_marker(-1,path_movement_graphs[g]);
			}
			else if (i >= 0){
				c = ns_movement_colors::color(path.movement_state(path.elements[i].absolute_time));
				if (include_motion_graphs)marker_manager.set_marker(path.elements[i].absolute_time,path_movement_graphs[g]);
			}
			else{
				c = ns_movement_colors::color(ns_movement_fast)/2;
				if (include_motion_graphs)marker_manager.set_marker(-1,path_movement_graphs[g]);
			}

			if (include_motion_graphs)path_movement_graphs[g].draw(graph_temp);
			

			
			int scale=1;
			if (i < 0)
				scale = 2;

			if (include_motion_graphs){
				for (unsigned int y = 0; y < graph_prop.height; y++){
					for (unsigned int x = 0; x < 3*graph_prop.width; x++){
						output_image[y+series.metadata_positions_on_visualization_grid[g].y]
						[x+ 3*series.metadata_positions_on_visualization_grid[g].x] = graph_temp[y][x]/scale;
					}
				}
			}

		
			//draw colored line around worm
			const ns_vector_2i & p (series.group_positions_on_visualization_grid[g]);
			const ns_vector_2i & s (series.group_context_sizes[g]);

			ns_vector_2i pos(series.group_positions_on_visualization_grid[g]);
			if (include_motion_graphs){
				if ( series.group_context_sizes[g].x < graph_temp.properties().width)
					pos.x += (graph_temp.properties().width-series.group_context_sizes[g].x)/2;
			}


		//	const ns_vector_2i s (series.metadata_positions_on_visualization_grid[g]+ns_vector_2i(graph_prop.width+thickness,graph_prop.height));
			output_image.draw_line_color(pos+ns_vector_2i(-thickness,-thickness),pos+ns_vector_2i(s.x,-thickness),c,thickness);
			output_image.draw_line_color(pos+ns_vector_2i(-thickness,-thickness),pos+ns_vector_2i(-thickness,s.y),c,thickness);
			output_image.draw_line_color(pos+s,pos+ns_vector_2i(s.x,-thickness),c,thickness);
			output_image.draw_line_color(pos+s,pos+ns_vector_2i(-thickness,s.y),c,thickness);
			
			if (i >= 0){
				const unsigned long time(path.elements[i].absolute_time);
				//find most up to date frame for the path;
				ns_analyzed_time_image_chunk chunk(i,i+1);
				path.load_movement_images(chunk,path_image_source[g]);
				if (i > 0)
					path.elements[i-1].clear_movement_images(); 

				image_to_output = true;
				//transfer over movement visualzation to the correct place on the grid.
				ns_image_standard im;
				path.elements[i].generate_movement_visualization(im);
		
				if (im.properties().height == 0)
					throw ns_ex("Registered images not loaded! Path ") << g << " i " << i;

				string::size_type ps(vis_summary.worms.size());
				vis_summary.worms.resize(ps+1);

				vis_summary.worms[ps].path_in_source_image.position = path.path_region_position;
				vis_summary.worms[ps].path_in_source_image.size= path.path_region_size;

				vis_summary.worms[ps].worm_in_source_image.position = path.elements[i].region_offset_in_source_image();
				vis_summary.worms[ps].worm_in_source_image.size = path.elements[i].worm_region_size();

				vis_summary.worms[ps].path_in_visualization.position = pos;
				vis_summary.worms[ps].path_in_visualization.size=  series.group_context_sizes[g];

				if (include_motion_graphs){
					vis_summary.worms[ps].metadata_in_visualizationA.position = series.metadata_positions_on_visualization_grid[g];
					vis_summary.worms[ps].metadata_in_visualizationA.size = ns_vector_2i(graph_prop.width,graph_prop.height);
				}
				else vis_summary.worms[ps].metadata_in_visualizationA.position = vis_summary.worms[ps].metadata_in_visualizationA.size = ns_vector_2i(0,0);

				vis_summary.worms[ps].stationary_path_id.path_id = path_id;
				vis_summary.worms[ps].stationary_path_id.group_id = g;
				vis_summary.worms[ps].stationary_path_id.detection_set_id = analysis_id;
				vis_summary.worms[ps].path_time.end_time = path.elements.rbegin()->absolute_time;
				vis_summary.worms[ps].path_time.start_time = path.elements[0].absolute_time;
				vis_summary.worms[ps].image_time = path.elements[i].absolute_time;

			
				//ns_vector_2i region_offset(path.elements[i].region_offset_in_source_image()-path.elements[i].context_offset_in_source_image());
				for (unsigned int y = 0; y < vis_summary.worms[ps].path_in_visualization.size.y; y++){
					for (unsigned int x = 0; x < 3*vis_summary.worms[ps].path_in_visualization.size.x; x++){
						output_image[y+pos.y]
						[x+ 3*pos.x] = im[y][x];
					}
				}
			}


		}
		string metadata;
		vis_summary.to_xml(metadata);
		output_image.set_description(metadata);
		ns_image_server_captured_image_region reg;
		reg.region_images_id = 0;
		reg.region_info_id = region_id;
		reg.region_name = region_name;
		reg.sample_id = sample_id;
		reg.experiment_id = experiment_id;
		reg.sample_name = sample_name;
		reg.experiment_name = experiment_name;
		ns_image_server_image im(reg.create_storage_for_aligned_path_image(t,(unsigned long)event_to_align,ns_tiff,sql,ns_movement_event_to_label(event_to_align)));
		try{
			bool had_to_use_volatile_storage;
			ns_image_storage_reciever_handle<ns_8_bit> r(image_server.image_storage.request_storage(im,ns_tiff,1024,&sql,had_to_use_volatile_storage,false,false));
			output_image.pump(r.output_stream(),1024);
			im.mark_as_finished_processing(&sql);
		}
		catch(ns_ex & ex){
			im.mark_as_finished_processing(&sql);
			throw ex;
		}
	}
}

void ns_time_path_image_movement_analyzer::generate_movement_posture_visualizations(const bool include_graphs,const unsigned long region_id,const ns_time_path_solution & solution,ns_sql & sql){
	const unsigned long thickness(3);

	ns_marker_manager marker_manager;

	const ns_vector_2i graph_dimensions(include_graphs?ns_vector_2i(300,200):ns_vector_2i(0,0));
	ns_worm_movement_description_series series = description_series;
	series.calculate_visualization_grid(graph_dimensions);
	if (series.group_positions_on_visualization_grid.size() != groups.size() ||
		series.group_should_be_displayed.size() != groups.size() ||
		series.group_region_sizes.size() != groups.size())
		throw ns_ex("calculate_visualization_grid() returned an inconsistant result");

	vector<unsigned long> path_i(groups.size(),0);
	vector<ns_image_storage_source_handle<ns_8_bit> > path_image_source;
	vector<ns_graph> path_movement_graphs(groups.size());
	path_image_source.reserve(groups.size());

	ns_image_standard output_image;
	ns_image_properties prop;
	prop.components = 3;
	prop.width = series.visualization_grid_dimensions.x;
	prop.height = series.visualization_grid_dimensions.y;
	output_image.init(prop);

	ns_image_properties graph_prop(prop);
	ns_image_standard graph_temp;
	if (include_graphs){
		graph_prop.width = series.metadata_dimensions.x;
		graph_prop.height = series.metadata_dimensions.y;
		graph_temp.init(graph_prop);
	}
	else graph_prop.width = graph_prop.height = 0;

	//initialize path movement image source for first frame
	for (unsigned int i = 0; i < groups.size(); i++){
		if (!series.group_should_be_displayed[i]){
			path_image_source.push_back(ns_image_storage_source_handle<ns_8_bit>(0)); //we want the index of groups[i] and path_image_source[i] to match so we fill unwanted groups with a dummy entry.
			continue;
		}
		groups[i].paths[0].output_image.load_from_db(groups[i].paths[0].output_image.id,&sql);
		path_image_source.push_back(image_server.image_storage.request_from_storage(groups[i].paths[0].output_image,&sql));
		groups[i].paths[0].initialize_movement_image_loading(path_image_source[i]);
	}

	//make movement 
	if (include_graphs){
		for (unsigned int i = 0; i < groups.size(); i++){
			if (!series.group_should_be_displayed[i]) continue;
			ns_make_path_movement_graph(groups[i].paths[0],path_movement_graphs[i]);
			path_movement_graphs[i].draw(graph_temp);
		}
	}

	//load first frame of all paths
	for (unsigned int g = 0; g < groups.size(); g++){
		if (!series.group_should_be_displayed[g]) continue;
		groups[g].paths[0].load_movement_images(ns_analyzed_time_image_chunk(0,1),path_image_source[g]);
	}
	//now go through each measurement time for the solution
	for (unsigned long t = 0; t < solution.timepoints.size(); t++){
		cerr << (100*t)/solution.timepoints.size() << "%...";

		ns_movement_posture_visualization_summary vis_summary;
		vis_summary.region_id = region_id;


		//init output image
		for (unsigned long y = 0; y < prop.height; y++)
			for (unsigned long x = 0; x < 3*prop.width; x++)
				output_image[y][x] = 0;
		bool image_to_output(false);

		const unsigned long time(solution.timepoints[t].time);
		//go through each path
		for (unsigned int g = 0; g < groups.size(); g++){
			if (!series.group_should_be_displayed[g]) continue;
			const unsigned long path_id(0);
			ns_analyzed_image_time_path & path(groups[g].paths[path_id]);
			unsigned long & i(path_i[g]);
			if (i >= path.elements.size()) continue;
			//find most up to date frame for the path;
			unsigned best_frame;

			for (best_frame = i; best_frame < path.elements.size() && path.elements[best_frame].absolute_time < time; best_frame++);
			if (best_frame == path.elements.size())
				continue;
			if (best_frame == 0 && path.elements[best_frame].absolute_time > time)
				continue;
			if (path.elements[best_frame].absolute_time > time)
				best_frame--;

			//now load frames until done
			if (best_frame > i+1)
				cerr << "Skipping" << best_frame - i << " frames from path " << g << "\n";

			for (; i < best_frame;){
			//	cerr << "Clearing p"<<g<< " " << i << "\n";
				if (i!=0)
					path.elements[i-1].clear_movement_images(); 
				++i;
				ns_analyzed_time_image_chunk chunk(i,i+1);
			//	cerr << "loading p"<<g<< " " << i << "\n";
				path.load_movement_images(chunk,path_image_source[g]);
			}

			image_to_output = true;
			//transfer over movement visualzation to the correct place on the grid.
			ns_image_standard im;
			ns_color_8 c;
			path.elements[i].generate_movement_visualization(im);
			c = ns_movement_colors::color(path.movement_state(time));
		
			if (im.properties().height == 0)
				throw ns_ex("Registered images not loaded! Path ") << g << " i " << i;


			string::size_type ps(vis_summary.worms.size());
			vis_summary.worms.resize(ps+1);
			vis_summary.worms[ps].path_in_source_image.position = path.path_region_position;
			vis_summary.worms[ps].path_in_source_image.size= path.path_region_size;

			vis_summary.worms[ps].worm_in_source_image.position = path.elements[i].region_offset_in_source_image();
			vis_summary.worms[ps].worm_in_source_image.size = path.elements[i].worm_region_size();

			vis_summary.worms[ps].path_in_visualization.position = series.group_positions_on_visualization_grid[g];
			vis_summary.worms[ps].path_in_visualization.size= series.group_context_sizes[g];

			if (include_graphs){
				vis_summary.worms[ps].metadata_in_visualizationA.position = series.metadata_positions_on_visualization_grid[g];
				vis_summary.worms[ps].metadata_in_visualizationA.size = ns_vector_2i(graph_prop.width,graph_prop.height);
			}
			else vis_summary.worms[ps].metadata_in_visualizationA.position = vis_summary.worms[ps].metadata_in_visualizationA.size = ns_vector_2i(0,0);

			vis_summary.worms[ps].stationary_path_id.path_id = path_id;
			vis_summary.worms[ps].stationary_path_id.group_id = g;
			vis_summary.worms[ps].stationary_path_id.detection_set_id = analysis_id;
			vis_summary.worms[ps].path_time.start_time = path.elements[i].absolute_time;
			vis_summary.worms[ps].path_time.end_time = path.elements.rbegin()->absolute_time;
			vis_summary.worms[ps].image_time = path.elements[i].absolute_time;

			
			//ns_vector_2i region_offset(path.elements[i].region_offset_in_source_image()-path.elements[i].context_offset_in_source_image());
			for (unsigned int y = 0; y < vis_summary.worms[ps].path_in_visualization.size.y; y++){
				for (unsigned int x = 0; x < 3*vis_summary.worms[ps].path_in_visualization.size.x; x++){
					output_image[y+vis_summary.worms[ps].path_in_visualization.position.y]
					[x+ 3*vis_summary.worms[ps].path_in_visualization.position.x] = im[y/*+region_offset.y*/][x/*+3*region_offset.x*/];
				}
			}

			if (include_graphs){
				marker_manager.set_marker(time,path_movement_graphs[g]);
				path_movement_graphs[g].draw(graph_temp);

				for (unsigned int y = 0; y < vis_summary.worms[ps].metadata_in_visualizationA.size.y; y++){
					for (unsigned int x = 0; x < 3*vis_summary.worms[ps].metadata_in_visualizationA.size.x; x++){
						output_image[y+vis_summary.worms[ps].metadata_in_visualizationA.position.y]
						[x+ 3*vis_summary.worms[ps].metadata_in_visualizationA.position.x] = graph_temp[y][x];
					}
				}
			}


			//draw colored line around worm
			const ns_vector_2i & p (vis_summary.worms[ps].path_in_visualization.position);
			const ns_vector_2i & s (vis_summary.worms[ps].path_in_visualization.size);
			output_image.draw_line_color(p,p+ns_vector_2i(s.x,0),c,thickness);
			output_image.draw_line_color(p,p+ns_vector_2i(0,s.y),c,thickness);
			output_image.draw_line_color(p+s,p+ns_vector_2i(s.x,0),c,thickness);
			output_image.draw_line_color(p+s,p+ns_vector_2i(0,s.y),c,thickness);
		}
		string metadata;
		vis_summary.to_xml(metadata);
		output_image.set_description(metadata);
		ns_image_server_captured_image_region reg;
		reg.region_images_id = solution.timepoints[t].sample_region_image_id;
		ns_image_server_image im(reg.create_storage_for_processed_image(ns_process_movement_posture_visualization,ns_tiff,&sql));
		try{
			bool had_to_use_volatile_storage;
			ns_image_storage_reciever_handle<ns_8_bit> r(image_server.image_storage.request_storage(im,ns_tiff,1024,&sql,had_to_use_volatile_storage,false,false));
			output_image.pump(r.output_stream(),1024);
			im.mark_as_finished_processing(&sql);
		}
		catch(ns_ex & ex){
			im.mark_as_finished_processing(&sql);
			throw ex;
		}
	}
};


//we step through all region visualizations between start_i and stop_i, ordered by time in region_image_specifications
//and populate any worm images that are needed from each region image.
void ns_time_path_image_movement_analyzer::load_region_visualization_images(const unsigned long start_i, const unsigned long stop_i,ns_sql & sql){

	for (unsigned long i = start_i; i < stop_i; i++){

		//check to see if the region images are needed at this time point
		region_image_specifications[i].required = false;
		for (unsigned int g = 0; g < groups.size(); g++){
			for (unsigned int p = 0; p < groups[g].paths.size(); p++){
				region_image_specifications[i].required = 
					region_image_specifications[i].required ||
					groups[g].paths[p].region_image_is_required(region_image_specifications[i].time);
//				if (region_image_specifications[i].required && g == 2)
//					cerr << "WHOA";
			}
		}
		if (!region_image_specifications[i].required)
			continue;

		//region images contain the context images
		ns_image_storage_source_handle<ns_8_bit> in(image_server.image_storage.request_from_storage(region_image_specifications[i].region_image,&sql));
		
		in.input_stream().pump(image_loading_temp,1024);
//		cerr << "Done.\n";
		//extract green channel, as this has the grayscale values.
		ns_image_properties prop(image_loading_temp.properties());
		if (prop.components != 3)
			throw ns_ex("ns_time_path_image_movement_analyzer::load_region_visualization_images()::Region images must be RBG");
		for (unsigned int g = 0; g < groups.size(); g++){
			for (unsigned int p = 0; p < groups[g].paths.size(); p++){
	//			ns_movement_image_collage_info m(groups[g].paths[p]);
				groups[g].paths[p].populate_images_from_region_visualization(region_image_specifications[i].time,image_loading_temp);
			}
		}
	}
}
