#include "ns_worm_training_set_image.h"
#include "ns_xml.h"
using namespace std;
void ns_worm_training_set_image::generate_check_boxes(){
	//draw check box for use in visualization
	ns_image_properties prop;
	prop.height = 50;
	prop.width = 50;
	prop.components = 3;
	check_box_unfilled_.prepare_to_recieve_image(prop);
	for (unsigned int y = 0; y < prop.height; y++)
		for (unsigned int x = 0; x < 3*prop.width; x++)
			check_box_unfilled_[y][x] = 0;
	for (unsigned int y = 0; y < prop.height; y++)
		for (unsigned int x = 0; x < 6; x++){
			check_box_unfilled_[y][x] = 255;
			check_box_unfilled_[y][3*(prop.width-2) +x] = 255;
		}
	for (unsigned int y = 0; y < 2; y++)
		for (unsigned int x = 0; x < 3*prop.width; x++){
			check_box_unfilled_[y][x] = 255;
			check_box_unfilled_[prop.height-2+y][x] = 255;
		}
	check_box_unfilled_.pump(check_box_filled_,512);
	for (unsigned int y = prop.height/3; y < (2*prop.height)/3; y++)
		for (unsigned int x = (prop.width/3)*3; x < (2*(prop.width/3)*3); x++)
			check_box_filled_[y][x] = 255;
}

struct ns_training_set_visualization_image_info{
	unsigned long multiple_worm_cluster_group_id;
	unsigned long multiple_worm_cluster_solution_id;
	ns_vector_2i original_bitmap_position;
	ns_vector_2i position;
	ns_vector_2i dimensions;
	bool identified_as_a_worm;
};
class ns_training_set_visualization_metadata_manager{
public:

	void from_collage(const ns_image_standard & im, const ns_image_standard & checkbox_unfilled, const ns_image_standard & checkbox_filled);
	std::string metadata_to_string(){
		ns_xml_simple_writer writer;
		writer.add_header();
		writer.start_group("image");
		writer.add_tag("min_intensity",minimum_region_intensity_in_containing_image);
		writer.add_tag("max_intensity",maximum_region_intensity_in_containing_image);
		writer.add_tag("av_intensity",minimum_region_intensity_in_containing_image);
		writer.end_group();
	/*	for(unsigned int i = 0; i < group_sizes.size(); i++){
			writer.start_group("gr");
			writer.add_tag("d",i);
			writer.add_tag("z",group_sizes[i]);
			writer.end_group();
		}*/

		for (unsigned int i = 0; i < image_info.size(); i++){
			writer.start_group("w");
			writer.add_tag("g",image_info[i].multiple_worm_cluster_group_id);
			writer.add_tag("s",image_info[i].multiple_worm_cluster_solution_id);
			writer.add_tag("ox",image_info[i].original_bitmap_position.x);
			writer.add_tag("oy",image_info[i].original_bitmap_position.y);
			writer.add_tag("px",image_info[i].position.x);
			writer.add_tag("py",image_info[i].position.y);
			writer.add_tag("dx",image_info[i].dimensions.x);
			writer.add_tag("dy",image_info[i].dimensions.y);
			if (image_info[i].identified_as_a_worm)
				 writer.add_tag("i","1");
			else writer.add_tag("i","0");
			writer.end_group();
		}
		writer.add_footer();
		return writer.result();
	}

	void load_from_mutually_exclusive_worm_groups(const std::vector< std::vector< std::vector<ns_detected_worm_info *> > > & groups){
		std::vector<ns_detected_worm_info *>::size_type s(0);
		for (unsigned int i = 0; i < groups.size(); i++){
			for (unsigned int g = 0; g < groups[i].size(); g++){
				for (unsigned int w = 0; w < groups[i][g].size(); w++){
					minimum_region_intensity_in_containing_image =   groups[i][g][w]->minimum_region_intensity_in_containing_image;  //should be the same for each
					maximum_region_intensity_in_containing_image =	 groups[i][g][w]->maximum_region_intensity_in_containing_image;  //worm in the image.
					average_region_intensity_in_containing_image =	 groups[i][g][w]->average_region_intensity_in_containing_image;  //we overwrite a bunch to save code

					s = worms.size();
					worms.resize(s+1,groups[i][g][w]);
					image_info.resize(s+1);
					image_info[s].multiple_worm_cluster_group_id = i;
					image_info[s].multiple_worm_cluster_solution_id = g;
					image_info[s].identified_as_a_worm = groups[i][g][w]->is_a_worm();
				}
			}
		}
		//generate visualization images
		images.resize(worms.size());
		unsigned int p(0);
		for (unsigned int i = 0; i < groups.size(); i++){
			for (unsigned int g = 0; g < groups[i].size(); g++){
				for (unsigned int w = 0; w < groups[i][g].size(); w++){
					image_info[p].original_bitmap_position =  groups[i][g][w]->generate_training_set_visualization(images[p]);
					p++;
				}
			}
		}
	}

	void generate_visualizations(const ns_image_standard & check_box_filled, const ns_image_standard & check_box_unfilled){
		
		//generate check box images
		images_with_boxes.resize(images.size());
		ns_image_properties check_p(check_box_unfilled.properties());
		for (unsigned int i = 0; i < worms.size(); i++){
			ns_image_properties prop(images[i].properties());
			prop.width += check_p.width;
			const ns_image_standard * box = & check_box_unfilled;
			if (worms[i]->is_a_worm())
				box = &check_box_filled;
			if(prop.height < check_p.height)
				prop.height = check_p.height;
			images_with_boxes[i].prepare_to_recieve_image(prop);
			for (unsigned int y = 0; y < prop.height; y++)
				for (unsigned int x = 0; x < prop.components*prop.width; x++)
					images_with_boxes[i][y][x] = 0;
			for (unsigned int y = 0; y < check_p.height; y++)
				for (unsigned int x = 0; x < prop.components*check_p.width; x++)
					images_with_boxes[i][y][x] = (*box)[y][x];
			for (unsigned int y = 0; y < images[i].properties().height; y++)
				for (unsigned int x = 0; x < prop.components*images[i].properties().width; x++)
					images_with_boxes[i][y][x+prop.components*check_p.width] = images[i][y][x];
		}
	}
	void generate_collage(ns_image_standard & im){

		ns_image_standard collage;
		std::vector<ns_packed_collage_position> worm_positions = ns_make_packed_collage(images_with_boxes,im,0,1200);
		if (worm_positions.size() != worms.size())
			throw ns_ex("ns_worm_training_set::to_image()::incorrect number of worm locations returned by make_packed_collage()") <<(unsigned long)worms.size() << "->" << (unsigned long) worm_positions.size();
		
		for (unsigned int i = 0; i < worm_positions.size(); i++){
			image_info[i].position = worm_positions[i].pos;
			image_info[i].dimensions = worm_positions[i].size;
		}

		im.set_description(this->metadata_to_string());
	}

	unsigned char minimum_region_intensity_in_containing_image,
				 maximum_region_intensity_in_containing_image,
				 average_region_intensity_in_containing_image;

	std::vector<ns_training_set_visualization_image_info> image_info;
	std::vector<ns_detected_worm_info *> worms;
	std::vector<ns_image_standard> images;
	std::vector<ns_image_standard> images_with_boxes;
	void from_string(const std::string & s){
		ns_xml_simple_object_reader reader;
		reader.from_string(s);
		//group_sizes.reserve(reader.objects.size()/2);
		image_info.reserve(reader.objects.size());
		for (unsigned int i = 0; i < reader.objects.size(); i++){
			if (reader.objects[i].name == "image"){
				minimum_region_intensity_in_containing_image = (unsigned char)atoi(reader.objects[i].tag("min_intensity").c_str());
				maximum_region_intensity_in_containing_image = (unsigned char)atoi(reader.objects[i].tag("max_intensity").c_str());
				average_region_intensity_in_containing_image = (unsigned char)atoi(reader.objects[i].tag("av_intensity").c_str());
			}
			/*if (reader.objects[i].name == "gr"){
				unsigned long id = atol(reader.objects[i].value("d").c_str());
				if (id >= group_sizes.size())
					group_sizes.resize(id+1);
				group_sizes[id] = atol(reader.objects[i].value("z").c_str());
			}*/
			if (reader.objects[i].name == "w"){
				unsigned long s = (unsigned long)image_info.size();
				image_info.resize(s+1);
				image_info[s].multiple_worm_cluster_group_id = atol(reader.objects[i].tag("g").c_str());
				image_info[s].multiple_worm_cluster_solution_id = atol(reader.objects[i].tag("s").c_str());
				image_info[s].original_bitmap_position. x= atol(reader.objects[i].tag("ox").c_str());
				image_info[s].original_bitmap_position.y = atol(reader.objects[i].tag("oy").c_str());
				image_info[s].position.x = atol(reader.objects[i].tag("px").c_str());
				image_info[s].position.y = atol(reader.objects[i].tag("py").c_str());
				image_info[s].dimensions.x = atol(reader.objects[i].tag("dx").c_str());
				image_info[s].dimensions.y = atol(reader.objects[i].tag("dy").c_str());
			}
		}
	}
};

void ns_worm_training_set_image::generate(const ns_image_worm_detection_results & results, ns_image_standard & out){
	ns_training_set_visualization_metadata_manager manager;
	manager.load_from_mutually_exclusive_worm_groups(results.mutually_exclusive_worm_groups);
	manager.generate_visualizations(check_box_filled(),check_box_unfilled());
	manager.generate_collage(out);
}


ns_annotated_training_set::~ns_annotated_training_set(){
	objects.clear();
	worm_positions.clear();
	region_stats.clear();
}

template<class ns_component>
float ns_calculate_overlap(const ns_image_whole<ns_component> & a, const ns_image_whole<ns_component> & b){

	unsigned long overlap(0);
	unsigned long area[2] = {0,0};
	for (unsigned int y = 0; y < a.properties().height; y++)
		for (unsigned int x = 0; x < a.properties().width; x++){
			overlap += a[y][x]&&b[y][x];
			area[0]+=a[y][x];
			area[1]+=b[y][x];
		}
	return (float)overlap/(float)(area[0]+area[1]);
}


void ns_worm_training_set_image::decode(const ns_image_standard & im,ns_annotated_training_set & t){

	//extract individual training images from collage
	ns_training_set_visualization_metadata_manager manager;
	manager.from_collage(im,check_box_filled(),check_box_unfilled());
	unsigned long checked(0);
	unsigned long unchecked(0);
	for (unsigned int i = 0; i < manager.image_info.size(); i++){
		if (manager.image_info[i].identified_as_a_worm)
			checked++;
		else unchecked++;
	}
//	cerr << "checked: " << checked << ", unchecked: " << unchecked << "\n";
	t.worms.reserve(manager.images.size()/2);
	t.non_worms.reserve(manager.images.size());
	t.objects.resize(manager.images.size());
	t.region_stats.resize(manager.images.size());
	
	//extract worm grayscale and bitmap information from the training images
	for (unsigned int i = 0; i < t.objects.size(); i++){
		t.objects[i].from_training_set_visualization(manager.images[i]);
	/*	std::string fname = "c:\\tt\\trn_";
		fname+=ns_to_string(i);
		fname+= ".tif";		
		ns_save_image(fname,*training_images[i]);
		std::string fname2 = "c:\\tt\\gry_";
		fname2+=ns_to_string(i);
		fname2+= ".tif";
		ns_save_image(fname2,t.objects[i].grayscale());*/

	}
	//calculate whole_region stats
	ns_8_bit min_region_intensity(-1);
	ns_8_bit max_region_intensity(0);
	unsigned long avg_region_intensity(0);
	for (unsigned int i = 0; i < t.objects.size(); i++){
		unsigned long reg_avg(0);
		unsigned long area_count(0);
		for (unsigned long y = 0; y < t.objects[i].bitmap().properties().height; y++)
			for (unsigned long x = 0; x < t.objects[i].bitmap().properties().width; x++){
				reg_avg+= t.objects[i].bitmap()[y][x]*t.objects[i].grayscale()[y][x];
				area_count+= t.objects[i].bitmap()[y][x];
			}
		if (area_count != 0)
			reg_avg/=area_count;
		avg_region_intensity+=reg_avg;
		if (reg_avg < min_region_intensity) min_region_intensity = (ns_8_bit)reg_avg;
		if (reg_avg > max_region_intensity) max_region_intensity = (ns_8_bit)reg_avg;
	}
	if (t.objects.size() > 0)
		avg_region_intensity/=(unsigned long)t.objects.size();
	for (unsigned int i = 0; i < t.objects.size(); i++){

		t.region_stats[i].minimum_region_intensity_in_containing_image = min_region_intensity;
		t.region_stats[i].maximum_region_intensity_in_containing_image = max_region_intensity;
		t.region_stats[i].average_region_intensity_in_containing_image = avg_region_intensity;
	}

	//build spines from bitmaps;
	ns_detected_object_manager object_manager;
	object_manager.objects.resize(t.objects.size(),0);
	for (unsigned int i = 0; i < t.objects.size(); i++){
		object_manager.objects[i] = new ns_detected_object();
		//we use the multiple worm bitmap
		t.objects[i].bitmap_of_worm_cluster().pump(object_manager.objects[i]->bitmap(),1024);
		//cerr << "Worm cluster has a size of " << t.objects[i].bitmap_of_worm_cluster().properties().width << "x" << t.objects[i].bitmap_of_worm_cluster().properties().height << "\n";
		object_manager.objects[i]->min_x = 
			object_manager.objects[i]->min_y = 0;
		object_manager.objects[i]->max_x = t.objects[i].bitmap().properties().width-1;
		object_manager.objects[i]->max_y = t.objects[i].bitmap().properties().height-1;
		object_manager.objects[i]->avg_x = object_manager.objects[i]->max_x/2;
		object_manager.objects[i]->avg_y = object_manager.objects[i]->max_y/2;
	}
	object_manager.convert_bitmaps_into_node_graphs(im.properties().resolution,"");
	object_manager.calculate_segment_topologies_from_node_graphs(true);
	//unsigned int number_of_worms = ns_count_number_of_worms_in_detected_object_group(object_manager.objects);

	//reconstruct mutually-exclusive solution hierarchy
	std::vector<std::vector<std::vector<ns_training_set_visualization_image_info * > > > metadata_mappings;
	std::vector<std::vector<std::vector<ns_detected_object * > > > mutually_exclusive_objects;
	t.mutually_exclusive_groups.reserve(manager.image_info.size());
	for (unsigned int i = 0; i < manager.image_info.size(); i++){
		if (manager.image_info[i].multiple_worm_cluster_group_id >= mutually_exclusive_objects.size()){
			mutually_exclusive_objects.resize (manager.image_info[i].multiple_worm_cluster_group_id+1);
			t.mutually_exclusive_groups.resize(manager.image_info[i].multiple_worm_cluster_group_id+1);
			metadata_mappings.resize		  (manager.image_info[i].multiple_worm_cluster_group_id+1);
		}
		if (manager.image_info[i].multiple_worm_cluster_solution_id >= mutually_exclusive_objects[manager.image_info[i].multiple_worm_cluster_group_id].size()){
			mutually_exclusive_objects [manager.image_info[i].multiple_worm_cluster_group_id].resize(manager.image_info[i].multiple_worm_cluster_solution_id +1);
			t.mutually_exclusive_groups[manager.image_info[i].multiple_worm_cluster_group_id].resize(manager.image_info[i].multiple_worm_cluster_solution_id +1);
			metadata_mappings		   [manager.image_info[i].multiple_worm_cluster_group_id].resize(manager.image_info[i].multiple_worm_cluster_solution_id +1);
		}
		mutually_exclusive_objects [manager.image_info[i].multiple_worm_cluster_group_id][manager.image_info[i].multiple_worm_cluster_solution_id].push_back(object_manager.objects[i]);
		t.mutually_exclusive_groups[manager.image_info[i].multiple_worm_cluster_group_id][manager.image_info[i].multiple_worm_cluster_solution_id].push_back(&t.objects[i]);
		metadata_mappings		   [manager.image_info[i].multiple_worm_cluster_group_id][manager.image_info[i].multiple_worm_cluster_solution_id].push_back(&manager.image_info[i]);
	}

	t.objects.reserve(manager.image_info.size());
	//now we go through each group and recalculate the solutions for each.
	for (unsigned int g = 0; g < mutually_exclusive_objects.size(); g++){
		if (mutually_exclusive_objects[g].size() == 0)
			continue;
		//each member of the group originate from the same multiple-worm disambiguation.
		//Thus, we only need to re-solve this once and can use that solution for all group members.
		std::vector<ns_detected_object *> objs(1,mutually_exclusive_objects[g][0][0]);
		std::vector<ns_detected_worm_info> solutions(ns_count_number_of_worms_in_detected_object_group(objs));
		std::vector<std::vector<ns_detected_worm_info *> > tmp;
		ns_image_bitmap *bmp(new ns_image_bitmap),*ebmp(new ns_image_bitmap);
		try{
			mutually_exclusive_objects[g][0][0]->bitmap().pump(*bmp,1024);
			mutually_exclusive_objects[g][0][0]->edge_bitmap().pump(*ebmp,1024);
			unsigned int worms_found = ns_detected_worm_info::from_segment_cluster_solution(*mutually_exclusive_objects[g][0][0],
					solutions, 0, tmp ,t.mutually_exclusive_groups[g][0][0]->grayscale(),false,ns_detected_worm_info::ns_vis_none);
			mutually_exclusive_objects[g][0][0]->accept_bitmap(bmp);
			bmp = 0;
			mutually_exclusive_objects[g][0][0]->accept_edge_bitmap(ebmp);
		}
		catch(...){
			if (bmp!=0)delete bmp;
			delete ebmp;
		}
		if (solutions.size() == 0)
			throw ns_ex("ns_worm_training_set_image::decode()::Could not find worm in imported image");
		//std::vector<char> solution_used(solutions.size(),0);
		for (unsigned int s = 0; s < t.mutually_exclusive_groups[g].size(); s++){
			for (unsigned int i = 0; i < t.mutually_exclusive_groups[g][s].size(); i++){
			
				unsigned long chosen_worm;
				if (solutions.size() == 1)
					chosen_worm = 0;
				else{
					chosen_worm = -1;
					//look for the detected worm with the most overlap with the one found in the training set image
					float max_overlap(0);
					unsigned long max_overlap_id(-1);
					for (unsigned int j = 0; j < solutions.size(); j++){
					//	if (solution_used[j]) continue;
						/*ns_image_standard im;
						ns_image_properties prop(t.objects[i].bitmap().properties());
						prop.components = 3;
						im.prepare_to_recieve_image(prop);
						for (unsigned int y = 0; y < prop.height; y++)
							for (unsigned int x = 0; x < prop.width; x++){
								im[y][3*x] = 255*(ns_8_bit)t.objects[i].bitmap()[y][x];
								im[y][3*x+1] = 0;
								im[y][3*x+2] = 255*(ns_8_bit)worms_found_in_image[j].bitmap()[y][x];
						}
						std::string fname = "c:\\tt\\bmp_";
						fname+=ns_to_string(i);
						fname+="_";
						fname+=ns_to_string(j);
						fname+=".tif";
						ns_save_image(fname,im);
						*/

						float overlap = ns_calculate_overlap(mutually_exclusive_objects[g][s][i]->bitmap(),solutions[j].bitmap());
						if (overlap > max_overlap){
							max_overlap = overlap;
							max_overlap_id = j;
						}
					}
					if (max_overlap_id != -1){
					//	cerr << "Max Overlap = " << max_overlap << "\n";
						chosen_worm = max_overlap_id;
				//		solution_used[max_overlap_id] = 1;
					}
					else std::cerr << "ns_worm_training_set_image::decode()::No detected worms had any overlap w. bitmap!";
				}
				//we now have the correct multiple worm disambiguation solution.  We copy it over, being carefule
				//to replace the original context image that we had to remove earlier.
				ns_vector_2i pos_in_ctx = t.mutually_exclusive_groups[g][s][i]->get_bitmap_offset_in_context_image();
				ns_image_standard ctx;
				
				t.mutually_exclusive_groups[g][s][i]->context_image().pump(ctx,1024);
				*t.mutually_exclusive_groups[g][s][i] = solutions[chosen_worm];
				t.mutually_exclusive_groups[g][s][i]->set_bitmap_offset_in_context_image(pos_in_ctx);
				ctx.pump(t.mutually_exclusive_groups[g][s][i]->context_image(),1024);
				t.mutually_exclusive_groups[g][s][i]->minimum_region_intensity_in_containing_image = manager.minimum_region_intensity_in_containing_image;
				t.mutually_exclusive_groups[g][s][i]->maximum_region_intensity_in_containing_image = manager.maximum_region_intensity_in_containing_image;
				t.mutually_exclusive_groups[g][s][i]->average_region_intensity_in_containing_image = manager.average_region_intensity_in_containing_image;
			}
		}
	}
	//set up propper  bindings
	for (unsigned int g = 0; g < t.mutually_exclusive_groups.size(); g++){
		for (unsigned int s = 0; s < t.mutually_exclusive_groups[g].size(); s++){
			for (unsigned int i = 0; i < t.mutually_exclusive_groups[g][s].size(); i++){
				if ((t.mutually_exclusive_groups[g].size() > 1 || t.mutually_exclusive_groups[g][s].size() > 1)
					&& !metadata_mappings[g][s][i]->identified_as_a_worm)
					 t.censored_worms.push_back(t.mutually_exclusive_groups[g][s][i]);
				else if (metadata_mappings[g][s][i]->identified_as_a_worm)
					 t.worms.push_back(t.mutually_exclusive_groups[g][s][i]);
				else t.non_worms.push_back(t.mutually_exclusive_groups[g][s][i]);
			}
		}
	}
}

void ns_training_set_visualization_metadata_manager::from_collage(const ns_image_standard & in, const ns_image_standard & check_box_unfilled, const ns_image_standard & check_box_filled){

	//cerr << "in size: " << in.properties().width << "," << in.properties().height << "," << (int)in.properties().components << "\n";
	const ns_image_properties prop(in.properties());
	//get number of objects

	from_string(prop.description);
	if (image_info.size() == 0)
		throw ns_ex("Could not identify any annotated worms in image");
	
	images.resize(image_info.size());

	//cerr << "Input positions:\n";
	//for (unsigned int i = 0 ; i < worm_positions.size(); i++)
	//	cerr << worm_positions[i].pos << ":" <<worm_positions[i].size << "," << worm_positions[i].original_bitmap_position << "\n";
	
	//ns_image_standard vis;
	//in.pump(vis,1024);


	for (unsigned int i = 0; i < image_info.size(); i++){
		ns_image_properties new_prop(prop);
		new_prop.height = image_info[i].dimensions.y;
		if (image_info[i].dimensions.x <= (long)check_box_unfilled.properties().width)
			throw ns_ex("Could not extract a check box from an image with width") << image_info[i].dimensions.x;
		new_prop.width = image_info[i].dimensions.x -check_box_unfilled.properties().width;
		images[i].prepare_to_recieve_image(new_prop);

		//see if the image is checked
		unsigned long pixels_in_checked_area(0);
		for (unsigned int y = 3; y < check_box_unfilled.properties().height-2; y++)
			for (unsigned int x = 3; x < check_box_unfilled.properties().width-2; x++){
				ns_vector_2i p(new_prop.components*(image_info[i].position.x + x),image_info[i].position.y + y);  //number_of_info_lines offset because these do not contain image info
				
				pixels_in_checked_area+=(in[p.y][p.x] > 200 && in[p.y][p.x+1] > 200);
			
			}
	//		cerr << pixels_in_checked_area << "\n";
		bool marked_as_worm(pixels_in_checked_area > 75);
	//	if (marked_as_worm)
		//cerr << worm_positions[i].pos << ":" <<worm_positions[i].size << ",\t" << worm_positions[i].original_bitmap_position << " is a worm\n";
		//see if the image is a duplicate
		bool marked_as_duplicate(true);
		for (unsigned int y = 4; marked_as_duplicate && y < 8; y++)
			for (unsigned int x = 4; x < 8; x++){
				ns_vector_2i p(new_prop.components*(image_info[i].position.x + x),image_info[i].position.y + y );  //number_of_info_lines offset because these do not contain image info
		
				if (!(in[p.y][p.x] == 255 && in[p.y][p.x+1] == 0 && in[p.y][p.x+2] == 0)){
					marked_as_duplicate = false;
					break;
				}
			}

		//copy image
		for (unsigned int y = 0; y < new_prop.height; y++)
			for (unsigned int x = 0; x < new_prop.components*new_prop.width; x++){
				ns_vector_2i p(new_prop.components*(check_box_unfilled.properties().width+image_info[i].position.x) + x,image_info[i].position.y + y);  //number_of_info_lines offset because these do not contain image info
				if ((unsigned long)p.x >= in.properties().components*in.properties().width)
					throw ns_ex() << "i" << i << "x:" <<p.x <<">" << in.properties().components*in.properties().width << "\n";
				if ((unsigned long)p.y >= in.properties().height)
					throw ns_ex() << "i" << i << "y:"<< p.y <<">" << in.properties().height << "\n";
					images[i][y][x] = in[p.y][p.x];
			}

		//if (marked_as_duplicate){
			//cerr << "Marked as duplicate\n";
			//continue;
		//}
		image_info[i].identified_as_a_worm = marked_as_worm;

		//if (1 || marked_as_worm){
		//	for (unsigned int y = 0; y < 20; y++)
		//		for (unsigned int x = 0; x < 20; x++)
		//			vis[worm_positions[i].pos.y+y][3*(worm_positions[i].pos.x+x+i/2)+1] = 255;
		//}
	}
	//ns_save_image("c:\\tt\\vis.tif",vis);
	
}


ns_image_standard & ns_worm_training_set_image::check_box_filled(){
	if (check_box_filled_.properties().width == 0)generate_check_boxes();
	return check_box_filled_;
}
ns_image_standard & ns_worm_training_set_image::check_box_unfilled(){
	if (check_box_unfilled_.properties().width == 0)generate_check_boxes();
	return check_box_unfilled_;
}
ns_image_standard ns_worm_training_set_image::check_box_filled_;
ns_image_standard ns_worm_training_set_image::check_box_unfilled_;
