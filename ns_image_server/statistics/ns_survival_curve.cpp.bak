#include "ns_survival_curve.h"
#include "ns_ex.h"
#include <fstream>
#include <string>
#include <iostream>
#include "ns_movement_state.h"
#include <set>
#include <algorithm>
#include "ns_by_hand_lifespan.h"
#include "ns_jmp_file.h"
#include "ns_xml.h"
using namespace std;


void ns_genotype_fetcher::load_from_db(ns_image_server_sql * sql, const bool load_all){
	*sql << "SELECT strain,genotype,id FROM strain_aliases";
	if (!load_all) *sql << " WHERE used_in_cluster = 1";
	ns_sql_result res;
	sql->get_rows(res);
	for (unsigned int i = 0; i < res.size(); i++){
		genotypes[res[i][0]] = ns_genotype_db_internal_info(atol(res[i][2].c_str()),res[i][1]);
	}
}
	
const std::string & ns_genotype_fetcher::genotype_from_strain(const std::string & strain, ns_image_server_sql * sql) const{
	ns_genotype_list::const_iterator p(genotypes.find(strain));
	if (p == genotypes.end()){
		*sql << "SELECT strain,genotype,id FROM strain_aliases WHERE strain='" << strain << "'";
		ns_sql_result res;
		sql->get_rows(res);
		if (res.size() == 0)
			return empty_string;
		else 
			p = genotypes.insert(
			ns_genotype_list::value_type(res[0][0],ns_genotype_db_internal_info(atol(res[0][2].c_str()),res[0][1]))
			).first;
		*sql << "UPDATE strain_aliases SET used_in_cluster = 1 WHERE id = " << res[0][2];
		sql->send_query();
	}
	return p->second.genotype;
}

void ns_survival_data::convert_absolute_times_to_ages(){
	for (unsigned int i = 0; i < timepoints.size(); i++)
		timepoints[i].absolute_time-=metadata.time_at_which_animals_had_zero_age;
	metadata.time_at_which_animals_had_zero_age = 0;
}
void ns_lifespan_experiment_set::convert_absolute_times_to_ages(){

	for (unsigned int i = 0; i < curves.size(); i++)
		curves[i].convert_absolute_times_to_ages();
}

void ns_lifespan_experiment_set::load_from_by_hand_lifespan_file(std::ifstream & in){
	ns_by_hand_lifespan_experiment_specification spec;
	spec.load(in);
	spec.convert_to_lifespan_experiment_set(*this);
}

void ns_region_metadata::load_from_fields(const std::map<std::string,std::string> & m,std::map<std::string,std::string> &unknown_values){
	clear();
	for (std::map<std::string,std::string>::const_iterator p = m.begin(); p != m.end(); p++){
		const string f(ns_to_lower(p->first));
		if (is_age_zero_field(f))
			time_at_which_animals_had_zero_age = ns_time_from_format_string(p->second);
		else{
			std::string * v(get_field_by_name(f));
			if (v != 0) *v = p->second;
			else unknown_values.insert(p,p);
		}
	}
}
void ns_region_metadata::recognized_field_names(std::vector<std::string> & names){
	names.push_back("details");
	names.push_back("device");
	names.push_back("experiment");
	names.push_back("region OR plate");
	names.push_back("sample");
	names.push_back("technique");
	names.push_back("strain");
	names.push_back("genotype");
	names.push_back("analysis type");
	names.push_back("technique");
	names.push_back("culturing temperature");
	names.push_back("experiment temperature");
	names.push_back("food source");
	names.push_back("environmental conditions");
	names.push_back("condition 1 OR strain condition 1");
	names.push_back("condition 2 OR strain condition 2");
	names.push_back("condition 3 OR strain condition 3");
	names.push_back("at age zero OR time at age zero OR age zero");
}

bool ns_region_metadata::is_age_zero_field(const std::string & s){return s.find("at age zero")!=std::string::npos || s.find("time at age zero")!=std::string::npos|| s.find("age zero")!=std::string::npos;}

std::string * ns_region_metadata::get_field_by_name(const std::string & s){
	if (s.find("details")!=std::string::npos)
		return &details;
	else if (s.find("device")!=std::string::npos)
		return &device;
	else if (s.find("experiment")!=std::string::npos)
		return &experiment_name;
	else if (s.find("region")!=std::string::npos ||
			 s.find("plate")!=std::string::npos)
		return &region_name;
	else if (s.find("sample")!=std::string::npos)
		return &sample_name;
	else if (s.find("technique")!=std::string::npos)
		return &technique;
	else if (s.find("strain")!=std::string::npos)
		return &strain;
	else if (s.find("genotype")!=std::string::npos)
		return &genotype;
	else if (s.find("analysis_type")!=std::string::npos)
		return &analysis_type;
	else if (s.find("technique")!=std::string::npos)
		return &technique;	
	else if (s.find("condition 1")!=std::string::npos || s.find("strain condition 1")!=std::string::npos || s.find("strain_condition_1")!=std::string::npos)
		return &strain_condition_1;	
	else if (s.find("condition 2")!=std::string::npos || s.find("strain condition 2")!=std::string::npos || s.find("strain_condition_2")!=std::string::npos)
		return &strain_condition_2;
	else if (s.find("condition 3")!=std::string::npos || s.find("strain condition 3")!=std::string::npos || s.find("strain_condition_3")!=std::string::npos)
		return &strain_condition_3;	
	else if (s.find("culturing_temperature")!=std::string::npos || s.find("culturing temperature")!=std::string::npos)
		return &culturing_temperature;
	else if (s.find("experiment_temperature")!=std::string::npos || s.find("experiment temperature")!=std::string::npos)
		return &experiment_temperature;
	else if (s.find("food_source")!=std::string::npos || s.find("food source")!=std::string::npos)
		return &food_source;
	else if (s.find("environmental_conditions")!=std::string::npos || s.find("environmental conditions")!=std::string::npos)
		return &environmental_conditions;
	else if (is_age_zero_field(s))
		throw ns_ex("get_field_by_name()::Found zero age field");
	return 0;
}


	
void ns_region_metadata::load_only_region_info_from_db(const unsigned long region_info_id, const std::string &analysis_type_, ns_sql & sql){
	sql << "SELECT sample_id, name, strain, strain_condition_1,strain_condition_2,strain_condition_3,"
		   "culturing_temperature,experiment_temperature,food_source, environmental_conditions,"
		   "time_at_which_animals_had_zero_age,details,time_of_last_valid_sample,"
		   "position_in_sample_x,position_in_sample_y,size_x,size_y "
		   "FROM sample_region_image_info WHERE id = " << region_info_id;
	ns_sql_result res;
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("Could not load metadata for region") << region_info_id;
	region_id = region_info_id;
	sample_id = atol(res[0][0].c_str());
	region_name = res[0][1];
	strain = res[0][2];
	strain_condition_1 = res[0][3];
	strain_condition_2 = res[0][4];
	strain_condition_3 = res[0][5];
	culturing_temperature = res[0][6];
	experiment_temperature = res[0][7];
	food_source = res[0][8];
	environmental_conditions = res[0][9];
	time_at_which_animals_had_zero_age = atol(res[0][10].c_str());
	details = res[0][11];
	time_of_last_valid_sample = atol(res[0][12].c_str());
	position_of_region_in_sample.x = atof(res[0][13].c_str());
	position_of_region_in_sample.y = atof(res[0][14].c_str());
	size.x = atof(res[0][15].c_str());
	size.y = atof(res[0][16].c_str());
	analysis_type = analysis_type_;
}

void ns_region_metadata::load_only_sample_info_from_db(const unsigned long sample_id_, ns_sql & sql){
	sample_id = sample_id_;
	sql << "SELECT experiment_id,name,device_name,incubator_name,incubator_location, position_x, position_y, image_resolution_dpi FROM capture_samples WHERE id = " << sample_id;
	ns_sql_result res;
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("Could not load metadata for sample ") << sample_id;
	sample_name = res[0][1];
	device = res[0][2];
	incubator_name = res[0][3];
	incubator_location = res[0][4];
	experiment_id = atol(res[0][0].c_str());
	float resolution(atof(res[0][7].c_str()));
	if (resolution == 0)
		throw ns_ex("Sample had a resolution of 0 specified in the database!");
	position_of_sample_on_scanner = ns_vector_2i(atof(res[0][5].c_str()),atof(res[0][6].c_str()));

	sql << "SELECT name,id FROM experiments WHERE id = " << res[0][0];
	sql.get_rows(res);
	if (res.size() == 0)
		throw ns_ex("Could not load metadata for sample ") << sample_id << ", experiment " << res[0][0];
	experiment_name = res[0][0];
}

void ns_region_metadata::load_from_db(const unsigned long region_info_id, const std::string &analysis_type_, ns_sql & sql){
	load_only_region_info_from_db(region_info_id,analysis_type_,sql);
	load_only_sample_info_from_db(sample_id,sql);
}

bool operator<(const ns_survival_timepoint & a, const ns_survival_timepoint & b){
	return a.absolute_time < b.absolute_time;
}

void ns_lifespan_experiment_set::load_from_JMP_file(std::ifstream & in){
	ns_jmp_file file;
	file.load(in);
	file.generate_survival_curve_set(*this);
}

void ns_lifespan_experiment_set::output_R_file(std::ostream & out)const{
	throw ns_ex("Not implemented");
}

void ns_lifespan_experiment_set::group_strains(ns_lifespan_experiment_set & new_set) const{
//	throw ns_ex("Not implemented");
	if (!set_is_on_common_time())
		throw ns_ex("ns_lifespan_experiment_set::group_strains()::Can only group curves after they are placed on a common time axis.");

	
	new_set.clear();
	new_set.common_time_.insert(new_set.common_time_.begin(),common_time().begin(),common_time().end());

	map<string,unsigned int> strain_ids;
	for (unsigned int i = 0; i < curves.size(); i++){
		unsigned long new_id;
		{
			string cur_name(curves[i].metadata.plate_type_summary());
			map<string,unsigned int>::iterator p = strain_ids.find(cur_name);
			if (p == strain_ids.end()){
				new_id = new_set.curves.size();
				new_set.curves.resize(new_id+1);
				new_set.curves[new_id].metadata = curves[i].metadata;
				new_set.curves[new_id].metadata.sample_name = "All " + cur_name + " animals";
				new_set.curves[new_id].metadata.region_name = "All " + cur_name + " animals";
				new_set.curves[new_id].timepoints.resize(common_time().size());
				strain_ids[cur_name] = new_id;
			}
			else new_id = p->second;
		}
		for (unsigned int t = 0; t < common_time().size(); t++)
			new_set.curves[new_id].timepoints[t]= new_set.curves[new_id].timepoints[t]+curves[i].timepoints[t];
	}
	new_set.curves_on_constant_time_interval = curves_on_constant_time_interval;
}

double ns_find_percentile_average(const std::vector<double> & d, const unsigned long percentile){
		unsigned int start,
					 stop;
		switch(percentile){
			case 1: start = 0; stop = d.size()/10; break;
			case 9: start = (9*d.size())/10; stop = d.size(); break;
			default: throw ns_ex("Lazy percentile implentation can't handle your reasonable input");
		}
		double sum(0);
		for (unsigned int i = start; i < stop; i++)
			sum+=d[i];
		if (start==stop)
			return 0;
		return sum/(stop-start);
}
ns_survival_data_summary ns_survival_data::produce_summary() const{
	ns_survival_data_summary s;
	s.metadata = metadata;
	s.death.set_as_zero();
	s.local_movement_cessation.set_as_zero();
	s.long_distance_movement_cessation.set_as_zero();
	vector<double> death_times,
						  local_movement_cessation_times,
						  long_distance_movement_cessation_times;

	for (unsigned int j = 0; j < timepoints.size(); ++j){
		const double age(timepoints[j].absolute_time-metadata.time_at_which_animals_had_zero_age);
	//	const long age(timepoints[j].absolute_time);
		s.death.count+=timepoints[j].deaths.event_count;
		s.death.machine_excluded_count += timepoints[j].deaths.machine_excluded_event_count;
		s.death.by_hand_excluded_count += timepoints[j].deaths.by_hand_excluded_event_count;
		s.death.censored_count += timepoints[j].deaths.censored_count;
		s.death.number_of_events_involving_multiple_worm_disambiguation += timepoints[j].deaths.number_in_event_count_that_came_from_multiple_worm_disambiguation_events;
		
		s.local_movement_cessation.count+=timepoints[j].local_movement_cessations.event_count;
		s.local_movement_cessation.machine_excluded_count += timepoints[j].local_movement_cessations.machine_excluded_event_count;
		s.local_movement_cessation.by_hand_excluded_count += timepoints[j].local_movement_cessations.by_hand_excluded_event_count;
		s.local_movement_cessation.censored_count += timepoints[j].local_movement_cessations.censored_count;
		s.local_movement_cessation.number_of_events_involving_multiple_worm_disambiguation += timepoints[j].local_movement_cessations.number_in_event_count_that_came_from_multiple_worm_disambiguation_events;
		
		s.long_distance_movement_cessation.count+=timepoints[j].long_distance_movement_cessations.event_count;
		s.long_distance_movement_cessation.machine_excluded_count += timepoints[j].long_distance_movement_cessations.machine_excluded_event_count;
		s.long_distance_movement_cessation.by_hand_excluded_count += timepoints[j].long_distance_movement_cessations.by_hand_excluded_event_count;
		s.long_distance_movement_cessation.censored_count += timepoints[j].long_distance_movement_cessations.censored_count;
		s.long_distance_movement_cessation.number_of_events_involving_multiple_worm_disambiguation += timepoints[j].long_distance_movement_cessations.number_in_event_count_that_came_from_multiple_worm_disambiguation_events;

		s.death.mean+=timepoints[j].deaths.event_count*age;
		s.local_movement_cessation.mean+=timepoints[j].local_movement_cessations.event_count*age;
		s.long_distance_movement_cessation.mean+=timepoints[j].long_distance_movement_cessations.event_count*age;

		for (unsigned int i = 0; i < timepoints[j].deaths.event_count; i++)
			death_times.push_back(age);		
		for (unsigned int i = 0; i < timepoints[j].local_movement_cessations.event_count; i++)
			local_movement_cessation_times.push_back(age);		
		for (unsigned int i = 0; i < timepoints[j].long_distance_movement_cessations.event_count; i++)
			 long_distance_movement_cessation_times.push_back(age);
	}	
	if (s.death.count!= 0) s.death.mean/=s.death.count;
	if (s.local_movement_cessation.count!= 0) s.local_movement_cessation.mean/=s.local_movement_cessation.count;
	if (s.long_distance_movement_cessation.count!= 0) s.long_distance_movement_cessation.mean/=s.long_distance_movement_cessation.count;

	for (unsigned int j = 0; j < timepoints.size(); ++j){
		const double age(timepoints[j].absolute_time-metadata.time_at_which_animals_had_zero_age);
		s.death.variance+=timepoints[j].deaths.event_count*(age-s.death.mean)*(age-s.death.mean);
		s.local_movement_cessation.variance+=timepoints[j].local_movement_cessations.event_count*(age-s.local_movement_cessation.mean)*(age-s.local_movement_cessation.mean);
		s.long_distance_movement_cessation.variance+=timepoints[j].long_distance_movement_cessations.event_count*(age-s.long_distance_movement_cessation.mean)*(age-s.long_distance_movement_cessation.mean);
	}
	if (s.death.count!= 0) s.death.variance/=s.death.count;
	if (s.local_movement_cessation.count!= 0) s.local_movement_cessation.variance/=s.local_movement_cessation.count;
	if (s.long_distance_movement_cessation.count!= 0) s.long_distance_movement_cessation.variance/=s.long_distance_movement_cessation.count;

	std::sort(death_times.begin(),death_times.end());
	std::sort(local_movement_cessation_times.begin(),local_movement_cessation_times.end());
	std::sort(long_distance_movement_cessation_times.begin(),long_distance_movement_cessation_times.end());
	if (death_times.size() > 0){
		s.death.percentile_10th = ns_find_percentile_average(death_times,1);
		s.death.percentile_90th = ns_find_percentile_average(death_times,9);
		s.death.percentile_50th =death_times[death_times.size()/2];
		s.death.minimum = *death_times.begin();
		s.death.maximum = *death_times.rbegin();
	}	
	if (local_movement_cessation_times.size() > 0){
		s.local_movement_cessation.percentile_10th = ns_find_percentile_average(local_movement_cessation_times,1);
		s.local_movement_cessation.percentile_90th = ns_find_percentile_average(local_movement_cessation_times,9);
		s.local_movement_cessation.percentile_50th =local_movement_cessation_times[local_movement_cessation_times.size()/2];
		s.local_movement_cessation.minimum = *local_movement_cessation_times.begin();
		s.local_movement_cessation.maximum = *local_movement_cessation_times.rbegin();
	}	
	if (long_distance_movement_cessation_times.size() > 0){
		s.long_distance_movement_cessation.percentile_10th = ns_find_percentile_average(long_distance_movement_cessation_times,1);
		s.long_distance_movement_cessation.percentile_90th = ns_find_percentile_average(long_distance_movement_cessation_times,9);
		s.long_distance_movement_cessation.percentile_50th =long_distance_movement_cessation_times[long_distance_movement_cessation_times.size()/2];
		s.long_distance_movement_cessation.minimum = *long_distance_movement_cessation_times.begin();
		s.long_distance_movement_cessation.maximum = *long_distance_movement_cessation_times.rbegin();
	}

	s.death.maximum+=metadata.time_at_which_animals_had_zero_age;
	s.death.minimum+=metadata.time_at_which_animals_had_zero_age;
	s.death.mean+=metadata.time_at_which_animals_had_zero_age;
	s.death.percentile_10th+=metadata.time_at_which_animals_had_zero_age;
	s.death.percentile_50th+=metadata.time_at_which_animals_had_zero_age;
	s.death.percentile_90th+=metadata.time_at_which_animals_had_zero_age;

	s.local_movement_cessation.maximum+=metadata.time_at_which_animals_had_zero_age;
	s.local_movement_cessation.minimum+=metadata.time_at_which_animals_had_zero_age;
	s.local_movement_cessation.mean+=metadata.time_at_which_animals_had_zero_age;
	s.local_movement_cessation.percentile_10th+=metadata.time_at_which_animals_had_zero_age;
	s.local_movement_cessation.percentile_50th+=metadata.time_at_which_animals_had_zero_age;
	s.local_movement_cessation.percentile_90th+=metadata.time_at_which_animals_had_zero_age;

	s.long_distance_movement_cessation.maximum+=metadata.time_at_which_animals_had_zero_age;
	s.long_distance_movement_cessation.minimum+=metadata.time_at_which_animals_had_zero_age;
	s.long_distance_movement_cessation.mean+=metadata.time_at_which_animals_had_zero_age;
	s.long_distance_movement_cessation.percentile_10th+=metadata.time_at_which_animals_had_zero_age;
	s.long_distance_movement_cessation.percentile_50th+=metadata.time_at_which_animals_had_zero_age;
	s.long_distance_movement_cessation.percentile_90th+=metadata.time_at_which_animals_had_zero_age;
	return s;
}

std::string ns_region_metadata::to_xml() const{
	ns_xml_simple_writer xml;
	xml.add_tag("device",device);
	xml.add_tag("technique",technique);
	xml.add_tag("experiment_name",experiment_name);
	xml.add_tag("sample_name",sample_name);
	xml.add_tag("region_name",region_name);
	xml.add_tag("strain",strain);
	xml.add_tag("strain_condition_1",strain_condition_1);
	xml.add_tag("strain_condition_2",strain_condition_2);
	xml.add_tag("strain_condition_3",strain_condition_3);
	xml.add_tag("culturing_temperature",culturing_temperature);
	xml.add_tag("experiment_temperature",experiment_temperature);
	xml.add_tag("food_source",food_source);
	xml.add_tag("environmental_conditions",environmental_conditions);
	xml.add_tag("genotype",genotype);
	xml.add_tag("details",details);
	xml.add_tag("analysis_type",analysis_type);
	xml.add_tag("region_id",region_id);
	return xml.result();
}

bool ns_region_metadata::from_xml(const ns_xml_simple_object & o){
	int found_something(0);
	found_something+=(int)o.assign_if_present("device",device);
	found_something+=(int)o.assign_if_present("technique",technique);
	found_something+=(int)o.assign_if_present("experiment_name",experiment_name);
	found_something+=(int)o.assign_if_present("sample_name",sample_name);
	found_something+=(int)o.assign_if_present("region_name",region_name);
	found_something+=(int)o.assign_if_present("strain",strain);
	found_something+=(int)o.assign_if_present("strain_condition_1",strain_condition_1);
	found_something+=(int)o.assign_if_present("strain_condition_2",strain_condition_2);
	found_something+=(int)o.assign_if_present("culturing_temperature",culturing_temperature);
	found_something+=(int)o.assign_if_present("experiment_temperature",experiment_temperature);
	found_something+=(int)o.assign_if_present("food_source",food_source);
	found_something+=(int)o.assign_if_present("environmental_conditions",environmental_conditions);

	found_something+=(int)o.assign_if_present("genotype",genotype);
	found_something+=(int)o.assign_if_present("details",details);
	found_something+=(int)o.assign_if_present("analysis_type",analysis_type);
	region_id = 0;
	found_something+=(int)o.assign_if_present("region_id",region_id);
	return found_something > 0;
}

void ns_survival_data_summary::from_xml(const ns_xml_simple_object & o){
	if (o.name !=  xml_tag())
		throw ns_ex("ns_survival_data_summary::from_xml()::Unknown object type: " ) << o.name;
	if (!metadata.from_xml(o))
		throw ns_ex("ns_survival_data_summary::from_xml()::Could not load any metadata for the specified data");

	o.assign_if_present("ldc",		long_distance_movement_cessation.count);
	o.assign_if_present("ldbcc",	long_distance_movement_cessation.by_hand_excluded_count);
	o.assign_if_present("ldmcc",	long_distance_movement_cessation.machine_excluded_count);
	o.assign_if_present("ldcs",	long_distance_movement_cessation.censored_count);
	o.assign_if_present("ldmw",		long_distance_movement_cessation.number_of_events_involving_multiple_worm_disambiguation);
	o.assign_if_present("ldm",		long_distance_movement_cessation.mean );
	o.assign_if_present("ldv",		long_distance_movement_cessation.variance);
	o.assign_if_present("ldp10",	long_distance_movement_cessation.percentile_10th);
	o.assign_if_present("ldp50",	long_distance_movement_cessation.percentile_50th );
	o.assign_if_present("ldp90",	long_distance_movement_cessation.percentile_90th);
	o.assign_if_present("ldmin",	long_distance_movement_cessation.minimum );
	o.assign_if_present("ldmax",	long_distance_movement_cessation.maximum );
	
	o.assign_if_present("loc",		local_movement_cessation.count);
	o.assign_if_present("lobcc",	local_movement_cessation.by_hand_excluded_count);
	o.assign_if_present("lomcc",	local_movement_cessation.machine_excluded_count);
	o.assign_if_present("locs",	local_movement_cessation.censored_count);
	o.assign_if_present("lomw",	local_movement_cessation.number_of_events_involving_multiple_worm_disambiguation);
	o.assign_if_present("lom",		local_movement_cessation.mean );
	o.assign_if_present("lov",		local_movement_cessation.variance );
	o.assign_if_present("lop10",	local_movement_cessation.percentile_10th);
	o.assign_if_present("lop50",	local_movement_cessation.percentile_50th );
	o.assign_if_present("lop90",	local_movement_cessation.percentile_90th);
	o.assign_if_present("lomin",	local_movement_cessation.minimum);
	o.assign_if_present("lomax",	local_movement_cessation.maximum);


	o.assign_if_present("dc",		death.count);
	o.assign_if_present("dmcc",		death.machine_excluded_count);
	o.assign_if_present("dbcc",		death.by_hand_excluded_count);
	o.assign_if_present("dcs",		death.censored_count);
	o.assign_if_present("dmw",		death.number_of_events_involving_multiple_worm_disambiguation);
	o.assign_if_present("dm",		death.mean);
	o.assign_if_present("dv",		death.variance );
	o.assign_if_present("dp10",		death.percentile_10th);
	o.assign_if_present("dp50",		death.percentile_50th );
	o.assign_if_present("dp90",		death.percentile_90th );
	o.assign_if_present("dmin",		death.minimum );
	o.assign_if_present("dmax",		death.maximum);
}

std::string ns_survival_data_summary::to_xml() const{
	ns_xml_simple_writer xml;
	xml.start_group( xml_tag());
	xml.add_raw(metadata.to_xml());

	xml.add_tag("ldc",		long_distance_movement_cessation.count);
	xml.add_tag("ldbcc",	long_distance_movement_cessation.by_hand_excluded_count);
	xml.add_tag("ldmcc",	long_distance_movement_cessation.machine_excluded_count);
	xml.add_tag("ldcs",		long_distance_movement_cessation.censored_count);
	xml.add_tag("ldmw",		long_distance_movement_cessation.number_of_events_involving_multiple_worm_disambiguation);
	xml.add_tag("ldm",		long_distance_movement_cessation.mean );
	xml.add_tag("ldv",		long_distance_movement_cessation.variance);
	xml.add_tag("ldp10",	long_distance_movement_cessation.percentile_10th);
	xml.add_tag("ldp50",	long_distance_movement_cessation.percentile_50th );
	xml.add_tag("ldp90",	long_distance_movement_cessation.percentile_90th);
	xml.add_tag("ldmin",	long_distance_movement_cessation.minimum );
	xml.add_tag("ldmax",	long_distance_movement_cessation.maximum );
	
	xml.add_tag("loc",		local_movement_cessation.count);
	xml.add_tag("lomcc",	local_movement_cessation.machine_excluded_count);
	xml.add_tag("lobcc",	local_movement_cessation.by_hand_excluded_count);
	xml.add_tag("locs",		local_movement_cessation.censored_count);
	xml.add_tag("lomw",		local_movement_cessation.number_of_events_involving_multiple_worm_disambiguation);
	xml.add_tag("lom",		local_movement_cessation.mean );
	xml.add_tag("lov",		local_movement_cessation.variance );
	xml.add_tag("lop10",	local_movement_cessation.percentile_10th);
	xml.add_tag("lop50",	local_movement_cessation.percentile_50th );
	xml.add_tag("lop90",	local_movement_cessation.percentile_90th);
	xml.add_tag("lomin",	local_movement_cessation.minimum);
	xml.add_tag("lomax",	local_movement_cessation.maximum);


	xml.add_tag("dc",		death.count);
	xml.add_tag("dmcc",		death.machine_excluded_count);
	xml.add_tag("dbcc",		death.by_hand_excluded_count);
	xml.add_tag("dcs",		death.censored_count);
	xml.add_tag("dmw",		death.number_of_events_involving_multiple_worm_disambiguation);
	xml.add_tag("dm",		death.mean);
	xml.add_tag("dv",		death.variance );
	xml.add_tag("dp10",	death.percentile_10th);
	xml.add_tag("dp50",	death.percentile_50th );
	xml.add_tag("dp90",	death.percentile_90th );
	xml.add_tag("dmin",	death.minimum );
	xml.add_tag("dmax",	death.maximum);
	xml.end_group();
	return xml.result();
}

void ns_survival_data_quantities::out_jmp_header(const std::string & type, std::ostream & o, const std::string & terminator){
	o << type << " Mean,"<< type << " Variance," << type << " Coefficient of Variation,"
		<< type << " Count," << type << " Machine Exclusion Count," << type << " By Hand Exclusion Count," << type << " Censored Count,"
		#ifdef NS_OUTPUT_MULTIWORM_STATS
		<< type << " Number of Events Originating as Mutliple Worm Disambiguation Events, "
		#endif
		<< type << " 10th Percentile,"<< type << " 50th Percentile,"<< type << " 90th Percentile,"
		<< type << " 90-10 Interdecile Range," << type << " Normalized Interdecile Range,"
		<< type << " Maximum,"<< type << " Minimum" << terminator;
}
void ns_survival_data_quantities::out_jmp_data(const ns_region_metadata & metadata, std::ostream & o, const std::string & terminator) const{

	o << (mean-metadata.time_at_which_animals_had_zero_age)/(60*60*24) <<"," 
		<< variance/((60.0*60*24)*(60*60*24)) <<"," 
		<< (((mean-metadata.time_at_which_animals_had_zero_age)!=0)?(variance/(mean-metadata.time_at_which_animals_had_zero_age)):0) << ","
		<< count << "," 
		<< machine_excluded_count << "," 
		<< by_hand_excluded_count << "," 
		<< censored_count << "," 
		#ifdef NS_OUTPUT_MULTIWORM_STATS
		<< number_of_events_involving_multiple_worm_disambiguation << ","
		#endif
		<< (percentile_10th-metadata.time_at_which_animals_had_zero_age)/(60*60*24) << "," 
		<< (percentile_50th-metadata.time_at_which_animals_had_zero_age)/(60*60*24) << "," 
		<< (percentile_90th-metadata.time_at_which_animals_had_zero_age)/(60*60*24) << ","
		<< (percentile_90th-percentile_10th)/(60*60*24) << ","
		<< (((percentile_50th-metadata.time_at_which_animals_had_zero_age)!=0)?
			((percentile_90th-percentile_10th)/(percentile_50th-metadata.time_at_which_animals_had_zero_age)):0) << ","
		<<(maximum-metadata.time_at_which_animals_had_zero_age)/(60*60*24) << "," 
		<< (minimum-metadata.time_at_which_animals_had_zero_age)/(60*60*24) << terminator;
}


void ns_survival_data_quantities::out_blank_jmp_data(std::ostream & o, const std::string & terminator){
	o  <<"," 
		 "," 
		 "," 
		 "," 
		 "," 
		 "," 
		 ","
		 "," 
		 << terminator;
}

void ns_survival_data_summary::out_jmp_header(const std::string & label,std::ostream & o, const std::string & terminator){
	ns_survival_data_quantities::out_jmp_header(std::string("Death (") + label + ")",o,",");
	ns_survival_data_quantities::out_jmp_header(std::string("Long Distance Movement Cessation (") + label + ")",o,",");
	ns_survival_data_quantities::out_jmp_header(std::string("Local Movement Cessation (") + label + ")",o,terminator);
}

void ns_survival_data_summary::out_jmp_data(std::ostream & o, const std::string & terminator) const{
	death.out_jmp_data(metadata,o,",");
	long_distance_movement_cessation.out_jmp_data(metadata,o,",");
	local_movement_cessation.out_jmp_data(metadata,o,terminator);
}


void ns_survival_data_summary::out_blank_jmp_data(std::ostream & o, const std::string & terminator){
	ns_survival_data_quantities::out_blank_jmp_data(o,",");
	ns_survival_data_quantities::out_blank_jmp_data(o,",");
	ns_survival_data_quantities::out_blank_jmp_data(o,terminator);
}

void ns_lifespan_experiment_set::output_xml_summary_file(std::ostream & o) const{
	ns_xml_simple_writer xml;
	xml.add_header();
	for (unsigned int i = 0; i < curves.size(); i++){
		ns_survival_data_summary s(curves[i].produce_summary());
		xml.add_raw(s.to_xml());
	}
	xml.add_footer();
	o << xml.result();
}
void ns_lifespan_experiment_set::output_JMP_summary_file(std::ostream & o) const{
	//ns_region_metadata::out_JMP_plate_identity_header(o);
	ns_survival_data_summary::out_jmp_header("",o,"\n");

	for (unsigned int i = 0; i < curves.size(); i++){
		ns_survival_data_summary s(curves[i].produce_summary());
	//	curves[i].metadata.out_JMP_plate_identity_data(o);
		s.out_jmp_data(o);
	}
}

const ns_survival_timepoint_event & ns_get_correct_event(const unsigned long i, const ns_survival_timepoint & e){
	switch(i){
		case 0: return e.deaths;
		case 1: return e.local_movement_cessations;
		case 2: return e.long_distance_movement_cessations;
		default: throw ns_ex("ns_get_correct_event()::Unknown event spec");
	}
}

double ns_lifespan_device_normalization_statistics::calculate_additive_device_regression_residual(const double measurement) const{
	if (this->external_fix_point_specified())
		return measurement - additive_device_regression_coefficient - grand_strain_mean + control_mean_external_fix_point;
	return measurement - additive_device_regression_coefficient;
}
double ns_lifespan_device_normalization_statistics::calculate_multiplicative_device_regression_residual(const double measurement) const{
	if (this->external_fix_point_specified())
		return measurement/multiplicative_device_regression_coefficient/grand_strain_mean*control_mean_external_fix_point;
	return measurement/multiplicative_device_regression_coefficient;
}
double ns_lifespan_device_normalization_statistics::calculate_multiplicative_device_regression_residual_additive_offset(const double measurement) const{
	if (external_fix_point_specified())
	return (measurement-multiplicative_additive_device_regression_additive_coefficient)/multiplicative_additive_device_regression_multiplicative_coefficient
			+ control_mean_external_fix_point;

	return 
		(measurement-multiplicative_additive_device_regression_additive_coefficient)/multiplicative_additive_device_regression_multiplicative_coefficient
			+ grand_strain_mean;
}
void ns_lifespan_experiment_set::out_JMP_header(std::ostream & o, const std::string & time_units,const std::string & terminator){
	ns_region_metadata::out_JMP_plate_identity_header(o);
	o << ",Event Frequency,"
		 "Age at Death (" << time_units << ") Raw,"
		 "Age at Death (" << time_units << ") Additive Regression Model Residuals,"
		 "Age at Death (" << time_units << ") Multiplicative Regression Model Residuals,"
		 "Age at Death (" << time_units << ") Multiplicative + Additive offset Regression Model Residuals,"
		"Censored,Excluded, Event Type,Technique,Analysis Type,Flags,"
	#ifdef NS_OUTPUT_MULTIWORM_STATS
	"Originated as a Mutliworm Disambiguation Result,"
	#endif 
	"Details" << terminator;
}


void ns_lifespan_experiment_set::out_JMP_event_data(std::ostream & o,  const ns_lifespan_device_normalization_statistics * regression_stats,const ns_region_metadata & metadata,const ns_metadata_worm_properties & prop,const double time_scaling_factor,const std::string & terminator){
		
		metadata.out_JMP_plate_identity_data(o);
		 o << "," << prop.event_frequency << ","
		<< prop.event_time/time_scaling_factor << ",";
		if (regression_stats == 0)
			o << ",,,";
		else {
			o << regression_stats->calculate_additive_device_regression_residual(prop.event_time)/time_scaling_factor << ",";
			if (regression_stats->multiplicative_device_regression_coefficient != 0)
				o << regression_stats->calculate_multiplicative_device_regression_residual(prop.event_time)/time_scaling_factor << ",";
			else o << ",";
			if(regression_stats->multiplicative_additive_device_regression_multiplicative_coefficient  != 0){
				o << regression_stats->calculate_multiplicative_device_regression_residual_additive_offset(prop.event_time)/time_scaling_factor << ",";
			}
			else o << ",";
		}
		o << (prop.censoring_and_flags.is_censored()?"1":"0") << ","
		 << (prop.censoring_and_flags.is_excluded()?ns_death_time_annotation::exclusion_value(prop.censoring_and_flags.excluded):0) <<","
		 << ns_metadata_worm_properties::event_type_to_string(prop.event_type) << ","
		 << metadata.technique << ","
		 << metadata.analysis_type << ","
		 << prop.censoring_and_flags.flag.label() << ","
			#ifdef NS_OUTPUT_MULTIWORM_STATS
		 << (prop.censoring_and_flags.disambiguation_type != ns_death_time_annotation::ns_single_worm?"1":"0") << ","
			#endif
		 << metadata.details << terminator;
	}

void ns_genotype_fetcher::add_information_to_database(const std::vector<ns_genotype_db_info> & info,ns_image_server_sql * sql){
	load_from_db(sql,true);
	for (unsigned int i = 0; i < info.size(); i++){
		ns_genotype_list::iterator p = genotypes.find(info[i].strain);
		if (p == genotypes.end()){
			*sql << "INSERT INTO strain_aliases SET strain='" << sql->escape_string(info[i].strain) << "', genotype='" << sql->escape_string(info[i].genotype) << "'";
			//cout << sql->query() << "\n";
			sql->send_query();
		}
		else{
			if (p->second.genotype == info[i].genotype)
				continue;
			*sql << "UPDATE strain_aliases SET  strain='" << sql->escape_string(info[i].strain) << "', genotype='" << sql->escape_string(info[i].genotype) << "'" <<
				" WHERE id = " << p->second.id;
		//	cout << sql->query() << "\n";
			sql->send_query();
		}
	}
}
void ns_lifespan_experiment_set::output_JMP_file(const ns_time_units & time_units,std::ostream & o) const{
	std::string time_unit_string;
	double time_scaling_factor;
	switch(time_units){
		case ns_seconds:
			time_unit_string = "s";
			time_scaling_factor = 1;
			break;
		case ns_minutes:
			time_unit_string = "m";
			time_scaling_factor = 60;
			break;
		case ns_hours:
			time_unit_string = "h";
			time_scaling_factor = 60*60;
			break;
		case ns_days:
			time_unit_string = "d";
			time_scaling_factor = 24*60*60;
			break;
		default: throw ns_ex("ns_lifespan_experiment_set::output_JMP_file::Invalid time unit type:") << (int)time_units;
	}
	out_JMP_header(o,time_unit_string,"\n");
	
	ns_metadata_worm_properties::ns_survival_event_type event_type[3] = {ns_metadata_worm_properties::ns_death, 
																ns_metadata_worm_properties::ns_local_movement_cessation, 
																ns_metadata_worm_properties::ns_long_distance_movement_cessation
																};
	for (unsigned int event_t = 0; event_t < 3; event_t++){
		
		const ns_lifespan_device_normalization_statistics_set & normalization_stats((
			(event_type[event_t] == ns_metadata_worm_properties::ns_death)? normalization_stats_for_death:
				(
					((event_type[event_t] == ns_metadata_worm_properties::ns_local_movement_cessation)?
													normalization_stats_for_translation_cessation:
													normalization_stats_for_fast_movement_cessation)
														)
														)
														);
		
		const bool output_regression_parameters(!normalization_stats.devices.empty());
		
		for (unsigned int i = 0; i < curves.size(); i++){
			
			const ns_lifespan_device_normalization_statistics * regression_stats(0);
			
			if (output_regression_parameters){
				ns_lifespan_device_normalization_statistics_set::ns_device_stats_list::const_iterator d(normalization_stats.devices.find(curves[i].metadata.device));
				if (d == normalization_stats.devices.end())
					throw ns_ex("Could not find normalization stats for device");
				if (d->second.control_specified())
					regression_stats = d->second.control_strain;
			}

			for (unsigned int j = 0; j < curves[i].timepoints.size(); ++j){
		
				const ns_survival_timepoint_event & e(ns_get_correct_event(event_t,curves[i].timepoints[j]));
				if (e.number_in_event_count_that_came_from_multiple_worm_disambiguation_events > e.event_count)
					throw ns_ex("Encountered a multiworm count larger than the event count!");
				if (e.event_count < e.number_in_event_count_that_came_from_multiple_worm_disambiguation_events)
					throw ns_ex("Found an invalid multi-worm disambiguation count!");
				
				bool data_to_output(false);
				ns_metadata_worm_properties p;
				p.event_time =  curves[i].timepoints[j].absolute_time-curves[i].metadata.time_at_which_animals_had_zero_age;
				p.event_type = event_type[event_t];

				if (e.event_count-e.number_in_event_count_that_came_from_multiple_worm_disambiguation_events > 0){
					p.event_frequency = e.event_count-e.number_in_event_count_that_came_from_multiple_worm_disambiguation_events;
					p.censoring_and_flags = ns_death_time_annotation();
					data_to_output = true;
					
				}

				if (e.number_in_event_count_that_came_from_multiple_worm_disambiguation_events > 0){
					
					p.event_frequency = e.number_in_event_count_that_came_from_multiple_worm_disambiguation_events;
					p.censoring_and_flags = ns_death_time_annotation();
					p.censoring_and_flags.disambiguation_type = ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster;
					p.censoring_and_flags.excluded = ns_death_time_annotation::ns_machine_excluded;
					data_to_output = true;
				}

				if (e.by_hand_excluded_event_count> 0){
				
					p.event_frequency = e.by_hand_excluded_event_count;
					p.censoring_and_flags = ns_death_time_annotation();
					p.censoring_and_flags.excluded = ns_death_time_annotation::ns_by_hand_excluded;
					data_to_output = true;
				}
				if (e.machine_excluded_event_count> 0){
					p.event_frequency = e.machine_excluded_event_count;
					p.censoring_and_flags = ns_death_time_annotation();
					p.censoring_and_flags.excluded = ns_death_time_annotation::ns_machine_excluded;
					data_to_output = true;
				}	
				if (e.censored_count > 0){
				
					p.event_frequency = e.censored_count;
					p.censoring_and_flags = ns_death_time_annotation();
					p.censoring_and_flags.excluded = ns_death_time_annotation::ns_censored;
					data_to_output = true;
				}
				if (e.multiple_conflated_animal_event_count > 0){
					
					p.event_frequency = e.multiple_conflated_animal_event_count;
					p.censoring_and_flags = ns_death_time_annotation();
					p.censoring_and_flags.excluded = ns_death_time_annotation::ns_machine_excluded;
					p.censoring_and_flags.disambiguation_type = ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster;
					data_to_output = true;
				}
				if (data_to_output)
					out_JMP_event_data(o,regression_stats,curves[i].metadata,p,time_scaling_factor);
			}
		}
	}
}
void ns_lifespan_experiment_set::output_matlab_file(std::ostream & out) const{
	const string line_span("...");
	unsigned max_t;
	if (set_is_on_common_time()){
		max_t = common_time().size();
		out << "t= [";
		for (unsigned int i = 0; i < common_time().size(); ++i){
			if (i%100 == 0) out << line_span << "\n";
			out << common_time()[i] << " ";
		}
		out << line_span << "\n];\n\n";
	}
	else{
		
		max_t=0;
		for (unsigned int i = 0; i < curves.size(); i++){
			if (curves[i].timepoints.size() > max_t)
				max_t = curves[i].timepoints.size();
		}
		out << "t= [";

		for (unsigned int i = 0; i < curves.size(); i++){
			out << "[";
			for (unsigned int j = 0; j < curves[i].timepoints.size(); j++){
				out << curves[i].timepoints[j].absolute_time << " ";
				if (j%100 == 0) out << line_span << "\n";
			}
			for (unsigned j = curves[i].timepoints.size(); j < max_t; j++){
				out <<  curves[i].timepoints[curves[i].timepoints.size()-1].absolute_time + j - curves[i].timepoints.size() << " ";
				if (j%100 == 0) out << line_span << "\n";
			}
			out << "]; " << line_span << "\n";
		}
		out << "];\n\n";
	}



	out << "survival = [";
	for (unsigned int i = 0; i < curves.size(); i++){
		//out << "diestributions{" << i+1 << "} = [";
		out << "[";
		for (unsigned int j = 0; j < curves[i].timepoints.size(); j++){
			out << curves[i].timepoints[j].deaths.survival_count << " ";
			if (j%100==0) out << line_span << "\n";
		}

		for (unsigned j = curves[i].timepoints.size(); j < max_t; j++){
			out << "NaN ";
			if (j%100==0) out << line_span << "\n";
		}
		out << "]; " << line_span << "\n";
	}
	out << "];\n";

	out << "survival_normalized = [";
	for (unsigned int i = 0; i < curves.size(); i++){
		//out << "diestributions{" << i+1 << "} = [";
		out << "[";
		float base(curves[i].timepoints[0].deaths.survival_count);
		if (base == 0) base = 1;
		for (unsigned int j = 0; j < curves[i].timepoints.size(); j++){
			out << curves[i].timepoints[j].deaths.survival_count/base << " ";
			if (j%100==0) out << line_span << "\n";
		}

		for (unsigned j = curves[i].timepoints.size(); j < max_t; j++){
			out << "NaN ";
			if (j%100==0) out << line_span << "\n";
		}
		out << "]; " << line_span << "\n";
	}
	out << "];\n";

	out << "mortality = [";
	for (unsigned int i = 0; i < curves.size(); i++){
		//out << "diestributions{" << i+1 << "} = [";
		out << "[";
		for (unsigned int j = 0; j < curves[i].timepoints.size(); j++){
			out << curves[i].timepoints[j].deaths.event_count << " ";
			if (j%100==0) out << line_span << "\n";
		}

		for (unsigned j = curves[i].timepoints.size(); j < max_t; j++){
			out << "NaN ";
			if (j%100==0) out << line_span << "\n";
		}
		out << "]; " << line_span << "\n";
	}
	out << "];\n";

	out << "mortality_normalized = [";
	for (unsigned int i = 0; i < curves.size(); i++){
		//out << "diestributions{" << i+1 << "} = [";
		out << "[";
		float base(curves[i].timepoints[0].deaths.event_count);
		if (base == 0) base = 1;
		for (unsigned int j = 0; j < curves[i].timepoints.size(); j++){
			out << curves[i].timepoints[j].deaths.event_count/base << " ";
			if (j%100==0) out << line_span << "\n";
		}

		for (unsigned j = curves[i].timepoints.size(); j < max_t; j++){
			out << "NaN ";
			if (j%100==0) out << line_span << "\n";
		}
		out << "]; " << line_span << "\n";
	}
	out << "];\n";

	out << "long_distance_movement_span_normalized = [";
	for (unsigned int i = 0; i < curves.size(); i++){
		//out << "diestributions{" << i+1 << "} = [";
		out << "[";
		float base(curves[i].timepoints[0].long_distance_movement_cessations.event_count);
		if (base == 0) base = 1;
		for (unsigned int j = 0; j < curves[i].timepoints.size(); j++){
			out << curves[i].timepoints[j].long_distance_movement_cessations.event_count/base << " ";
			if (j%100==0) out << line_span << "\n";
		}
		for (unsigned j = curves[i].timepoints.size(); j < max_t; j++){
			out << "NaN ";
			if (j%100==0) out << line_span << "\n";
		}
		out << "]; " << line_span << "\n";
	}
	out << "];\n";

	out << "local_movement_span_normalized = [";
	for (unsigned int i = 0; i < curves.size(); i++){
		//out << "diestributions{" << i+1 << "} = [";
		out << "[";
		float base(curves[i].timepoints[0].local_movement_cessations.event_count);
		if (base == 0) base = 1;
		for (unsigned int j = 0; j < curves[i].timepoints.size(); j++){
			out << curves[i].timepoints[j].local_movement_cessations.event_count/base << " ";
			if (j%100==0) out << line_span << "\n";
		}
		for (unsigned j = curves[i].timepoints.size(); j < max_t; j++){
			out << "NaN ";
			if (j%100==0) out << line_span << "\n";
		}
		out << "]; " << line_span << "\n";
	}
	out << "];\n";

		
	out << "time_at_which_animals_had_zero_age= [";
	for (unsigned int i = 0; i < curves.size(); i++){
		out << curves[i].metadata.time_at_which_animals_had_zero_age << " ";
		if (i%100==0) out << line_span << "\n";
	}
	out << "];\n\n";

	out << "strain = {";
	for (unsigned int i = 0; i < curves.size(); i++){
		out << "'" << curves[i].metadata.strain << "', " << line_span << "\n";
	}
	out << "};\n\n";	

	out << "genotype = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.genotype << "', " << line_span << "\n";
	out << "};\n\n";

	out << "experiment_name = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.experiment_name << "', " << line_span << "\n";
	out << "};\n\n";

	out << "analysis_type = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.analysis_type << "', " << line_span << "\n";
	out << "};\n\n";	
	
	out << "technique = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.technique << "', " << line_span << "\n";
	out << "};\n\n";

	out << "details = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.details << "', " << line_span << "\n";
	out << "};\n\n";	
	out << "strain_condition_1 = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.strain_condition_1 << "', " << line_span << "\n";
	out << "};\n\n";	
	out << "strain_condition_2 = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.strain_condition_2 << "', " << line_span << "\n";
		out << "strain_condition_3 = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.strain_condition_3 << "', " << line_span << "\n";
		out << "culturing_temperature = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.culturing_temperature << "', " << line_span << "\n";
		out << "experiment_temperature = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.experiment_temperature << "', " << line_span << "\n";
		out << "food_source = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.food_source  << "', " << line_span << "\n";
		out << "environmental_conditions = {";
	for (unsigned int i = 0; i < curves.size(); i++)
		out << "'" << curves[i].metadata.environmental_conditions << "', " << line_span << "\n";
	out << "};\n\n";
}

void ns_survival_data::calculate_survival(){
	if (timepoints.size() == 0)
		return;
	timepoints.rbegin()->deaths.survival_count = 0;
	timepoints.rbegin()->local_movement_cessations.survival_count = 0;
	timepoints.rbegin()->long_distance_movement_cessations.survival_count = 0;
	for (long i = timepoints.size()-1; i > 0; --i){
		timepoints[i-1].deaths.survival_count = timepoints[i].deaths.survival_count + timepoints[i].deaths.event_count;
		timepoints[i-1].local_movement_cessations.survival_count= timepoints[i].local_movement_cessations.survival_count+ timepoints[i].local_movement_cessations.event_count;
		timepoints[i-1].long_distance_movement_cessations.survival_count= timepoints[i].long_distance_movement_cessations.survival_count + timepoints[i].long_distance_movement_cessations.event_count;
	}
}

void ns_lifespan_experiment_set::load_genotypes(ns_sql & sql){
	ns_genotype_fetcher fetcher;
	fetcher.load_from_db(&sql);
	for (unsigned int i = 0; i < curves.size(); ++i)
		curves[i].metadata.genotype = fetcher.genotype_from_strain(curves[i].metadata.strain,&sql);
	
}
void ns_lifespan_experiment_set::calculate_survival(){
	for (unsigned int i = 0; i < curves.size(); ++i)
		curves[i].calculate_survival();
}

void ns_lifespan_experiment_set::generate_common_time_set(ns_lifespan_experiment_set & new_set) const{

	//build up a list of all sample times and the curves that were measured at those times
	//std::map<a, std::vector< pair<b,c> > >
	//a: the time at which the sample was taken
	//b: std::vector<> a list of measurements taken for that time
	//c: the index of the strain in ex.curves[] of the experiment who's sample was taken
	//d: the index of the sample data in ex.curves[c].survival that records the result
	//   of the sample.
	new_set.clear();
	if (curves.size() == 0)
		return;
	std::set<unsigned long> all_points;
	for (unsigned int i = 0; i < curves.size(); i++){
		for (unsigned int j = 0; j < curves[i].timepoints.size(); j++){
			all_points.insert(all_points.begin(),curves[i].timepoints[j].absolute_time);
		}
	}
	new_set.curves.resize(curves.size());
	new_set.common_time_.resize(all_points.size());
	{
		unsigned long t(0);
		for (std::set<unsigned long>::iterator p = all_points.begin(); p != all_points.end(); p++){
			new_set.common_time()[t] = (*p);
			t++;
		}
	}
	for (unsigned int i = 0; i < curves.size(); i++){
		new_set.curves[i].timepoints.resize(new_set.common_time().size());
		for (unsigned int j = 0; j < curves[i].timepoints.size(); j++)
			new_set.curves[i].timepoints[j].absolute_time = new_set.common_time()[j];
		new_set.curves[i].metadata = curves[i].metadata;
	}
	
	for (unsigned int i = 0; i < curves.size(); i++){
		
		unsigned long new_curve_i(0);
		for (unsigned int old_curve_i = 0; old_curve_i < curves[i].timepoints.size(); old_curve_i++){
			while (new_curve_i < new_set.common_time().size()
					&& curves[i].timepoints[old_curve_i].absolute_time > new_set.common_time()[new_curve_i]){
					++new_curve_i;
			}

				
			if (new_curve_i > new_set.common_time().size())
				throw ns_ex("ns_lifespan_experiment_set::generate_common_time_set()::Found an event in curve # ") << i << "[" << old_curve_i << "] that occurred after the final timepoitn of the common time set";
			if (curves[i].timepoints[old_curve_i].absolute_time != new_set.common_time()[new_curve_i])
				throw ns_ex("ns_lifespan_experiment_set::generate_common_time_set()::Found an event in curve # ") << i << "[" << old_curve_i << "] that occurred at a time not included in the common time set";
			
			new_set.curves[i].timepoints[new_curve_i] = curves[i].timepoints[old_curve_i];
		}
	}
}


ns_survival_timepoint_event operator+(const ns_survival_timepoint_event & a, const ns_survival_timepoint_event & b){
	ns_survival_timepoint_event e(a);
	e.machine_excluded_event_count += b.machine_excluded_event_count;
	e.by_hand_excluded_event_count += b.by_hand_excluded_event_count;
	e.censored_count += b.censored_count;
	e.event_count += b.event_count;
	e.multiple_conflated_animal_event_count += b.multiple_conflated_animal_event_count;
	e.number_in_event_count_that_came_from_multiple_worm_disambiguation_events += b.number_in_event_count_that_came_from_multiple_worm_disambiguation_events;
	e.survival_count += b.survival_count;
	return e;
}
ns_survival_timepoint operator+(const ns_survival_timepoint & a, const ns_survival_timepoint & b){
	ns_survival_timepoint ret;
	ret.absolute_time = (a.absolute_time>b.absolute_time)?a.absolute_time:b.absolute_time;
	ret.deaths = a.deaths + b.deaths;
	ret.local_movement_cessations = a.local_movement_cessations + b.local_movement_cessations;
	ret.long_distance_movement_cessations = a.long_distance_movement_cessations + b.long_distance_movement_cessations;
	return ret;
}

void ns_lifespan_experiment_set::force_common_time_set_to_constant_time_interval(const unsigned long interval_time_in_seconds,ns_lifespan_experiment_set & new_set) const{
	if (!set_is_on_common_time())
		throw ns_ex("ns_lifespan_experiment_set::force_common_time_set_to_constant_time_interval()::Constant time intervals can only be set for experiment sets on a common time interval");
	
	if (interval_time_in_seconds == 0)
		throw ns_ex("ns_lifespan_experiment_set::force_common_time_set_to_constant_time_interval()::Cannot set constant time interval to zero!");
	
	new_set.clear();
	if (curves.size() == 0)
		return;

	unsigned long start_time = common_time()[0];
	unsigned long stop_time = common_time()[common_time().size()-1];
	unsigned long number_of_points = (stop_time - start_time)/interval_time_in_seconds + 1;
	
	new_set.common_time_.resize(number_of_points);
	for (unsigned int i = 0; i < new_set.common_time().size(); ++i)
		new_set.common_time()[i] = start_time+interval_time_in_seconds*i;
	
	new_set.curves.resize(0);
	new_set.curves.resize(curves.size());	
	for (unsigned int i = 0; i < curves.size(); ++i){
		new_set.curves[i].timepoints.resize(number_of_points);
		new_set.curves[i].metadata = curves[i].metadata;

		unsigned long old_curve_i = 0;
		
		for (std::vector<unsigned long>::size_type new_curve_i = 0; new_curve_i < new_set.common_time().size(); ++new_curve_i){
			new_set.curves[i].timepoints[new_curve_i].absolute_time = new_set.common_time()[new_curve_i];
			if (old_curve_i >= curves[i].timepoints.size() || curves[i].timepoints[old_curve_i].absolute_time > new_set.common_time()[new_curve_i])
				continue;

			ns_survival_timepoint events_that_have_occurred;
			for(;old_curve_i < curves[i].timepoints.size() &&
				curves[i].timepoints[old_curve_i].absolute_time < new_set.common_time()[new_curve_i];old_curve_i++){
					if (new_curve_i==0)
						throw ns_ex("Found events before first event in new curve!");
				events_that_have_occurred=events_that_have_occurred + curves[i].timepoints[old_curve_i];
			}
			if (new_curve_i==0)
				continue;
			events_that_have_occurred.absolute_time = new_set.common_time()[new_curve_i-1];
			new_set.curves[i].timepoints[new_curve_i-1] = events_that_have_occurred;
		}
		new_set.curves[i].calculate_survival();
	}
	new_set.curves_on_constant_time_interval = true;
	new_set.normalization_stats_for_death = normalization_stats_for_death;
	new_set.normalization_stats_for_fast_movement_cessation = normalization_stats_for_fast_movement_cessation;
	new_set.normalization_stats_for_translation_cessation = normalization_stats_for_translation_cessation;
}
void ns_survival_data_quantities::add(const ns_survival_data_quantities & s){
	count += s.count;
	number_of_events_involving_multiple_worm_disambiguation += s.number_of_events_involving_multiple_worm_disambiguation;
	by_hand_excluded_count += s.by_hand_excluded_count;
	machine_excluded_count += s.machine_excluded_count;
	censored_count += s.censored_count;
	mean += s.mean;
	variance += s.variance;
	percentile_90th += s.percentile_90th;
	percentile_50th += s.percentile_50th;
	percentile_10th += s.percentile_10th;
	if (s.maximum > maximum)
		maximum = s.maximum;	
	if (s.minimum < minimum)
		minimum= s.minimum;
}
void ns_survival_data_summary::add(const ns_survival_data_summary & s){
	death.add(s.death);
	local_movement_cessation.add(s.local_movement_cessation);
	long_distance_movement_cessation.add(s.long_distance_movement_cessation);
}
struct ns_death_stat_key{
	ns_death_stat_key(const ns_death_stat_key & key){
		*this = key;
	}
	ns_death_stat_key(const ns_region_metadata & m):metadata(m){}

	ns_region_metadata metadata;
};
bool operator<(const ns_death_stat_key & a, const ns_death_stat_key & b){
	if (a.metadata.device != b.metadata.device) return a.metadata.device < b.metadata.device;
	if (a.metadata.technique != b.metadata.technique) return a.metadata.technique < b.metadata.technique;
	if (a.metadata.strain != b.metadata.strain) return a.metadata.strain < b.metadata.strain;
	if (a.metadata.strain_condition_1 != b.metadata.strain_condition_1) return a.metadata.strain_condition_1 < b.metadata.strain_condition_1;
	//if (a.metadata.strain_condition_2 != b.metadata.strain_condition_2)
	return a.metadata.strain_condition_2 < b.metadata.strain_condition_2;
	/*if (a.metadata.strain_condition_3 != b.metadata.strain_condition_3) return a.metadata.strain_condition_3 < b.metadata.strain_condition_3;
	if (a.metadata.culturing_temperature != b.metadata.culturing_temperature) return a.metadata.culturing_temperature < b.metadata.culturing_temperature;
	if (a.metadata.experiment_temperature != b.metadata.experiment_temperature) return a.metadata.experiment_temperature < b.metadata.experiment_temperature;
	if (a.metadata.food_source != b.metadata.food_source) return a.metadata.strain_condition_1 < b.metadata.strain_condition_1;
	return a.metadata.environmental_conditions < b.metadata.environmental_conditions;*/
}

struct ns_death_stat{
	ns_death_stat():offset(0),sum(0),count(0),number_of_plates(0){}
	unsigned long offset;
	unsigned long long sum;
	unsigned long count;
	unsigned long number_of_plates;
};

void ns_lifespan_experiment_set::compute_device_normalization_regression( const ns_region_metadata & control_strain){
	compute_device_normalization_regression(ns_translation_cessation, control_strain,normalization_stats_for_translation_cessation);
	compute_device_normalization_regression(ns_movement_cessation, control_strain,normalization_stats_for_death);
	compute_device_normalization_regression(ns_fast_movement_cessation, control_strain,normalization_stats_for_fast_movement_cessation);
}

typedef map<ns_death_stat_key,ns_death_stat> ns_death_stat_list;

void ns_lifespan_experiment_set::compute_device_normalization_regression(const ns_movement_event & event_type,  const ns_region_metadata & control_strain,ns_lifespan_device_normalization_statistics_set & set) const{
	
	//<animal description,death statistics for that strain>
	std::map<std::string,ns_death_stat> strain_grand_statistics;

	//make statistics for each strain on each scanner
	ns_death_stat_list strain_statistics_on_each_device;
	for (std::vector<unsigned long>::size_type i = 0; i < curves.size(); i++){
		if (curves[i].metadata.device.size() == 0)
			throw ns_ex("ns_lifespan_experiment_set::normalize_by_device_mean()::Found an unspecified device name");
		ns_death_stat_list::iterator p= strain_statistics_on_each_device.find(ns_death_stat_key(curves[i].metadata));

		if (p == strain_statistics_on_each_device.end()){
			p = strain_statistics_on_each_device.insert(pair<ns_death_stat_key,ns_death_stat>(curves[i].metadata,ns_death_stat())).first;
			p->second.offset= curves[i].metadata.time_at_which_animals_had_zero_age;
		}	

		std::map<std::string,ns_death_stat>::iterator grand_stats(strain_grand_statistics.find(curves[i].metadata.device_regression_match_description()));

		if (grand_stats == strain_grand_statistics.end()){
			grand_stats = strain_grand_statistics.insert(pair<std::string,ns_death_stat>(curves[i].metadata.device_regression_match_description(),ns_death_stat())).first;
		}

		if (p->second.offset != curves[i].metadata.time_at_which_animals_had_zero_age){
			throw ns_ex("Two plates, ") << p->first.metadata.plate_name() << " and " << curves[i].metadata.plate_name()
				<<", with the same animal type ("
				<< p->first.metadata.plate_type_summary()
				<<";" << curves[i].metadata.plate_type_summary() << ") have different "
				"\"Time At Which Animals Had Zero Age\" values specified: " << 
				p->second.offset << " and " << curves[i].metadata.time_at_which_animals_had_zero_age;
		}
		for (unsigned int j = 0; j < curves[i].timepoints.size(); j++){
			unsigned long int event_count(0);
			switch(event_type){
				case ns_movement_cessation:
					event_count = curves[i].timepoints[j].deaths.event_count;
					break;
				case ns_translation_cessation:
					event_count = curves[i].timepoints[j].local_movement_cessations.event_count;
					break;
				case ns_fast_movement_cessation:
					event_count = curves[i].timepoints[j].long_distance_movement_cessations.event_count;
					break;
				default: throw ns_ex("Unknown normalization event specification: ") << (int)event_type;

			}
			p->second.count  += event_count;
			grand_stats->second.count += event_count;
			p->second.number_of_plates++;
			grand_stats->second.number_of_plates++;

			unsigned long long s(((unsigned long long)event_count)*(curves[i].timepoints[j].absolute_time-p->second.offset));
			p->second.sum+=  s;
			grand_stats->second.sum += s;
		}
	}
	
	set.devices.clear();
	for (ns_death_stat_list::iterator p = strain_statistics_on_each_device.begin(); p!=strain_statistics_on_each_device.end(); ++p){
	//	if (p->second.count!=0)
	//		p->second.sum/=p->second.count;
		ns_lifespan_device_normalization_statistics_set::ns_device_stats_list::iterator q = set.devices.find(p->first.metadata.device);
		if (q == set.devices.end()){
			q = set.devices.insert(
				ns_lifespan_device_normalization_statistics_set::ns_device_stats_list::value_type(
				p->first.metadata.device,ns_lifespan_device_normalization_statistics_for_device())).first;
		}
		ns_lifespan_device_normalization_statistics_for_device::ns_strain_stat_list::iterator r(
			q->second.strains.find(p->first.metadata.device_regression_match_description()));
		if (r == q->second.strains.end()){
			r = q->second.strains.insert(ns_lifespan_device_normalization_statistics_for_device::ns_strain_stat_list::value_type(
				p->first.metadata.device_regression_match_description(),ns_lifespan_device_normalization_statistics())).first;
		}
		else throw ns_ex("Repeat strains found!");
		r->second.device_strain_mean = p->second.sum;
		r->second.device_strain_mean/=p->second.count;
		r->second.number_of_animals_on_device = p->second.count;
		r->second.number_of_plates_on_device = p->second.number_of_plates;
		r->second.strain_info = p->first.metadata;
		//set the control strain
	//	cerr << p->first.metadata.plate_type_summary() << " vs " << control_strain.plate_type_summary() << "\n";
		if (p->first.metadata.is_same_strain_and_first_two_conditions(control_strain)){
			q->second.control_strain = &r->second;
		//	cerr << "\n YES!\n";
		}
	}

	for (std::map<std::string,ns_death_stat>::iterator p = strain_grand_statistics.begin(); p!=strain_grand_statistics.end(); ++p){
		bool found(false);
		for (ns_lifespan_device_normalization_statistics_set::ns_device_stats_list::iterator q = set.devices.begin(); q!=set.devices.end(); ++q){
			
			ns_lifespan_device_normalization_statistics_for_device::ns_strain_stat_list::iterator r(
				q->second.strains.find(p->first));
			if (r == q->second.strains.end())	//the device does not contain any animals of the specified strain
				continue;
			found = true;
			r->second.grand_strain_mean = p->second.sum;
			r->second.grand_strain_mean/=p->second.count;
		}
		if (found == false)
			throw ns_ex("Could not find grand mean stat on any device!");
	}

	//calculate regression parameters.
	//We really aught to link into R and do a propper multiple linear regression
	//using dummy variables to encode the categorical predictor of device names,
	//but it all resolves to doing arithmatic on plate means, so we just do that
	//here for simplicity
	for (ns_lifespan_device_normalization_statistics_set::ns_device_stats_list::iterator p = set.devices.begin(); p!=set.devices.end(); ++p){
		for (ns_lifespan_device_normalization_statistics_for_device::ns_strain_stat_list::iterator q = p->second.strains.begin(); q != p->second.strains.end(); q++){
			q->second.additive_device_regression_coefficient = q->second.device_strain_mean - q->second.grand_strain_mean;
			if (q->second.grand_strain_mean != 0)
				q->second.multiplicative_device_regression_coefficient = q->second.device_strain_mean/q->second.grand_strain_mean;
			else q->second.multiplicative_device_regression_coefficient = 0;
			//don't quite know how to do this one yet.
			q->second.multiplicative_additive_device_regression_additive_coefficient = 0;
			q->second.multiplicative_additive_device_regression_multiplicative_coefficient = 0;
		}
	}
}

void ns_survival_data_summary_aggregator::add(const ns_movement_event normalization_type, const ns_survival_data_summary & summary){
	ns_plate_list::iterator p(plate_list.find(summary.metadata.plate_name()));
	if (p == plate_list.end())
		p = plate_list.insert(ns_plate_list::value_type(summary.metadata.plate_name(),ns_plate_normalization_list())).first;
	ns_plate_normalization_list::iterator q = p->second.find(normalization_type);
	if (q!= p->second.end())
		throw ns_ex("Duplicate specificaiton of region ") << summary.metadata.plate_name() << " with normalization " << ns_movement_event_to_label(normalization_type);
	p->second.insert(ns_plate_normalization_list::value_type(normalization_type,summary));
}

void ns_survival_data_summary_aggregator::add(const ns_movement_event normalization_type,const ns_lifespan_experiment_set & set){
	for (unsigned int i = 0; i < set.curves.size(); i++)
		add(normalization_type,set.curves[i].produce_summary());
}

std::vector<ns_movement_event> ns_survival_data_summary_aggregator::events_to_output;
ns_survival_data_summary_aggregator::ns_survival_data_summary_aggregator(){
	if (events_to_output.empty()){
		events_to_output.push_back(ns_no_movement_event);
		events_to_output.push_back(ns_movement_cessation);
		events_to_output.push_back(ns_translation_cessation);
		events_to_output.push_back(ns_fast_movement_cessation);
	}
}

void ns_survival_data_summary_aggregator::out_JMP_summary_data_header(std::ostream & o, const std::string & terminator) {
	for (unsigned int i = 0; i < events_to_output.size(); i++){
		std::string terminator((i != events_to_output.size()-1)?",":terminator);
		ns_survival_data_summary::out_jmp_header(std::string("Normalized to ") +ns_movement_event_to_string(events_to_output[i]),o,terminator);
	}
}

void ns_survival_data_summary_aggregator::out_JMP_summary_data(const ns_plate_list::const_iterator & region,std::ostream & o)const{
	for (unsigned int i = 0; i < events_to_output.size(); i++){
		std::string terminator((i != events_to_output.size()-1)?",":"");
		ns_plate_normalization_list::const_iterator q(region->second.find(events_to_output[i]));
		if (q == region->second.end()){
			ns_survival_data_summary::out_blank_jmp_data(o,terminator);
		}
		else{
			q->second.out_jmp_data(o,terminator);
		}
	}
}
void ns_survival_data_summary_aggregator::out_JMP_empty_summary_data(std::ostream & o){
	for (unsigned int i = 0; i < events_to_output.size(); i++){
		std::string terminator((i != events_to_output.size()-1)?",":"");
		ns_survival_data_summary::out_blank_jmp_data(o,terminator);
	}
}
void ns_survival_data_summary_aggregator::out_JMP_summary_file(std::ostream & o) const {

	ns_region_metadata::out_JMP_plate_identity_header(o);
	o<<",";
	out_JMP_summary_data_header(o,"\n");

	for (ns_plate_list::const_iterator p(plate_list.begin()); p != plate_list.end(); p++){
		if (events_to_output.size() == 0) continue;
		p->second.begin()->second.metadata.out_JMP_plate_identity_data(o) ;
		o<< ",";
		out_JMP_summary_data(p,o);
		o << "\n";
	}
}

