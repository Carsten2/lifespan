#ifndef NS_MOVEMENT_MEASUREMENT_H
#define NS_MOVEMENT_MEASUREMENT_H
#include "ns_ex.h"
#include <ostream>
#include <string>
#include "ns_movement_state.h"
#include "ns_vector.h"
#include "ns_survival_curve.h"
#include "ns_death_time_annotation_set.h"
#include <limits.h>

struct ns_worm_movemement_measurement_summary_statistics{
	ns_worm_movemement_measurement_summary_statistics():maximum_count_for_movement_state(ns_movement_number_of_states,0),minimum_count_for_movement_state(ns_movement_number_of_states,ULONG_MAX){}
	std::vector<double> maximum_count_for_movement_state;
	std::vector<double> minimum_count_for_movement_state;
};
struct ns_worm_movement_measurement_summary{
	ns_worm_movement_measurement_summary():time(0),
		number_total(0),
		number_moving_fast(0),
		number_moving_slow(0),
		number_changing_posture(0),
		number_stationary(0),
		number_not_translating(0),
		number_stationary_processed(0),
		survival(0),
		translation(0),
		number_by_hand_excluded(0),
		number_machine_excluded(0),
		number_of_worms_involving_multiple_worm_disambiguation(0),
		number_death_posture_relaxing(0),
		number_of_stationary_animal_dissapearances(0),
		number_of_moving_animal_dissapearances(0),
		net_number_of_animals_lost(0),
		number_of_deaths(0),
		processed_number_of_animals_lost(0){}
	unsigned long time;

	unsigned long number_total,
		number_moving_fast,
		number_moving_slow,
		number_changing_posture,
		number_stationary,
		number_stationary_processed,
		number_not_translating,
		number_by_hand_excluded,
		number_machine_excluded,
		number_of_worms_involving_multiple_worm_disambiguation,
		number_death_posture_relaxing,
		number_of_deaths,
		survival,
		translation,
		processed_number_of_animals_lost;
	long 	number_of_stationary_animal_dissapearances,
		number_of_moving_animal_dissapearances,
		net_number_of_animals_lost;

	void add(const ns_worm_movement_measurement_summary & s){
		number_total											+=s.number_total;
		number_moving_fast										+=s.number_moving_fast;
		number_moving_slow										+=s.number_moving_slow;
		number_changing_posture									+=s.number_changing_posture;
		number_stationary										+=s.number_stationary;
		number_stationary_processed								+=s.number_stationary_processed;
		number_not_translating									+=s.number_not_translating;
		number_by_hand_excluded									+=s.number_by_hand_excluded;
		number_machine_excluded									+=s.number_machine_excluded;
		number_of_worms_involving_multiple_worm_disambiguation	+=s.number_of_worms_involving_multiple_worm_disambiguation;
		number_death_posture_relaxing							+=s.number_death_posture_relaxing;
		number_of_deaths										+=s.number_of_deaths;
		survival												+=s.survival;
		translation												+=s.translation;
		number_of_stationary_animal_dissapearances				+=s.number_of_stationary_animal_dissapearances;
		number_of_moving_animal_dissapearances					+=s.number_of_moving_animal_dissapearances;
		net_number_of_animals_lost								+=s.net_number_of_animals_lost;
		processed_number_of_animals_lost						+=s.processed_number_of_animals_lost;
	}
	static void out_header(std::ostream & o);
	void to_file(const ns_region_metadata & metadata,const ns_worm_movemement_measurement_summary_statistics & stats,std::ostream & o) const;
	bool from_file(std::istream & o);

	unsigned long & movement_state_count(const ns_movement_state & state){
		switch(state){
			case ns_movement_fast: return number_moving_fast;
			case ns_movement_slow: return number_moving_slow;
			case ns_movement_posture: return number_changing_posture;
			case ns_movement_stationary: return number_stationary;
			case ns_movement_death_posture_relaxation: return number_death_posture_relaxing;
			default:throw ns_ex("ns_worm_movement_measurement_summary::movement_state_count():: invalid state: " )<< (long)state;
		}
	}

};

struct ns_worm_movement_summary_series{

	
	void from_death_time_annotations(const ns_death_time_annotation_compiler & annotation_set, const bool force_incomplete_paths_to_be_fast);

	ns_worm_movement_summary_series():number_uncalculated(0){}
	std::vector<ns_worm_movement_measurement_summary> measurements;
	ns_worm_movemement_measurement_summary_statistics movement_summary_statistics;
	unsigned long number_of_worms_at_start(const bool refresh_cache=true)const;	
	unsigned long number_moving_at_max_stationary;
	unsigned long number_moving_at_nt_max_stationary;
	unsigned long number_uncalculated;
	float percent_calculated() const{
		if (measurements.size()+number_uncalculated == 0) return 0; 
		return((float)measurements.size())/(float)(measurements.size()+number_uncalculated);
	}
	bool empty() const{return measurements.size()==0;}
	
	void calculate_missing_moving_worms();
	void calculate_survival();	
	void calculate_totals();
	void calculate_maximums();

	void to_file(const ns_region_metadata & metadata,std::ostream & o) const;
	void from_file(std::istream & o);
	void clear(){
		cached_number_of_worms_at_start = 0;
		measurements.clear();
		movement_summary_statistics = ns_worm_movemement_measurement_summary_statistics();
	}
	private:
	mutable unsigned long cached_number_of_worms_at_start;
};
class ns_detected_worm_info;

struct ns_worm_movement_measurement_description{
	ns_worm_movement_measurement_description(const ns_detected_worm_info * w=0,
											 const ns_movement_state & m=ns_movement_not_calculated, 
											 const ns_vector_2i & pos=ns_vector_2i(0,0),
											 const ns_vector_2i & siz = ns_vector_2i(0,0),
											 const long path_id_ = -1):
												worm_(w),movement(m),region_position(pos),region_size(siz),path_id(path_id_){}
	bool worm_specified() const {return worm_ != 0;}
	const ns_detected_worm_info & worm() const {return *worm_;}
	long path_id;
	ns_movement_state movement;
	ns_vector_2i region_position,region_size;
private:
	const ns_detected_worm_info * worm_;
};
struct ns_worm_movement_measurement_description_timepoint{
	unsigned long time;
	std::vector<ns_worm_movement_measurement_description> worms;
};

struct ns_worm_movement_description_series{
	std::vector<ns_worm_movement_measurement_description_timepoint> timepoints;

	std::vector<ns_vector_2i> group_region_position_in_source_image;
	std::vector<ns_vector_2i> group_region_sizes;
	std::vector<ns_vector_2i> group_context_position_in_source_image;
	std::vector<ns_vector_2i> group_context_sizes;
	mutable std::vector<char> group_should_be_displayed;

	void calculate_visualization_grid(const ns_vector_2i & extra_space_for_metadata = ns_vector_2i(0,0)) const ;
	void output_position_visualization_csv(std::ostream & o) const;

	private:
	mutable std::vector<ns_vector_2i> group_positions_on_visualization_grid;
	mutable ns_vector_2i visualization_grid_dimensions;
	mutable std::vector<ns_vector_2i> metadata_positions_on_visualization_grid;
	mutable ns_vector_2i metadata_dimensions;
	friend class ns_movement_summarizer;
	friend class ns_time_path_image_movement_analyzer;
};

class ns_movement_series_summary_producer{
public:
	virtual void make_movement_summary_series(ns_worm_movement_summary_series & series,const ns_movement_data_source_type::type & type) const = 0;
	virtual bool ready_to_produce_movement_data() const = 0;
	virtual std::string analysis_description(const ns_movement_data_source_type::type & type)const =0;
};

class ns_movement_series_description_producer{
public:
	virtual const ns_worm_movement_description_series & movement_description_series(const ns_movement_data_source_type::type & type) const = 0;
	virtual bool ready_to_produce_movement_data() const = 0;
};


class ns_movement_colors{
public:
	static ns_color_8 color(const ns_movement_state & m){
		switch(m){
			case ns_movement_death_posture_relaxation: return ns_color_8 (180,0,20);
			case ns_movement_stationary: return ns_color_8(255,0,0);
			case ns_movement_posture: return ns_color_8(255,255,0);
			case ns_movement_slow: return ns_color_8(0,255,0);
			case ns_movement_fast:return  ns_color_8(255,0,255);
			case ns_movement_machine_excluded: return ns_color_8(175,175,175);
			case ns_movement_by_hand_excluded: return ns_color_8(225,225,225);
			
			case ns_movement_not_calculated: return ns_color_8(0,0,0);
			default: throw ns_ex("Uknown movement color request:") << (unsigned long)m;
		}
	}
};
#endif
