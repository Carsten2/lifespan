#include "ns_movement_measurement.h"
#include "ns_vector_bitmap_interface.h"
#include "ns_time_path_solver.h"
#include <vector>

using namespace std;
template<class T>
class ns_measurement_stationary_processed_accessor{
public:
	ns_measurement_stationary_processed_accessor(T & d):data(&d){}
	inline unsigned long &operator[](const unsigned long i){
		return (*data)[i].number_stationary_processed;
	}
	inline unsigned long size(){return (unsigned long)data->size();}
	typedef unsigned long value_type;
	T * data;
};
template<class T>
class ns_measurement_not_translating_accessor{
public:
	ns_measurement_not_translating_accessor(T & d):data(&d){}
	inline unsigned long &operator[](const unsigned long i){
		return (*data)[i].number_not_translating;
	}
	typedef unsigned long value_type;
	T * data;
};
void ns_worm_movement_summary_series::calculate_totals(){
	calculate_maximums();
}

void ns_worm_movement_summary_series::calculate_survival(){
	if (measurements.size() < 3)
		return;

	//copy data over to processed slot
	for (unsigned int i = 0; i < measurements.size(); i++){
		measurements[i].number_stationary_processed = measurements[i].number_stationary;
		measurements[i].number_not_translating = measurements[i].number_changing_posture+
												 measurements[i].number_moving_slow +
												 measurements[i].number_stationary;
	}

	//smooth processed data
	//ns_measurement_stationary_processed_accessor< std::vector<ns_worm_movement_measurement_summary> > ac(measurements);
	//ns_median_smoother(ac,2);
	//ns_measurement_not_translating_accessor< std::vector<ns_worm_movement_measurement_summary> > tc(measurements);
	//ns_median_smoother(tc,2);

	unsigned long mmax(measurements[0].number_stationary_processed);
	unsigned long max_id(0);
	
	unsigned long nt_mmax(measurements[0].number_not_translating);
	unsigned long nt_max_id(0);


	//locate maximum number of stationary objects
	for (long t = 0; t < (long)measurements.size(); t++){
		if (measurements[t].number_stationary_processed > mmax){
			mmax = measurements[t].number_stationary_processed;
			max_id = t;
		}	
		if (measurements[t].number_not_translating > nt_mmax){
			nt_mmax = measurements[t].number_not_translating;
			nt_max_id = t;
		}
	}
	number_moving_at_max_stationary = measurements[max_id].number_changing_posture 
														+ measurements[max_id].number_moving_fast
									   					+ measurements[max_id].number_moving_slow;
	
	number_moving_at_nt_max_stationary = measurements[nt_max_id].number_moving_fast;

	//discard stationary objects missing after maximum
	for (long t = max_id; t < (long)measurements.size(); t++)
		measurements[t].number_stationary_processed = mmax;

	for (long t = nt_max_id; t < (long)measurements.size(); t++)
		measurements[t].number_not_translating = nt_mmax;

	//caclulate running minimum
	unsigned long mmin(ULONG_MAX);
	for (long t = max_id; t >= 0; t--){
		if (measurements[t].number_stationary_processed <= mmin){
			mmin = measurements[t].number_stationary_processed;
		}
		measurements[t].number_stationary_processed = mmin;
	}

	//caclulate running minimum
	mmin = ULONG_MAX;
	for (long t = nt_max_id; t >= 0; t--){
		if (measurements[t].number_not_translating <= mmin){
			mmin = measurements[t].number_not_translating ;
		}
		measurements[t].number_not_translating  = mmin;
	}

	for (long t = 0; t < (long)measurements.size(); t++){
		measurements[t].survival = mmax - measurements[t].number_stationary_processed;
		measurements[t].translation = nt_mmax - measurements[t].number_not_translating;
	}
	calculate_maximums();
}

void ns_worm_movement_summary_series::calculate_missing_moving_worms(){
	if (measurements.size() == 0)
		return;

	measurements[0].number_of_moving_animal_dissapearances = 0;
	measurements[0].net_number_of_animals_lost = 0;
	for (unsigned int i = 1; i < measurements.size(); i++){
		measurements[i].number_of_moving_animal_dissapearances = (
																   measurements[i-1].number_moving_fast + 
																   measurements[i-1].number_moving_slow +
																   measurements[i-1].number_changing_posture -
																   (
																	   measurements[i-1].number_by_hand_excluded +
																	   measurements[i-1].number_machine_excluded 
															
																   )
															    )
																-
																(
																   measurements[i].number_moving_fast + 
																   measurements[i].number_moving_slow +
																   measurements[i].number_changing_posture -
																   (
																	   measurements[i].number_by_hand_excluded +
																	   measurements[i].number_machine_excluded
																	  )
																)

															   - measurements[i].number_of_deaths;
		measurements[i].net_number_of_animals_lost = measurements[i].number_of_moving_animal_dissapearances + measurements[i-1].net_number_of_animals_lost;
	}
	unsigned long end_buffer(6);
	if (measurements.size() < end_buffer)
		end_buffer = 0;
	long cur_min(measurements[measurements.size()-end_buffer].net_number_of_animals_lost);
	for (long i = (long)measurements.size()-end_buffer-1; i >= 0; i--){
		if (measurements[i].net_number_of_animals_lost < cur_min)
			cur_min = measurements[i].net_number_of_animals_lost;
		measurements[i].processed_number_of_animals_lost = cur_min;
	}
	for (unsigned long i = 0; i < measurements.size()-end_buffer; i++)
		measurements[i].processed_number_of_animals_lost -= cur_min;
	for (unsigned long i = measurements.size()-end_buffer; i < measurements.size(); i++)
		measurements[i].processed_number_of_animals_lost = measurements[measurements.size()-end_buffer-1].processed_number_of_animals_lost;

	
}


void ns_worm_movement_summary_series::calculate_maximums(){
	if (measurements.size() == 0)
		return;

	std::vector<double> &max(movement_summary_statistics.maximum_count_for_movement_state);
	std::vector<double> &min(movement_summary_statistics.minimum_count_for_movement_state);

	if (max.empty())
		throw ns_ex("Incorrectly initialized max!");
	for (unsigned int i = 0; i < min.size(); i++){
		min[i] = ULONG_MAX;
		max[i] = 0;
	}
	
	//calculate maximums
	for (unsigned int i = 0; i < measurements.size(); i++){
		unsigned long total =	measurements[i].number_moving_fast + 
								measurements[i].number_moving_slow +
								measurements[i].number_changing_posture +
								measurements[i].number_machine_excluded+
								measurements[i].number_by_hand_excluded+
								measurements[i].number_stationary;
		measurements[i].number_total = total;

		if (total > max[(int)ns_movement_total])
			max[(int)ns_movement_total] =total;
		if (measurements[i].number_machine_excluded >  max[(int)ns_movement_machine_excluded])
			max[(int)ns_movement_machine_excluded] = measurements[i].number_machine_excluded;
		if (measurements[i].number_by_hand_excluded >  max[(int)ns_movement_by_hand_excluded])
			max[(int)ns_movement_by_hand_excluded] = measurements[i].number_by_hand_excluded;
		if (measurements[i].number_moving_fast >  max[(int)ns_movement_fast])
			max[(int)ns_movement_fast] = measurements[i].number_moving_fast;
		if (measurements[i].number_moving_slow >  max[(int)ns_movement_slow])
			max[(int)ns_movement_slow] = measurements[i].number_moving_slow;
		if (measurements[i].number_changing_posture >  max[(int)ns_movement_posture])
			max[(int)ns_movement_posture] = measurements[i].number_changing_posture;
		if (measurements[i].number_stationary >  max[(int)ns_movement_stationary])
			max[(int)ns_movement_stationary] = measurements[i].number_stationary;

		if (total < min[(int)ns_movement_total])
			min[(int)ns_movement_total] =total;
		if (measurements[i].number_machine_excluded <  min[(int)ns_movement_machine_excluded])
			min[(int)ns_movement_machine_excluded] = measurements[i].number_machine_excluded;
		if (measurements[i].number_by_hand_excluded <  min[(int)ns_movement_by_hand_excluded])
			min[(int)ns_movement_by_hand_excluded] = measurements[i].number_by_hand_excluded;
		if (measurements[i].number_moving_fast <  min[(int)ns_movement_fast])
			min[(int)ns_movement_fast] = measurements[i].number_moving_fast;
		if (measurements[i].number_moving_slow <  min[(int)ns_movement_slow])
			min[(int)ns_movement_slow] = measurements[i].number_moving_slow;
		if (measurements[i].number_changing_posture <  min[(int)ns_movement_posture])
			min[(int)ns_movement_posture] = measurements[i].number_changing_posture;
		if (measurements[i].number_stationary <  min[(int)ns_movement_stationary])
			min[(int)ns_movement_stationary] = measurements[i].number_stationary;
	}
}

void ns_worm_movement_summary_series::to_file(const ns_region_metadata & metadata,std::ostream & o) const{
	for (unsigned int i = 0; i < measurements.size(); i++){
		measurements[i].to_file(metadata,this->movement_summary_statistics,o);
		o << "\n";
	}
}

void ns_worm_movement_summary_series::from_file(std::istream & i){
	std::string in;
	getline(i,in,'\n');
	measurements.reserve(100);
	while(true){
		std::string::size_type s(measurements.size());
		measurements.resize(s+1);
		if (!measurements[s].from_file(i)){
			measurements.resize(s);
			break;
		}
	}
}


void ns_worm_movement_measurement_summary::out_header(std::ostream & o){
	o << "Strain,Genotype,Strain Condition 1,Strain Condition 2,Genotype::Condition,Plate Name,Time (Seconds), Time (Hours),Time (Days),"
		"Total,Moving Fast,Moving Slow,Changing Posture,Stationary,"
		  "Machine Excluded, By Hand Excluded, Involving Multiple Worm Disambiguation, Number of Stationary Animal Disappearances, Number of Moving Animal Disappearances,Net Number of Moving Worms Lost, Processed Net Number of Moving worms Lost, Number of Deaths,"
		  "Fraction Moving Fast, Fraction Moving, Fraction Stationary,"
		  "Min Normalized Total,Min Normalized Moving Fast,Min Normalized Moving Slow,Min Normalized Changing Posture,Min Normalized Stationary, Fraction of Maximum Total Currently Present,Fraction of Max Moving Fast, Fraction of Max Stationary\n";
}
void ns_worm_movement_measurement_summary::to_file(const ns_region_metadata & metadata,const ns_worm_movemement_measurement_summary_statistics & stats,ostream & o) const{
	o << metadata.strain << "," << metadata.genotype << ","
		<< metadata.strain_condition_1 << "," << metadata.strain_condition_2 << "," 
		<<((metadata.genotype.size()>0)?metadata.genotype:metadata.strain) 
			<< ((metadata.strain_condition_1.size()>0)?(string("::") + metadata.strain_condition_1):"")
			<< ((metadata.strain_condition_2.size()>0)?(string("::") + metadata.strain_condition_2):"")
			<< "," << metadata.plate_name()
		<< "," << time 
		<< "," << time/(60.0*60)
		<< "," << time/(60.0*60*24) << ","
		<< (long)number_total << ","
		<< (long)number_moving_fast << ","
		<< (long)number_moving_slow << ","
		<< (long)number_changing_posture << ","
		<< (long)number_stationary << "," 
		<< (long)number_machine_excluded << ","
		<< (long)number_by_hand_excluded << ","
		<< (long)number_of_worms_involving_multiple_worm_disambiguation <<","
		<< (long)number_of_stationary_animal_dissapearances<< ","
		<< (long)number_of_moving_animal_dissapearances << ","
		<< (long)net_number_of_animals_lost << ","
		<< (long)processed_number_of_animals_lost << ","
		<< (long)number_of_deaths << ",";
		if (number_total == 0){
			o << "0,0,0,";
		}
		else{
			o << (number_moving_fast)/((float)number_total) << ","
				<< (number_moving_fast + number_moving_slow + number_changing_posture)/((float)number_total) << ","
				 << (number_stationary)/((float)number_total) << ",";
		}
		unsigned long total_range(stats.maximum_count_for_movement_state[(int)ns_movement_total] - stats.minimum_count_for_movement_state[(int)ns_movement_total]),
					  fast_range(stats.maximum_count_for_movement_state[(int)ns_movement_fast] - stats.minimum_count_for_movement_state[(int)ns_movement_fast]),
					  slow_range(stats.maximum_count_for_movement_state[(int)ns_movement_slow] - stats.minimum_count_for_movement_state[(int)ns_movement_slow]),
					  posture_range(stats.maximum_count_for_movement_state[(int)ns_movement_posture] - stats.minimum_count_for_movement_state[(int)ns_movement_posture]),
					  stationary_range(stats.maximum_count_for_movement_state[(int)ns_movement_stationary] - stats.minimum_count_for_movement_state[(int)ns_movement_stationary]);
	
		unsigned long total_min(stats.minimum_count_for_movement_state[(int)ns_movement_total]),
					  fast_min(stats.minimum_count_for_movement_state[(int)ns_movement_fast]),
					  slow_min(stats.minimum_count_for_movement_state[(int)ns_movement_slow]),
					  posture_min(stats.minimum_count_for_movement_state[(int)ns_movement_posture]),
					  stationary_min(stats.minimum_count_for_movement_state[(int)ns_movement_stationary]);

		o << (long)number_total-total_min << ","
			<< (long)number_moving_fast - fast_min<< ","
			<< (long)number_moving_slow - slow_min << ","
			<< (long)number_changing_posture - posture_min<< ","
			<< (long)number_stationary - stationary_min<< ",";
		unsigned long total_max(stats.maximum_count_for_movement_state[(int)ns_movement_total]);
		if (total_max == 0){
			o << "0,0,0";
		}
		else{
			o << (number_moving_fast)/((float)total_max) << ","
				<< (number_moving_fast + number_moving_slow + number_changing_posture)/((float)total_max) << ","
				 << (number_stationary)/((float)total_max);
		}

}
bool ns_worm_movement_measurement_summary::from_file(istream & i){
	throw ns_ex("Depreciated");
	return true;
}

std::string ns_movement_data_source_type::type_string(const ns_movement_data_source_type::type & t){
	switch (t){
		case ns_time_path_analysis_data: return "time_path";
		case ns_time_path_image_analysis_data: return "time_path_image";
		case ns_triplet_data: return "triplet";
		case ns_triplet_interpolated_data: return "triplet_interpolated";
	}
	throw ns_ex("ns_movement_series_summary_producer::type_string()::Unknown source type: ") << (unsigned long)t;
}



void ns_worm_movement_description_series::output_position_visualization_csv(std::ostream & o) const{
	ns_time_path_solution::output_visualization_csv_header(o);
	//output unassigned points
	for (unsigned int i = 0; i< timepoints.size(); i++){
		for (unsigned int j = 0; j < timepoints[i].worms.size(); j++){
			ns_time_path_solution::output_visualization_csv_data(o,
				(timepoints[i].time - timepoints[0].time)/60.0/60.0/24.0,
				timepoints[i].time,
				timepoints[i].worms[j].region_position + timepoints[i].worms[j].region_size/2,
				timepoints[i].worms[j].region_size,
				timepoints[i].worms[j].path_id, 0,
				0,(timepoints[i].worms[j].movement == ns_movement_machine_excluded || 
				timepoints[i].worms[j].movement == ns_movement_by_hand_excluded),0,0,
				timepoints[i].worms[j].movement
				);
		}
	}
}
typedef std::map<unsigned long,ns_worm_movement_measurement_summary> ns_events_ordered_in_time;

typedef std::map<unsigned long,ns_events_ordered_in_time> ns_region_events;

void ns_worm_movement_summary_series::from_death_time_annotations(const ns_death_time_annotation_compiler & annotation_set, const bool force_incomplete_paths_to_be_fast){
	
	//first we get a time series of events for each region
	ns_region_events region_events;
	for (ns_death_time_annotation_compiler::ns_region_list::const_iterator p(annotation_set.regions.begin()); p!= annotation_set.regions.end(); ++p){
		for (ns_death_time_annotation_compiler_region::ns_location_list::const_iterator q(p->second.locations.begin()); q != p->second.locations.end(); q++){

			for (unsigned int i = 0; i < q->annotations.size(); i++){
				if (q->annotations[i].type !=  ns_fast_moving_worm_observed &&
					q->annotations[i].type !=  ns_slow_moving_worm_observed &&
					q->annotations[i].type !=  ns_posture_changing_worm_observed &&
					q->annotations[i].type !=  ns_stationary_worm_observed &&
					q->annotations[i].type != ns_stationary_worm_disappearance &&
					q->annotations[i].type != ns_movement_cessation)
					continue;
				
				region_events[p->first][q->annotations[i].time.end_time].number_machine_excluded+= q->properties.number_of_extra_worms_at_location;
	///			if (q->number_of_extra_worms > 0)
	///				cerr << "Found " << q->number_of_extra_worms << " worms\n";
				if (q->annotations[i].disambiguation_type == ns_death_time_annotation::ns_part_of_a_mutliple_worm_disambiguation_cluster)
					region_events[p->first][q->annotations[i].time.end_time].number_of_worms_involving_multiple_worm_disambiguation++;

				//fast moving objects are not excluded by hand annotations because
				//they are likely only briefly passing through that position.
				if (q->properties.excluded == ns_death_time_annotation::ns_by_hand_excluded && q->annotations[i].type!=  ns_fast_moving_worm_observed)
					region_events[p->first][q->annotations[i].time.end_time].number_by_hand_excluded++;
				else if ((q->properties.excluded == ns_death_time_annotation::ns_by_hand_excluded || 
						  q->properties.excluded == ns_death_time_annotation::ns_both_excluded) && q->annotations[i].type !=  ns_fast_moving_worm_observed){
					region_events[p->first][q->annotations[i].time.end_time].number_machine_excluded++;
				}
				else{
					switch(q->annotations[i].type){
						case ns_fast_moving_worm_observed: 
							region_events[p->first][q->annotations[i].time.end_time].number_moving_fast++; break;
						case ns_slow_moving_worm_observed: 
							if (force_incomplete_paths_to_be_fast && !q->annotations[i].animal_is_part_of_a_complete_trace)
								region_events[p->first][q->annotations[i].time.end_time].number_moving_fast++;
							else
								region_events[p->first][q->annotations[i].time.end_time].number_moving_slow++; break;
						case ns_posture_changing_worm_observed: 
							if (force_incomplete_paths_to_be_fast && !q->annotations[i].animal_is_part_of_a_complete_trace)
								region_events[p->first][q->annotations[i].time.end_time].number_moving_fast++;
							else
								region_events[p->first][q->annotations[i].time.end_time].number_changing_posture++; break;
						case ns_stationary_worm_observed: 
							region_events[p->first][q->annotations[i].time.end_time].number_stationary++; break;
						case ns_stationary_worm_disappearance:
							region_events[p->first][q->annotations[i].time.end_time].number_of_stationary_animal_dissapearances++;break;
						case ns_movement_cessation:
							region_events[p->first][q->annotations[i].time.end_time].number_of_deaths++;break;
					}
				}
			}
		}
	}

	std::set<unsigned long> all_times;
	for (ns_region_events::iterator p = region_events.begin(); p!=region_events.end(); p++){
		for (ns_events_ordered_in_time::iterator q = p->second.begin(); q != p->second.end(); q++){
			all_times.insert(all_times.end(),q->first);
		}
	}
	measurements.resize(0);
	measurements.resize(all_times.size());
	std::set<unsigned long>::iterator t(all_times.begin());
	for (unsigned int i = 0; i < measurements.size(); i++){
		measurements[i].time = *t;
		t++;
	}
	//each measurement in a region indicates that for a span of time a worm was detected in a position.
	//we go through for each span in the region (that is, each interval between region_events[i][j] and region_events[i][j+1])
	//and increment the total number of worms for each measurement[] time point found between these points.
	
	//this is done this way because different regions are measured at different times and we have to aggregate them properly.

	unsigned long current_index_in_aggregate_data;
	for (ns_region_events::iterator cur_region_events = region_events.begin(); cur_region_events!=region_events.end(); cur_region_events++){

		current_index_in_aggregate_data = 0;
		for (ns_events_ordered_in_time::iterator current_measurement = cur_region_events->second.begin();; current_measurement++){
			ns_events_ordered_in_time::iterator next_measurement(current_measurement);
			next_measurement++;
			if(next_measurement == cur_region_events->second.end()){
				//extend the last measurement of the plate to the end of the expeirment.
				//this prevents the total number of worms measured to remain meaningful during the last few time points of an experiment
				//where an increasing number of plates are no longer being measured.

				for (;current_index_in_aggregate_data < measurements.size(); current_index_in_aggregate_data++)
					measurements[current_index_in_aggregate_data].add(current_measurement->second);
				break;
			}
			for (;measurements[current_index_in_aggregate_data].time < next_measurement->first; current_index_in_aggregate_data++){
				measurements[current_index_in_aggregate_data].add(current_measurement->second);
			}
		}
		
	}

}



void ns_worm_movement_description_series::calculate_visualization_grid(const ns_vector_2i & extra_space_for_metadata) const{
	
	const bool include_metadata(extra_space_for_metadata.x > 0);

	const vector<ns_vector_2i> & sizes(group_context_sizes);


	//identify paths that should be included in the visualization
	group_should_be_displayed.resize(sizes.size(),0);
	unsigned long output_group_count(0);
	for (unsigned int t = 0; t < timepoints.size(); t++){
		for (unsigned int i = 0; i < timepoints[t].worms.size(); i++){
			if (timepoints[t].worms[i].path_id == -1) continue;
			if (timepoints[t].worms[i].path_id >= group_should_be_displayed.size())
				throw ns_ex("ns_worm_movement_description_series::calculate_visualization_grid()::Inconsistant path labeling!  Path id ")
					<< timepoints[t].worms[i].path_id << " found in description series with " << group_should_be_displayed.size() << " groups specified.";
			if (/*timepoints[t].worms[i].movement != ns_movement_fast && */
				group_should_be_displayed[timepoints[t].worms[i].path_id] == 0){
				group_should_be_displayed[timepoints[t].worms[i].path_id] = 1;
				output_group_count++;
			}
		}
	}
	
	if (output_group_count == 0)
		throw ns_ex("Region Contained No Paths");
	group_positions_on_visualization_grid.resize(group_context_sizes.size());
	if (include_metadata){
		metadata_dimensions = extra_space_for_metadata;
		metadata_positions_on_visualization_grid.resize(group_context_sizes.size());
	}

	const unsigned long worms_per_row((unsigned long)ceil(1.3*sqrt((double)output_group_count)));
	const unsigned long border = 15;
	unsigned long current_row_height(0);
	unsigned long maximum_row_width(0);
	ns_vector_2i cur_pos(border,border);

	unsigned long paths_placed(0);
	for (unsigned int i = 0; i < sizes.size(); i++){
		if(!group_should_be_displayed[i]){
			metadata_positions_on_visualization_grid[i] = ns_vector_2i(0,0);
			group_positions_on_visualization_grid[i] = ns_vector_2i(0,0);
			continue;
		}
	//	cerr << group_position[i] << " by " << sizes[i] << "\n";
		group_positions_on_visualization_grid[i] = cur_pos;
		if (include_metadata)
			metadata_positions_on_visualization_grid[i] = cur_pos + ns_vector_2i(0,sizes[i].y);

		ns_vector_2i item_size(sizes[i]);
		if (include_metadata){
			if (sizes[i].x < metadata_dimensions.x)
				item_size.x = metadata_dimensions.x;
			item_size.y += metadata_dimensions.y;
		}

		cur_pos.x += item_size.x + border;

		if (item_size.y > current_row_height)
			current_row_height = item_size.y;

		if (cur_pos.x > maximum_row_width)
			 maximum_row_width = cur_pos.x;

		if (paths_placed%worms_per_row == worms_per_row-1){
			cur_pos.x = border;
			cur_pos.y+=current_row_height + border;
			current_row_height = 0;
		}
		paths_placed++;
	}
	 visualization_grid_dimensions.x =  maximum_row_width;
	 visualization_grid_dimensions.y = cur_pos.y + current_row_height + border;
}
